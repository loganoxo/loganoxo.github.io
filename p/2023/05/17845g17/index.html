<!doctype html><html lang=zh-cn dir=ltr><head><meta charset=utf-8><meta name=viewport content='width=device-width,initial-scale=1'><meta name=description content="JVM底层原理"><meta name=keywords content="JVM"><title>13-垃圾回收器</title>
<link rel=canonical href=https://logan.wssw.fun/p/2023/05/17845g17/><link rel=stylesheet href=/scss/preload.min.32ee2aad8e18a40378a2032c6c3d06fa17729e6fc8bbeeb7064da7ff3826f80b.css crossorigin=anonymous><script src=/ts/preload.min.5a9adf4d684a430995e4a2d6d4231b23de7250e2db58b5829c2162e940eccac7.js crossorigin=anonymous></script><link rel=stylesheet href=/scss/style.min.e3309acc1a8da8b9c61300d44feaaad6ec1444c5b41576c047c8057958cb8411.css><meta property='og:title' content="13-垃圾回收器"><meta property='og:description' content="JVM底层原理"><meta property='og:url' content='https://logan.wssw.fun/p/2023/05/17845g17/'><meta property='og:site_name' content='Logan的博客'><meta property='og:type' content='article'><meta property='article:section' content='Draft'><meta property='article:tag' content='JVM'><meta property='article:published_time' content='2023-05-03T03:17:32+08:00'><meta property='article:modified_time' content='2024-05-08T21:39:00+08:00'><meta property='og:image' content='https://logan.wssw.fun/img/share.jpg'><meta name=twitter:site content="@loganovo297796"><meta name=twitter:creator content="@loganovo297796"><meta name=twitter:title content="13-垃圾回收器"><meta name=twitter:description content="JVM底层原理"><meta name=twitter:card content="summary"><meta name=twitter:image content='https://logan.wssw.fun/img/share.jpg'><link rel=apple-touch-icon sizes=180x180 href=/apple-touch-icon.png><link rel=icon type=image/png sizes=32x32 href=/favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=/favicon-16x16.png><link rel=manifest href=/site.webmanifest><script async src="https://www.googletagmanager.com/gtag/js?id=G-R7GQB9XXQW"></script><script>var dnt,doNotTrack=!1;if(!1&&(dnt=navigator.doNotTrack||window.doNotTrack||navigator.msDoNotTrack,doNotTrack=dnt=="1"||dnt=="yes"),!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-R7GQB9XXQW")}</script><meta name=google-site-verification content="3CAZCWVpDIWQxfZCqLMpov13bCzaH1QdnlHZTNnNjfM"><link rel=preload as=style onload='this.rel="stylesheet"' href=https://cdn.bootcdn.net/ajax/libs/lxgw-wenkai-screen-webfont/1.7.0/style.min.css crossorigin=anonymous><script src=https://cdn.bootcdn.net/ajax/libs/busuanzi/2.3.0/bsz.pure.mini.min.js crossorigin=anonymous async></script><meta name=referrer content="no-referrer-when-downgrade"><script src=/js/sceneanimation.min.8c8c65611aaf0c8996e6d8a06f3e3bc82e6c8d2d2ab542e7cde8df7bceeeba9e.js crossorigin=anonymous async></script></head><body class=article-page><div id=loading-box><div class=loading-left-bg></div><div class=loading-right-bg></div><div class=spinner-box><div class=configure-border-1><div class=configure-core></div></div><div class=configure-border-2><div class=configure-core></div></div><div class=loading-word>加载中...</div></div></div><script>(function(){const e="StackColorScheme";localStorage.getItem(e)||localStorage.setItem(e,"dark")})()</script><script>(function(){const t="StackColorScheme",e=localStorage.getItem(t),n=window.matchMedia("(prefers-color-scheme: dark)").matches===!0;e==="dark"||e==="auto"&&n?document.documentElement.dataset.scheme="dark":document.documentElement.dataset.scheme="light"})()</script><div class="container main-container flex on-phone--column extended"><aside class="sidebar left-sidebar sticky"><a id=dark-mode-toggle-mine type=button aria-label=切换主题 href=javascript:void(0)><svg class="icon icon-tabler icon-tabler-toggle-left" viewBox="0 0 1025 1024" xmlns="http://www.w3.org/2000/svg" p-id="14930" width="128" height="128"><path d="M253.939302 502.92736a269.74208 269.74208.0 00122.90048 235.84768 257.024 257.024.0 00259.95264 9.07264c81.46944-44.27776 135.70048-130.49856 139.0592-226.7136 5.14048-147.3536-107.37664-270.1312-250.63424-275.1488-145.32608-5.05856-266.1376 109.568-271.27808 256.94208zM531.730022.3072c16.384.57344 32.256 15.48288 31.62112 33.8944l-3.72736 106.43456c-.57344 16.384-15.4624 32.256-33.8944 31.60064-16.384-.57344-32.23552-15.4624-31.60064-33.8944l3.72736-106.43456c2.74432-20.3776 15.4624-32.23552 33.87392-31.60064zm493.89568 527.52384c-.57344 16.384-13.35296 30.26944-33.8944 31.60064l-104.36608-3.64544c-16.384-.57344-32.19456-17.53088-31.62112-33.8944.57344-16.384 15.48288-32.256 33.8944-31.60064l104.38656 3.64544a32.3584 32.3584.0 0131.60064 33.8944zm-855.53152-29.9008c-.57344 16.384-13.35296 30.28992-33.8944 31.62112l-104.38656-3.64544c-16.384-.57344-32.17408-17.5104-31.60064-33.8944.57344-16.384 15.4624-32.256 33.8944-31.60064l104.38656 3.64544a32.3584 32.3584.0 0131.60064 33.8944zm325.91872 525.76256c-16.384-.57344-32.256-15.48288-31.62112-33.8944l3.72736-106.43456c.57344-16.384 15.4624-32.256 33.8944-31.60064 16.384.57344 32.23552 15.4624 31.60064 33.8944l-3.72736 106.43456c-2.74432 20.3776-17.5104 32.1536-33.87392 31.60064zm401.32608-871.26016c11.85792 12.6976 11.0592 35.2256-1.6384 47.06304l-78.37696 73.09312c-12.6976 11.85792-33.1776 11.14112-47.08352-1.6384-11.83744-12.6976-11.0592-35.2256 1.6384-47.08352l78.39744-73.09312c16.85504-13.74208 35.2256-11.0592 47.06304 1.6384zm-15.50336 737.1776c-12.6976 11.85792-31.1296 11.22304-47.06304-1.6384l-70.9632-80.34304c-11.85792-12.6976-11.0592-35.2256 1.6384-47.08352s35.2256-11.0592 47.08352 1.6384l73.07264 78.37696c9.728 14.68416 8.94976 37.21216-3.76832 49.0496zm-596.31616-645.8368c-12.6976 11.85792-31.1296 11.20256-47.06304-1.6384l-73.09312-78.37696c-11.85792-12.6976-11.0592-35.2256 1.6384-47.08352s35.2256-11.0592 47.08352 1.6384l73.09312 78.37696c11.776 14.7456 11.0592 35.2256-1.6384 47.08352zm-138.24 614.05184c-11.85792-12.71808-11.0592-35.2256 1.6384-47.08352l78.37696-73.09312c12.6976-11.83744 33.1776-11.12064 47.08352 1.6384 11.83744 12.71808 11.0592 35.2256-1.6384 47.104l-78.39744 73.07264c-16.7936 11.71456-35.2256 11.0592-47.06304-1.6384z" fill="#ffb948"/></svg>
<svg class="icon icon-tabler icon-tabler-toggle-right" viewBox="0 0 1024 1024" xmlns="http://www.w3.org/2000/svg" width="128" height="128"><path d="M578.256332 591.814252v-82.970701m0 95.54202a12.655127 12.655127.0 01-12.571318-12.571319v-82.970701a12.571318 12.571318.0 1125.142636.0v82.970701a12.571318 12.571318.0 01-12.571318 12.571319z" fill="#f89b1b"/><path d="M598.873294 479.342858a36.959676 36.959676.0 01-27.573092-61.59946 52.380493 52.380493.0 1062.521357 36.540632 36.875867 36.875867.0 01-34.948265 25.058828zm204.0744-109.035234v-82.970701m0 95.542019a12.571318 12.571318.0 01-12.571318-12.571318v-82.970701a12.571318 12.571318.0 1125.142636.0v82.970701a12.571318 12.571318.0 01-12.571318 12.571318z" fill="#f89b1b"/><path d="M823.9837 257.83623a36.959676 36.959676.0 01-27.6569-61.515651 52.129067 52.129067.0 1064.616576 50.285273 53.050963 53.050963.0 00-2.011411-14.163685A36.875867 36.875867.0 01823.9837 257.83623z" fill="#f89b1b"/><path d="M803.282929 328.822274a59.588049 59.588049.0 0159.588049 59.588048V785.66398H743.694881V388.410322a59.588049 59.588049.0 0159.588048-59.588048zM581.776301 551.16699a143.145411 143.145411.0 01143.145411 143.145411V837.54162H438.463272V694.312401A143.145411 143.145411.0 01581.776301 551.16699z" fill="#612273"/><path d="M600.968514 198.667225l-49.111951-4.693292a8.380879 8.380879.0 01-7.039938-5.196145l-17.599845-42.658674a8.380879 8.380879.0 00-15.672244.0l-17.432228 42.658674a8.380879 8.380879.0 01-7.039938 5.196145l-49.11195 4.693292a8.380879 8.380879.0 00-4.777101 14.750347l36.959676 32.51781a8.380879 8.380879.0 012.681881 8.380878l-11.06276 45.67579a8.380879 8.380879.0 0012.487509 9.302776L515.232123 285.074086a8.380879 8.380879.0 018.380879.0l40.982497 24.136931a8.380879 8.380879.0 0012.571319-9.302776l-10.978952-45.675789a8.380879 8.380879.0 012.681882-8.380879L606.08085 213.417572a8.380879 8.380879.0 00-5.028528-14.750347z" fill="#fed150"/><path d="M470.897274 246.77347l1.927602-8.380879a8.380879 8.380879.0 00-2.681881-8.380879l-35.032074-30.506399a8.380879 8.380879.0 00-1.927602 13.912259l36.959676 32.51781a6.788512 6.788512.0 01.754279.838088zM603.98563 199.589122l-34.948265 30.674016a8.380879 8.380879.0 00-2.681881 8.380879l1.927602 8.380879a6.788512 6.788512.0 01.754279-.838088l37.043485-32.769236a8.380879 8.380879.0 00-2.09522-13.82845zm-28.578797 92.189667a8.380879 8.380879.0 01-10.643716 1.759985l-40.982498-24.053123a8.380879 8.380879.0 00-8.380879.0L474.249625 293.454965a8.380879 8.380879.0 01-10.643716-1.676176l-1.927602 8.380879a8.380879 8.380879.0 0012.487509 9.302775l41.066307-24.388357a8.380879 8.380879.0 018.380879.0l40.982497 24.136931a8.380879 8.380879.0 0012.571319-9.302776z" fill="#fed150" opacity=".5"/><path d="M434.608068 426.543321l-28.159753-2.681881a4.86091 4.86091.0 01-4.022822-3.017117l-10.057054-24.388357a4.86091 4.86091.0 00-8.967541.0l-9.973245 24.388357a4.693292 4.693292.0 01-4.022822 3.017117l-28.159753 2.681881a4.86091 4.86091.0 00-2.76569 8.380879l21.203623 18.605551a4.944719 4.944719.0 011.592367 4.777101L354.654484 484.455194a4.86091 4.86091.0 007.123747 5.363762l23.466461-13.82845a5.196145 5.196145.0 014.944718.0l23.466461 13.82845a4.86091 4.86091.0 007.123747-5.363762l-6.285659-26.064533a4.86091 4.86091.0 011.508558-4.777101l21.203624-18.605551a4.86091 4.86091.0 00-2.849499-8.380879z" fill="#fed150"/><path d="M360.102055 454.032604l1.173323-4.609484a4.944719 4.944719.0 00-1.592367-5.112336l-20.0303-17.683654a4.944719 4.944719.0 00-1.173323 8.380879l21.203623 18.605551zm76.182189-26.98643-20.0303 17.26461a4.86091 4.86091.0 00-1.508559 4.777101l1.173323 4.693292v-.502852l21.203624-18.605551a4.86091 4.86091.0 00-.838088-7.6266zM419.94153 479.845711a4.777101 4.777101.0 01-6.034233 1.005705l-23.46646-13.82845a5.196145 5.196145.0 00-4.944719.0l-23.466461 13.82845a4.777101 4.777101.0 01-6.034233-1.005705l-1.089514 4.609483a4.86091 4.86091.0 007.123747 5.363762l23.466461-13.82845a5.196145 5.196145.0 014.944719.0l23.46646 13.82845a4.86091 4.86091.0 007.123747-5.363762z" fill="#fed150" opacity=".5"/><path d="M635.413926 803.68287A414.685886 414.685886.0 01459.41547 18.729756 9.805628 9.805628.0 00453.967898.124205a513.831683 513.831683.0 10567.050264 607.027056 9.805628 9.805628.0 00-18.186507-6.704704A414.350651 414.350651.0 01635.413926 803.68287z" fill="#fed150" p-id="22313"/><path d="M50.931434 292.868303a460.110249 460.110249.0 00275.311871 359.455895 413.847798 413.847798.0 01133.339782-633.594442A9.805628 9.805628.0 00453.967898.124205 513.915492 513.915492.0 0050.931434 292.868303z" fill="#fed150" opacity=".4" p-id="22314"/><path d="M1006.016389 597.261823A513.664065 513.664065.0 013.914704 475.320036c-.670471 10.308481-1.257132 20.616962-1.257132 31.093061a513.831683 513.831683.0 001018.36059 100.570546 9.805628 9.805628.0 00-15.001773-9.72182zM231.539373 332.258434c0 7.458982.67047 14.917964 1.257132 22.293138A414.769695 414.769695.0 01459.583087 18.729756 9.805628 9.805628.0 00453.967898.124205a505.869848 505.869848.0 00-94.620122 20.868388A413.177328 413.177328.0 00231.539373 332.258434z" fill="#fed150" opacity=".5" p-id="22315"/><path d="M715.032275 421.514794m17.683654.0h141.217809q17.683654.0 17.683655 17.683654v-.083809q0 17.683654-17.683655 17.683655H732.715929q-17.683654.0-17.683654-17.683655v.083809q0-17.683654 17.683654-17.683654z" fill="#eb3d72" p-id="22316"/><path d="M205.139605 319.603307c4.441866-6.872321 22.041711-45.340555-11.817039-67.047031s-51.626214 8.380879-51.626214 8.380879a25.142637 25.142637.0 1042.742482 27.489282s2.179029 5.950424-6.537085 18.437934-25.142637 12.236083-43.077718.754279-47.01673-65.789899-.67047-138.787354c1.592367-2.514264 3.352352-4.693292 5.028527-7.039938a26.818812 26.818812.0 00-23.047417-2.430455 33.523515 33.523515.0 00-18.689359 17.683654c-31.260678 64.36515-22.628373 127.724594 21.203623 155.884347 48.944333 31.093061 82.048804-6.453277 86.49067-13.325597zM734.224488 931.491272c6.453277-2.681881 37.713955-21.45505 24.304548-53.386198s-40.647262-19.35983-40.647262-19.35983a21.874094 21.874094.0 1016.761757 40.312027s-1.340941 5.363762-13.577023 9.973246S697.264812 905.259122 689.889638 888.497364s-1.340941-69.561295 67.047031-98.894371c2.346646-1.005705 4.693292-1.676176 7.039938-2.514263a31.931148 31.931148.0 00-1.927602-3.352352 28.578797 28.578797.0 00-38.635851-7.542791c-51.87764 30.841634-74.422204 81.545951-57.325212 122.277023 19.778874 46.262451 61.59946 35.786353 68.136546 33.020662zM279.813236 802.844782c-5.950424-3.687587-39.390131-18.354125-57.660447 11.146569s7.794217 44.334849 7.794217 44.334849a21.874094 21.874094.0 1023.047417-36.875867s5.112336-2.011411 16.007479 5.279954 10.811334 21.622667 1.173323 37.211102-55.984271 41.317733-119.511333 2.430455c-2.179029-1.340941-4.106631-2.849499-6.118041-4.274249a22.376947 22.376947.0 00-1.676176 3.51997 28.662606 28.662606.0 0016.342714 36.037779c55.146183 24.388357 109.538087 13.409406 132.920739-24.136931 26.399768-42.9101-6.369468-70.902235-12.319892-74.673631zM431.00429 694.312401h302.298301m0 20.952197H431.00429a20.952197 20.952197.0 010-41.904394h302.298301a20.952197 20.952197.0 010 41.904394z" fill="#eb3d72" p-id="22317"/><path d="M255.760113 683.082023m-30.171164.0a30.171164 30.171164.0 1060.342328.0 30.171164 30.171164.0 10-60.342328.0z" fill="#fed150" opacity=".4" p-id="22318"/><path d="M356.246851 840.977781m-30.171164.0a30.171164 30.171164.0 1060.342328.0 30.171164 30.171164.0 10-60.342328.0z" fill="#fed150" opacity=".4" p-id="22319"/><path d="M54.870447 472.135302m-30.171164.0a30.171164 30.171164.0 1060.342328.0 30.171164 30.171164.0 10-60.342328.0z" fill="#fed150" opacity=".4" p-id="22320"/><path d="M561.410765 873.914635m-30.171164.0a30.171164 30.171164.0 1060.342328.0 30.171164 30.171164.0 10-60.342328.0z" fill="#fed150" opacity=".5" p-id="22321"/><path d="M445.167976 825.13792m-19.862683.0a19.862683 19.862683.0 1039.725365.0 19.862683 19.862683.0 10-39.725365.0z" fill="#fed150" opacity=".5" p-id="22322"/><path d="M149.406761 689.786726m-19.862683.0a19.862683 19.862683.0 1039.725365.0 19.862683 19.862683.0 10-39.725365.0z" fill="#fed150" opacity=".5" p-id="22323"/><path d="M132.225959 633.299603m-18.940786.0a18.940786 18.940786.0 1037.881572.0 18.940786 18.940786.0 10-37.881572.0z" fill="#fed150" opacity=".4" p-id="22324"/><path d="M475.339139 906.935297m-18.940786.0a18.940786 18.940786.0 1037.881573.0 18.940786 18.940786.0 10-37.881573.0z" fill="#fed150" opacity=".4" p-id="22325"/></svg>
<span>切换</span></a><div id=article-toolbar><a href=/ type=button class=back-home id=back-toggle aria-label=主页><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-chevron-left" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"/><path d="M15 6l-6 6 6 6"/></svg>
<span>HOME</span></a></div><button class="hamburger hamburger--spin" type=button id=toggle-menu aria-label=切换菜单>
<span class=hamburger-box><span class=hamburger-inner></span></span></button><header><figure class=site-avatar><a href=/><img src=/img/avatar-3K_hu560d426f92925c766fafa78be2429fd1_3226_300x0_resize_box_3.png width=300 height=300 class=site-logo loading=lazy decoding=async alt=Avatar>
</a><span class=emoji>🍥</span></figure><div class=site-meta><h1 class=site-name><a href=/>Logan🌀</a></h1><h2 class=site-description>Starry serenade ✍️</h2></div></header><ol class=menu-social><li><a href=https://github.com/loganoxo target=_blank title=GitHub rel=me><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-brand-github" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"/><path d="M9 19c-4.3 1.4-4.3-2.5-6-3m12 5v-3.5c0-1 .1-1.4-.5-2 2.8-.3 5.5-1.4 5.5-6a4.6 4.6.0 00-1.3-3.2 4.2 4.2.0 00-.1-3.2s-1.1-.3-3.5 1.3a12.3 12.3.0 00-6.2.0C6.5 2.8 5.4 3.1 5.4 3.1a4.2 4.2.0 00-.1 3.2A4.6 4.6.0 004 9.5c0 4.6 2.7 5.7 5.5 6-.6.6-.6 1.2-.5 2V21"/></svg></a></li><li><a href=https://blog.csdn.net/u014229652 target=_blank title=my_csdn rel=me><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-copyright" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><circle cx="12" cy="12" r="9"/><path d="M14.5 9a3.5 4 0 100 6"/></svg></a></li><li><a href=https://twitter.com target=_blank title=Twitter rel=me><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-brand-twitter" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"/><path d="M22 4.01c-1 .49-1.98.689-3 .99-1.121-1.265-2.783-1.335-4.38-.737S11.977 6.323 12 8v1c-3.245.083-6.135-1.395-8-4 0 0-4.182 7.433 4 11-1.872 1.247-3.739 2.088-6 2 3.308 1.803 6.913 2.423 10.034 1.517 3.58-1.04 6.522-3.723 7.651-7.742a13.84 13.84.0 00.497-3.753C20.18 7.773 21.692 5.25 22 4.009z"/></svg></a></li></ol><ol class=menu id=main-menu><li><a href=/><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-home" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><polyline points="5 12 3 12 12 3 21 12 19 12"/><path d="M5 12v7a2 2 0 002 2h10a2 2 0 002-2v-7"/><path d="M9 21v-6a2 2 0 012-2h2a2 2 0 012 2v6"/></svg>
<span>主页</span></a></li><li><a href=/articles/><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-heart" width="44" height="44" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"/><path d="M19.5 12.572 12 20l-7.5-7.428A5 5 0 1112 6.006a5 5 0 117.5 6.572"/></svg>
<span>我的</span></a></li><li><a href=/page/archives/><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-archive" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><rect x="3" y="4" width="18" height="4" rx="2"/><path d="M5 8v10a2 2 0 002 2h10a2 2 0 002-2V8"/><line x1="10" y1="12" x2="14" y2="12"/></svg>
<span>归档</span></a></li><li><a href=/page/photos/><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-camera" width="44" height="44" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"/><path d="M5 7h1a2 2 0 002-2 1 1 0 011-1h6a1 1 0 011 1 2 2 0 002 2h1a2 2 0 012 2v9a2 2 0 01-2 2H5a2 2 0 01-2-2V9a2 2 0 012-2"/><path d="M9 13a3 3 0 106 0 3 3 0 00-6 0"/></svg>
<span>相册</span></a></li><li><a href=/page/search/><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-search" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><circle cx="10" cy="10" r="7"/><line x1="21" y1="21" x2="15" y2="15"/></svg>
<span>搜索</span></a></li><li><a href=/timeline/><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-fish-christianity" width="44" height="44" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"/><path d="M22 7S16.354 17 9.692 17c-3.226.025-6.194-1.905-7.692-5 1.498-3.095 4.466-5.025 7.692-5C16.354 7 22 17 22 17"/></svg>
<span>年轴</span></a></li><li><a href=/page/links/><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-link" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><path d="M10 14a3.5 3.5.0 005 0l4-4a3.5 3.5.0 00-5-5l-.5.5"/><path d="M14 10a3.5 3.5.0 00-5 0l-4 4a3.5 3.5.0 005 5l.5-.5"/></svg>
<span>友链</span></a></li><li><a href=/about/><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-user" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><circle cx="12" cy="7" r="4"/><path d="M6 21v-2a4 4 0 014-4h4a4 4 0 014 4v2"/></svg>
<span>关于</span></a></li><li class=menu-bottom-section><ol class=menu><li id=dark-mode-toggle><svg class="icon icon-tabler icon-tabler-toggle-left" viewBox="0 0 1025 1024" xmlns="http://www.w3.org/2000/svg" p-id="14930" width="128" height="128"><path d="M253.939302 502.92736a269.74208 269.74208.0 00122.90048 235.84768 257.024 257.024.0 00259.95264 9.07264c81.46944-44.27776 135.70048-130.49856 139.0592-226.7136 5.14048-147.3536-107.37664-270.1312-250.63424-275.1488-145.32608-5.05856-266.1376 109.568-271.27808 256.94208zM531.730022.3072c16.384.57344 32.256 15.48288 31.62112 33.8944l-3.72736 106.43456c-.57344 16.384-15.4624 32.256-33.8944 31.60064-16.384-.57344-32.23552-15.4624-31.60064-33.8944l3.72736-106.43456c2.74432-20.3776 15.4624-32.23552 33.87392-31.60064zm493.89568 527.52384c-.57344 16.384-13.35296 30.26944-33.8944 31.60064l-104.36608-3.64544c-16.384-.57344-32.19456-17.53088-31.62112-33.8944.57344-16.384 15.48288-32.256 33.8944-31.60064l104.38656 3.64544a32.3584 32.3584.0 0131.60064 33.8944zm-855.53152-29.9008c-.57344 16.384-13.35296 30.28992-33.8944 31.62112l-104.38656-3.64544c-16.384-.57344-32.17408-17.5104-31.60064-33.8944.57344-16.384 15.4624-32.256 33.8944-31.60064l104.38656 3.64544a32.3584 32.3584.0 0131.60064 33.8944zm325.91872 525.76256c-16.384-.57344-32.256-15.48288-31.62112-33.8944l3.72736-106.43456c.57344-16.384 15.4624-32.256 33.8944-31.60064 16.384.57344 32.23552 15.4624 31.60064 33.8944l-3.72736 106.43456c-2.74432 20.3776-17.5104 32.1536-33.87392 31.60064zm401.32608-871.26016c11.85792 12.6976 11.0592 35.2256-1.6384 47.06304l-78.37696 73.09312c-12.6976 11.85792-33.1776 11.14112-47.08352-1.6384-11.83744-12.6976-11.0592-35.2256 1.6384-47.08352l78.39744-73.09312c16.85504-13.74208 35.2256-11.0592 47.06304 1.6384zm-15.50336 737.1776c-12.6976 11.85792-31.1296 11.22304-47.06304-1.6384l-70.9632-80.34304c-11.85792-12.6976-11.0592-35.2256 1.6384-47.08352s35.2256-11.0592 47.08352 1.6384l73.07264 78.37696c9.728 14.68416 8.94976 37.21216-3.76832 49.0496zm-596.31616-645.8368c-12.6976 11.85792-31.1296 11.20256-47.06304-1.6384l-73.09312-78.37696c-11.85792-12.6976-11.0592-35.2256 1.6384-47.08352s35.2256-11.0592 47.08352 1.6384l73.09312 78.37696c11.776 14.7456 11.0592 35.2256-1.6384 47.08352zm-138.24 614.05184c-11.85792-12.71808-11.0592-35.2256 1.6384-47.08352l78.37696-73.09312c12.6976-11.83744 33.1776-11.12064 47.08352 1.6384 11.83744 12.71808 11.0592 35.2256-1.6384 47.104l-78.39744 73.07264c-16.7936 11.71456-35.2256 11.0592-47.06304-1.6384z" fill="#ffb948"/></svg>
<svg class="icon icon-tabler icon-tabler-toggle-right" viewBox="0 0 1024 1024" xmlns="http://www.w3.org/2000/svg" width="128" height="128"><path d="M578.256332 591.814252v-82.970701m0 95.54202a12.655127 12.655127.0 01-12.571318-12.571319v-82.970701a12.571318 12.571318.0 1125.142636.0v82.970701a12.571318 12.571318.0 01-12.571318 12.571319z" fill="#f89b1b"/><path d="M598.873294 479.342858a36.959676 36.959676.0 01-27.573092-61.59946 52.380493 52.380493.0 1062.521357 36.540632 36.875867 36.875867.0 01-34.948265 25.058828zm204.0744-109.035234v-82.970701m0 95.542019a12.571318 12.571318.0 01-12.571318-12.571318v-82.970701a12.571318 12.571318.0 1125.142636.0v82.970701a12.571318 12.571318.0 01-12.571318 12.571318z" fill="#f89b1b"/><path d="M823.9837 257.83623a36.959676 36.959676.0 01-27.6569-61.515651 52.129067 52.129067.0 1064.616576 50.285273 53.050963 53.050963.0 00-2.011411-14.163685A36.875867 36.875867.0 01823.9837 257.83623z" fill="#f89b1b"/><path d="M803.282929 328.822274a59.588049 59.588049.0 0159.588049 59.588048V785.66398H743.694881V388.410322a59.588049 59.588049.0 0159.588048-59.588048zM581.776301 551.16699a143.145411 143.145411.0 01143.145411 143.145411V837.54162H438.463272V694.312401A143.145411 143.145411.0 01581.776301 551.16699z" fill="#612273"/><path d="M600.968514 198.667225l-49.111951-4.693292a8.380879 8.380879.0 01-7.039938-5.196145l-17.599845-42.658674a8.380879 8.380879.0 00-15.672244.0l-17.432228 42.658674a8.380879 8.380879.0 01-7.039938 5.196145l-49.11195 4.693292a8.380879 8.380879.0 00-4.777101 14.750347l36.959676 32.51781a8.380879 8.380879.0 012.681881 8.380878l-11.06276 45.67579a8.380879 8.380879.0 0012.487509 9.302776L515.232123 285.074086a8.380879 8.380879.0 018.380879.0l40.982497 24.136931a8.380879 8.380879.0 0012.571319-9.302776l-10.978952-45.675789a8.380879 8.380879.0 012.681882-8.380879L606.08085 213.417572a8.380879 8.380879.0 00-5.028528-14.750347z" fill="#fed150"/><path d="M470.897274 246.77347l1.927602-8.380879a8.380879 8.380879.0 00-2.681881-8.380879l-35.032074-30.506399a8.380879 8.380879.0 00-1.927602 13.912259l36.959676 32.51781a6.788512 6.788512.0 01.754279.838088zM603.98563 199.589122l-34.948265 30.674016a8.380879 8.380879.0 00-2.681881 8.380879l1.927602 8.380879a6.788512 6.788512.0 01.754279-.838088l37.043485-32.769236a8.380879 8.380879.0 00-2.09522-13.82845zm-28.578797 92.189667a8.380879 8.380879.0 01-10.643716 1.759985l-40.982498-24.053123a8.380879 8.380879.0 00-8.380879.0L474.249625 293.454965a8.380879 8.380879.0 01-10.643716-1.676176l-1.927602 8.380879a8.380879 8.380879.0 0012.487509 9.302775l41.066307-24.388357a8.380879 8.380879.0 018.380879.0l40.982497 24.136931a8.380879 8.380879.0 0012.571319-9.302776z" fill="#fed150" opacity=".5"/><path d="M434.608068 426.543321l-28.159753-2.681881a4.86091 4.86091.0 01-4.022822-3.017117l-10.057054-24.388357a4.86091 4.86091.0 00-8.967541.0l-9.973245 24.388357a4.693292 4.693292.0 01-4.022822 3.017117l-28.159753 2.681881a4.86091 4.86091.0 00-2.76569 8.380879l21.203623 18.605551a4.944719 4.944719.0 011.592367 4.777101L354.654484 484.455194a4.86091 4.86091.0 007.123747 5.363762l23.466461-13.82845a5.196145 5.196145.0 014.944718.0l23.466461 13.82845a4.86091 4.86091.0 007.123747-5.363762l-6.285659-26.064533a4.86091 4.86091.0 011.508558-4.777101l21.203624-18.605551a4.86091 4.86091.0 00-2.849499-8.380879z" fill="#fed150"/><path d="M360.102055 454.032604l1.173323-4.609484a4.944719 4.944719.0 00-1.592367-5.112336l-20.0303-17.683654a4.944719 4.944719.0 00-1.173323 8.380879l21.203623 18.605551zm76.182189-26.98643-20.0303 17.26461a4.86091 4.86091.0 00-1.508559 4.777101l1.173323 4.693292v-.502852l21.203624-18.605551a4.86091 4.86091.0 00-.838088-7.6266zM419.94153 479.845711a4.777101 4.777101.0 01-6.034233 1.005705l-23.46646-13.82845a5.196145 5.196145.0 00-4.944719.0l-23.466461 13.82845a4.777101 4.777101.0 01-6.034233-1.005705l-1.089514 4.609483a4.86091 4.86091.0 007.123747 5.363762l23.466461-13.82845a5.196145 5.196145.0 014.944719.0l23.46646 13.82845a4.86091 4.86091.0 007.123747-5.363762z" fill="#fed150" opacity=".5"/><path d="M635.413926 803.68287A414.685886 414.685886.0 01459.41547 18.729756 9.805628 9.805628.0 00453.967898.124205a513.831683 513.831683.0 10567.050264 607.027056 9.805628 9.805628.0 00-18.186507-6.704704A414.350651 414.350651.0 01635.413926 803.68287z" fill="#fed150" p-id="22313"/><path d="M50.931434 292.868303a460.110249 460.110249.0 00275.311871 359.455895 413.847798 413.847798.0 01133.339782-633.594442A9.805628 9.805628.0 00453.967898.124205 513.915492 513.915492.0 0050.931434 292.868303z" fill="#fed150" opacity=".4" p-id="22314"/><path d="M1006.016389 597.261823A513.664065 513.664065.0 013.914704 475.320036c-.670471 10.308481-1.257132 20.616962-1.257132 31.093061a513.831683 513.831683.0 001018.36059 100.570546 9.805628 9.805628.0 00-15.001773-9.72182zM231.539373 332.258434c0 7.458982.67047 14.917964 1.257132 22.293138A414.769695 414.769695.0 01459.583087 18.729756 9.805628 9.805628.0 00453.967898.124205a505.869848 505.869848.0 00-94.620122 20.868388A413.177328 413.177328.0 00231.539373 332.258434z" fill="#fed150" opacity=".5" p-id="22315"/><path d="M715.032275 421.514794m17.683654.0h141.217809q17.683654.0 17.683655 17.683654v-.083809q0 17.683654-17.683655 17.683655H732.715929q-17.683654.0-17.683654-17.683655v.083809q0-17.683654 17.683654-17.683654z" fill="#eb3d72" p-id="22316"/><path d="M205.139605 319.603307c4.441866-6.872321 22.041711-45.340555-11.817039-67.047031s-51.626214 8.380879-51.626214 8.380879a25.142637 25.142637.0 1042.742482 27.489282s2.179029 5.950424-6.537085 18.437934-25.142637 12.236083-43.077718.754279-47.01673-65.789899-.67047-138.787354c1.592367-2.514264 3.352352-4.693292 5.028527-7.039938a26.818812 26.818812.0 00-23.047417-2.430455 33.523515 33.523515.0 00-18.689359 17.683654c-31.260678 64.36515-22.628373 127.724594 21.203623 155.884347 48.944333 31.093061 82.048804-6.453277 86.49067-13.325597zM734.224488 931.491272c6.453277-2.681881 37.713955-21.45505 24.304548-53.386198s-40.647262-19.35983-40.647262-19.35983a21.874094 21.874094.0 1016.761757 40.312027s-1.340941 5.363762-13.577023 9.973246S697.264812 905.259122 689.889638 888.497364s-1.340941-69.561295 67.047031-98.894371c2.346646-1.005705 4.693292-1.676176 7.039938-2.514263a31.931148 31.931148.0 00-1.927602-3.352352 28.578797 28.578797.0 00-38.635851-7.542791c-51.87764 30.841634-74.422204 81.545951-57.325212 122.277023 19.778874 46.262451 61.59946 35.786353 68.136546 33.020662zM279.813236 802.844782c-5.950424-3.687587-39.390131-18.354125-57.660447 11.146569s7.794217 44.334849 7.794217 44.334849a21.874094 21.874094.0 1023.047417-36.875867s5.112336-2.011411 16.007479 5.279954 10.811334 21.622667 1.173323 37.211102-55.984271 41.317733-119.511333 2.430455c-2.179029-1.340941-4.106631-2.849499-6.118041-4.274249a22.376947 22.376947.0 00-1.676176 3.51997 28.662606 28.662606.0 0016.342714 36.037779c55.146183 24.388357 109.538087 13.409406 132.920739-24.136931 26.399768-42.9101-6.369468-70.902235-12.319892-74.673631zM431.00429 694.312401h302.298301m0 20.952197H431.00429a20.952197 20.952197.0 010-41.904394h302.298301a20.952197 20.952197.0 010 41.904394z" fill="#eb3d72" p-id="22317"/><path d="M255.760113 683.082023m-30.171164.0a30.171164 30.171164.0 1060.342328.0 30.171164 30.171164.0 10-60.342328.0z" fill="#fed150" opacity=".4" p-id="22318"/><path d="M356.246851 840.977781m-30.171164.0a30.171164 30.171164.0 1060.342328.0 30.171164 30.171164.0 10-60.342328.0z" fill="#fed150" opacity=".4" p-id="22319"/><path d="M54.870447 472.135302m-30.171164.0a30.171164 30.171164.0 1060.342328.0 30.171164 30.171164.0 10-60.342328.0z" fill="#fed150" opacity=".4" p-id="22320"/><path d="M561.410765 873.914635m-30.171164.0a30.171164 30.171164.0 1060.342328.0 30.171164 30.171164.0 10-60.342328.0z" fill="#fed150" opacity=".5" p-id="22321"/><path d="M445.167976 825.13792m-19.862683.0a19.862683 19.862683.0 1039.725365.0 19.862683 19.862683.0 10-39.725365.0z" fill="#fed150" opacity=".5" p-id="22322"/><path d="M149.406761 689.786726m-19.862683.0a19.862683 19.862683.0 1039.725365.0 19.862683 19.862683.0 10-39.725365.0z" fill="#fed150" opacity=".5" p-id="22323"/><path d="M132.225959 633.299603m-18.940786.0a18.940786 18.940786.0 1037.881572.0 18.940786 18.940786.0 10-37.881572.0z" fill="#fed150" opacity=".4" p-id="22324"/><path d="M475.339139 906.935297m-18.940786.0a18.940786 18.940786.0 1037.881573.0 18.940786 18.940786.0 10-37.881573.0z" fill="#fed150" opacity=".4" p-id="22325"/></svg>
<span>主题</span></li></ol></li></ol></aside><main class="main full-width"><nav aria-label=breadcrumb class=breadcrumb><ol><li><a href=/>首页</a></li><div><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-chevrons-right" width="44" height="44" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"/><path d="M7 7l5 5-5 5"/><path d="M13 7l5 5-5 5"/></svg></div><li><a href=/p/>未整理</a></li><div><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-chevrons-right" width="44" height="44" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"/><path d="M7 7l5 5-5 5"/><path d="M13 7l5 5-5 5"/></svg></div><li class=active><a aria-current=page href=/p/2023/05/17845g17/>13-垃圾回收器</a></li></ol></nav><article class=main-article><header class="article-header not-page"><section class="main-hero-waves-area waves-area"><svg class="waves-svg" xmlns="http://www.w3.org/2000/svg" viewBox="0 24 150 28" preserveAspectRatio="none" shape-rendering="auto"><defs><path id="gentle-wave" d="M-160 44c30 0 58-18 88-18s58 18 88 18 58-18 88-18 58 18 88 18v44h-352z"/></defs><g class="parallax"><use href="#gentle-wave" x="48" y="0"/><use href="#gentle-wave" x="48" y="3"/><use href="#gentle-wave" x="48" y="5"/><use href="#gentle-wave" x="48" y="7"/></g></svg></section><div class=article-details><header class=article-category><a href=/categories/jvm/ style=background-color:#c21292;color:#fff>JVM</a></header><div class=article-title-wrapper><h2 class=article-title><a href=/p/2023/05/17845g17/>13-垃圾回收器</a></h2><h3 class=article-subtitle>JVM底层原理</h3></div><footer class=article-time><div><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-calendar-time" width="56" height="56" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><path d="M11.795 21H5a2 2 0 01-2-2V7a2 2 0 012-2h12a2 2 0 012 2v4"/><circle cx="18" cy="18" r="4"/><path d="M15 3v4"/><path d="M7 3v4"/><path d="M3 11h16"/><path d="M18 16.496V18l1 1"/></svg>
<time class=article-time--published>2023年5月3日</time></div><div><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-clock" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><circle cx="12" cy="12" r="9"/><polyline points="12 7 12 12 15 15"/></svg>
<time class=article-time--reading>阅读时长: 50 分钟</time></div></footer></div></header><section class=article-content><h1 id=13-垃圾回收器><a href=#13-%e5%9e%83%e5%9c%be%e5%9b%9e%e6%94%b6%e5%99%a8 class=header-anchor>#</a>
13. 垃圾回收器</h1><h2 id=131-gc-分类与性能指标><a href=#131-gc-%e5%88%86%e7%b1%bb%e4%b8%8e%e6%80%a7%e8%83%bd%e6%8c%87%e6%a0%87 class=header-anchor>#</a>
13.1. GC 分类与性能指标</h2><h3 id=1311-垃圾回收器概述><a href=#1311-%e5%9e%83%e5%9c%be%e5%9b%9e%e6%94%b6%e5%99%a8%e6%a6%82%e8%bf%b0 class=header-anchor>#</a>
13.1.1. 垃圾回收器概述</h3><p>垃圾收集器没有在规范中进行过多的规定，可以由不同的厂商、不同版本的 JVM 来实现。</p><p>由于 JDK 的版本处于高速迭代过程中，因此 Java 发展至今已经衍生了众多的 GC 版本。</p><p>从不同角度分析垃圾收集器，可以将 GC 分为不同的类型。</p><h3 id=1312-垃圾收集器分类><a href=#1312-%e5%9e%83%e5%9c%be%e6%94%b6%e9%9b%86%e5%99%a8%e5%88%86%e7%b1%bb class=header-anchor>#</a>
13.1.2. 垃圾收集器分类</h3><p>按<mark>线程数</mark>分，可以分为<mark>串行垃圾回收器</mark>和<mark>并行垃圾回收器</mark>。</p><p><img src=https://logan.1357810.xyz/img/20220422/153020741-b2b8ae1f18.png width=900 height=600 loading=lazy decoding=async alt=image-20210512144253383 class="gallery-image link-image" data-flex-grow=20 data-flex-basis=20px></p><p>串行回收指的是在同一时间段内只允许有一个 CPU 用于执行垃圾回收操作，此时工作线程被暂停，直至垃圾收集工作结束。</p><ul><li>在诸如单 CPU 处理器或者较小的应用内存等硬件平台不是特别优越的场合，串行回收器的性能表现可以超过并行回收器和并发回收器。所以，<mark>串行回收默认被应用在客户端的 Client 模式下的 JVM 中</mark></li><li>在并发能力比较强的 CPU 上，并行回收器产生的停顿时间要短于串行回收器。</li></ul><p>和串行回收相反，并行收集可以运用多个 CPU 同时执行垃圾回收，因此提升了应用的吞吐量，不过并行回收仍然与串行回收一样，采用独占式，使用了“Stop-the-World”机制。</p><p>按照<mark>工作模式</mark>分，可以分为<mark>并发式垃圾回收器</mark>和<mark>独占式垃圾回收器</mark>。</p><ul><li>并发式垃圾回收器与应用程序线程交替工作，以尽可能减少应用程序的停顿时间。</li><li>独占式垃圾回收器（Stop the world）一旦运行，就停止应用程序中的所有用户线程，直到垃圾回收过程完全结束。</li></ul><p><img src=https://logan.1357810.xyz/img/20220422/153020741-7da8ab5ade.png width=900 height=600 loading=lazy decoding=async alt=image-20200713083443486 class="gallery-image link-image" data-flex-grow=20 data-flex-basis=20px></p><p>按<mark>碎片处理方式</mark>分，可分为<mark>压缩式垃圾回收器</mark>和<mark>非压缩式垃圾回收器</mark>。</p><ul><li>压缩式垃圾回收器会在回收完成后，对存活对象进行压缩整理，消除回收后的碎片。</li><li>非压缩式的垃圾回收器不进行这步操作。</li></ul><p>按<mark>工作的内存区间</mark>分，又可分为<mark>年轻代垃圾回收器</mark>和<mark>老年代垃圾回收器</mark>。</p><h3 id=1313-评估-gc-的性能指标><a href=#1313-%e8%af%84%e4%bc%b0-gc-%e7%9a%84%e6%80%a7%e8%83%bd%e6%8c%87%e6%a0%87 class=header-anchor>#</a>
13.1.3. 评估 GC 的性能指标</h3><ul><li><mark>吞吐量</mark>：运行用户代码的时间占总运行时间的比例（总运行时间 = 程序的运行时间 + 内存回收的时间）</li><li><mark>垃圾收集开销</mark>：吞吐量的补数，垃圾收集所用时间与总运行时间的比例。</li><li><mark>暂停时间</mark>：执行垃圾收集时，程序的工作线程被暂停的时间。</li><li><mark>收集频率</mark>：相对于应用程序的执行，收集操作发生的频率。</li><li><mark>内存占用</mark>：Java 堆区所占的内存大小。</li><li><mark>快速</mark>：一个对象从诞生到被回收所经历的时间。</li></ul><p>吞吐量、暂停时间、内存占用 这三者共同构成一个“不可能三角”。三者总体的表现会随着技术进步而越来越好。一款优秀的收集器通常最多同时满足其中的两项。</p><p>这三项里，暂停时间的重要性日益凸显。因为随着硬件发展，内存占用多些越来越能容忍，硬件性能的提升也有助于降低收集器运行时对应用程序的影响，即提高了吞吐量。而内存的扩大，对延迟反而带来负面效果。</p><p>简单来说，主要抓住两点：吞吐量、暂停时间</p><h4 id=吞吐量><a href=#%e5%90%9e%e5%90%90%e9%87%8f class=header-anchor>#</a>
吞吐量</h4><p>吞吐量就是 CPU 用于运行用户代码的时间与 CPU 总消耗时间的比值，即吞吐量 = 运行用户代码时间 /（运行用户代码时间+垃圾收集时间）。比如：虚拟机总共运行了 100 分钟，其中垃圾收集花掉 1 分钟，那吞吐量就是 99%。</p><p>这种情况下，应用程序能容忍较高的暂停时间，因此，高吞吐量的应用程序有更长的时间基准，快速响应是不必考虑的</p><p>吞吐量优先，意味着在单位时间内，STW 的时间最短：0.2 + 0.2 = 0.4</p><p><img src=https://logan.1357810.xyz/img/20220422/153020741-2452b90524.png width=900 height=600 loading=lazy decoding=async alt=image-20200713084726176 class="gallery-image link-image" data-flex-grow=20 data-flex-basis=20px></p><h4 id=暂停时间><a href=#%e6%9a%82%e5%81%9c%e6%97%b6%e9%97%b4 class=header-anchor>#</a>
暂停时间</h4><p>“暂停时间”是指一个时间段内应用程序线程暂停，让 GC 线程执行的状态。</p><p>例如，GC 期间 100 毫秒的暂停时间意味着在这 100 毫秒期间内没有应用程序线程是活动的。</p><p>暂停时间优先，意味着尽可能让单次 STW 的时间最短：0.1 + 0.1 + 0.1 + 0.1 + 0.1 = 0.5</p><p><img src=https://logan.1357810.xyz/img/20220422/153020741-3f1d43e786.png width=900 height=600 loading=lazy decoding=async alt=image-20200713085306400 class="gallery-image link-image" data-flex-grow=20 data-flex-basis=20px></p><h4 id=吞吐量-vs-暂停时间><a href=#%e5%90%9e%e5%90%90%e9%87%8f-vs-%e6%9a%82%e5%81%9c%e6%97%b6%e9%97%b4 class=header-anchor>#</a>
吞吐量 vs 暂停时间</h4><p>高吞吐量较好因为这会让应用程序的最终用户感觉只有应用程序线程在做“生产性”工作。直觉上，吞吐量越高程序运行越快。</p><p>低暂停时间（低延迟）较好因为从最终用户的角度来看不管是 GC 还是其他原因导致一个应用被挂起始终是不好的。这取决于应用程序的类型，<mark>有时候甚至短暂的 200 毫秒暂停都可能打断终端用户体验</mark>。因此，具有低的较大暂停时间是非常重要的，特别是对于一个<mark>交互式应用程序</mark>。</p><p>不幸的是”高吞吐量”和”低暂停时间”是一对相互竞争的目标（矛盾）。</p><ul><li>因为如果选择以吞吐量优先，那么<mark>必然需要降低内存回收的执行频率</mark>，但是这样会导致 GC 需要更长的暂停时间来执行内存回收。</li><li>相反的，如果选择以低延迟优先为原则，那么为了降低每次执行内存回收时的暂停时间，也<mark>只能频繁地执行内存回收</mark>，但这又引起了年轻代内存的缩减和导致程序吞吐量的下降。</li></ul><p>在设计（或使用）GC 算法时，我们必须确定我们的目标：一个 GC 算法只可能针对两个目标之一（即只专注于较大吞吐量或最小暂停时间），或尝试找到一个二者的折衷。</p><p>现在标准：<mark>在最大吞吐量优先的情况下，降低停顿时间</mark></p><h2 id=132-不同的垃圾回收器概述><a href=#132-%e4%b8%8d%e5%90%8c%e7%9a%84%e5%9e%83%e5%9c%be%e5%9b%9e%e6%94%b6%e5%99%a8%e6%a6%82%e8%bf%b0 class=header-anchor>#</a>
13.2. 不同的垃圾回收器概述</h2><p>垃圾收集机制是 Java 的招牌能力，极大地提高了开发效率。这当然也是面试的热点。</p><h3 id=1321-垃圾回收器发展史><a href=#1321-%e5%9e%83%e5%9c%be%e5%9b%9e%e6%94%b6%e5%99%a8%e5%8f%91%e5%b1%95%e5%8f%b2 class=header-anchor>#</a>
13.2.1. 垃圾回收器发展史</h3><p>有了虚拟机，就一定需要收集垃圾的机制，这就是 Garbage Collection，对应的产品我们称为 Garbage Collector。</p><ul><li>1999 年随 JDK1.3.1 一起来的是串行方式的 serialGc，它是第一款 GC。ParNew 垃圾收集器是 Serial 收集器的多线程版本</li><li>2002 年 2 月 26 日，Parallel GC 和 Concurrent Mark Sweep GC 跟随 JDK1.4.2 一起发布·</li><li>Parallel GC 在 JDK6 之后成为 HotSpot 默认 GC。</li><li>2012 年，在 JDK1.7u4 版本中，G1 可用。</li><li>2017 年，JDK9 中 G1 变成默认的垃圾收集器，以替代 CMS。</li><li>2018 年 3 月，JDK10 中 G1 垃圾回收器的并行完整垃圾回收，实现并行性来改善最坏情况下的延迟。</li><li>2018 年 9 月，JDK11 发布。引入 Epsilon 垃圾回收器，又被称为 &ldquo;No-Op(无操作)“ 回收器。同时，引入 ZGC：可伸缩的低延迟垃圾回收器（Experimental）</li><li>2019 年 3 月，JDK12 发布。增强 G1，自动返回未用堆内存给操作系统。同时，引入 Shenandoah GC：低停顿时间的 GC（Experimental）。·</li><li>2019 年 9 月，JDK13 发布。增强 ZGC，自动返回未用堆内存给操作系统。</li><li>2020 年 3 月，JDK14 发布。删除 CMS 垃圾回收器。扩展 ZGC 在 macos 和 Windows 上的应用</li></ul><h3 id=1322-7-种经典的垃圾收集器><a href=#1322-7-%e7%a7%8d%e7%bb%8f%e5%85%b8%e7%9a%84%e5%9e%83%e5%9c%be%e6%94%b6%e9%9b%86%e5%99%a8 class=header-anchor>#</a>
13.2.2. 7 种经典的垃圾收集器</h3><ul><li>串行回收器：Serial、Serial Old</li><li>并行回收器：ParNew、Parallel Scavenge、Parallel old</li><li>并发回收器：CMS、G1</li></ul><p><img src=https://logan.1357810.xyz/img/20220422/153020741-713d8b7f95.png width=900 height=600 loading=lazy decoding=async alt=image-20200713093551365 class="gallery-image link-image" data-flex-grow=20 data-flex-basis=20px></p><p>官方手册：<a class=link href=https://www.oracle.com/technetwork/java/javase/tech/memorymanagement-whitepaper-1-150020.pdf target=_blank rel=noopener>https://www.oracle.com/technetwork/java/javase/tech/memorymanagement-whitepaper-1-150020.pdf
<span style=white-space:nowrap><svg width=".7em" height=".7em" viewBox="0 0 21 21" xmlns="http://www.w3.org/2000/svg"><path d="m13 3 3.293 3.293-7 7 1.414 1.414 7-7L21 11V3z" fill="currentcolor"/><path d="M19 19H5V5h7l-2-2H5c-1.103.0-2 .897-2 2v14c0 1.103.897 2 2 2h14c1.103.0 2-.897 2-2v-5l-2-2v7z" fill="currentcolor"/></span></a></p><p><img src=https://logan.1357810.xyz/img/20220422/153020741-9eddf061c1.png width=900 height=600 loading=lazy decoding=async alt=image-20210512145950897 class="gallery-image link-image" data-flex-grow=20 data-flex-basis=20px></p><h3 id=1323-7-款经典收集器与垃圾分代之间的关系><a href=#1323-7-%e6%ac%be%e7%bb%8f%e5%85%b8%e6%94%b6%e9%9b%86%e5%99%a8%e4%b8%8e%e5%9e%83%e5%9c%be%e5%88%86%e4%bb%a3%e4%b9%8b%e9%97%b4%e7%9a%84%e5%85%b3%e7%b3%bb class=header-anchor>#</a>
13.2.3. 7 款经典收集器与垃圾分代之间的关系</h3><p><img src=https://logan.1357810.xyz/img/20220422/153020741-21122e2f67.png width=900 height=600 loading=lazy decoding=async alt=image-20200713093757644 class="gallery-image link-image" data-flex-grow=20 data-flex-basis=20px></p><ul><li><p>新生代收集器：Serial、ParNew、Parallel Scavenge；</p></li><li><p>老年代收集器：Serial Old、Parallel Old、CMS；</p></li><li><p>整堆收集器：G1；</p></li></ul><h3 id=1324-垃圾收集器的组合关系><a href=#1324-%e5%9e%83%e5%9c%be%e6%94%b6%e9%9b%86%e5%99%a8%e7%9a%84%e7%bb%84%e5%90%88%e5%85%b3%e7%b3%bb class=header-anchor>#</a>
13.2.4. 垃圾收集器的组合关系</h3><p><img src=https://logan.1357810.xyz/img/20220422/153020741-4fcb28e52d.png width=900 height=600 loading=lazy decoding=async alt=image-20200713094745366 class="gallery-image link-image" data-flex-grow=20 data-flex-basis=20px></p><ol><li>两个收集器间有连线，表明它们可以搭配使用：Serial/Serial Old、Serial/CMS、ParNew/Serial Old、ParNew/CMS、Parallel Scavenge/Serial Old、Parallel Scavenge/Parallel Old、G1；</li><li>其中 Serial Old 作为 CMS 出现&rdquo;<code>Concurrent Mode Failure</code>&ldquo;失败的后备预案。</li><li>（红色虚线）由于维护和兼容性测试的成本，在 JDK 8 时将 Serial+CMS、ParNew+Serial Old 这两个组合声明为废弃（JEP173），并在 JDK9 中完全取消了这些组合的支持（JEP214），即：移除。</li><li>（绿色虚线）JDK14 中：弃用 Parallel Scavenge 和 Serialold GC 组合（JEP366）</li><li>（绿色虚框）JDK14 中：删除 CMS 垃圾回收器（JEP363）</li></ol><h3 id=1325-不同的垃圾收集器概述><a href=#1325-%e4%b8%8d%e5%90%8c%e7%9a%84%e5%9e%83%e5%9c%be%e6%94%b6%e9%9b%86%e5%99%a8%e6%a6%82%e8%bf%b0 class=header-anchor>#</a>
13.2.5. 不同的垃圾收集器概述</h3><p>为什么要有很多收集器，一个不够吗？因为 Java 的使用场景很多，移动端，服务器等。所以就需要针对不同的场景，提供不同的垃圾收集器，提高垃圾收集的性能。</p><p>虽然我们会对各个收集器进行比较，但并非为了挑选一个最好的收集器出来。没有一种放之四海皆准、任何场景下都适用的完美收集器存在，更加没有万能的收集器。所以<mark>我们选择的只是对具体应用最合适的收集器</mark>。</p><h3 id=1326-如何查看默认垃圾收集器><a href=#1326-%e5%a6%82%e4%bd%95%e6%9f%a5%e7%9c%8b%e9%bb%98%e8%ae%a4%e5%9e%83%e5%9c%be%e6%94%b6%e9%9b%86%e5%99%a8 class=header-anchor>#</a>
13.2.6. 如何查看默认垃圾收集器</h3><p><code>-XX:+PrintCommandLineFlags</code>：查看命令行相关参数（包含使用的垃圾收集器）</p><p>使用命令行指令：<code>jinfo -flag 相关垃圾回收器参数 进程ID</code></p><h2 id=133-serial-回收器串行回收><a href=#133-serial-%e5%9b%9e%e6%94%b6%e5%99%a8%e4%b8%b2%e8%a1%8c%e5%9b%9e%e6%94%b6 class=header-anchor>#</a>
13.3. Serial 回收器：串行回收</h2><p>Serial 收集器是最基本、历史最悠久的垃圾收集器了。JDK1.3 之前回收新生代唯一的选择。</p><p>Serial 收集器作为 HotSpot 中 client 模式下的默认新生代垃圾收集器。</p><p><mark>Serial 收集器采用复制算法、串行回收和"stop-the-World"机制的方式执行内存回收。</mark></p><p>除了年轻代之外，Serial 收集器还提供用于执行老年代垃圾收集的 Serial Old 收集器。<mark>Serial Old 收集器同样也采用了串行回收和"Stop the World"机制，只不过内存回收算法使用的是标记-压缩算法。</mark></p><ul><li>Serial old 是运行在 Client 模式下默认的老年代的垃圾回收器</li><li>Serial 0ld 在 Server 模式下主要有两个用途：① 与新生代的 Parallel scavenge 配合使用 ② 作为老年代 CMS 收集器的后备垃圾收集方案</li></ul><p><img src=https://logan.1357810.xyz/img/20220422/153020741-b01bfd4b4b.png width=900 height=600 loading=lazy decoding=async alt=image-20200713100703799 class="gallery-image link-image" data-flex-grow=20 data-flex-basis=20px></p><p>这个收集器是一个单线程的收集器，但它的“单线程”的意义并不仅仅说明它只会<mark>使用一个 CPU 或一条收集线程去完成垃圾收集工作</mark>，更重要的是在它进行垃圾收集时，<mark>必须暂停其他所有的工作线程</mark>，直到它收集结束（Stop The World）</p><p>优势：<mark>简单而高效</mark>（与其他收集器的单线程比），对于限定单个 CPU 的环境来说，Serial 收集器由于没有线程交互的开销，专心做垃圾收集自然可以获得最高的单线程收集效率。运行在 Client 模式下的虚拟机是个不错的选择。</p><p>在用户的桌面应用场景中，可用内存一般不大（几十 MB 至一两百 MB），可以在较短时间内完成垃圾收集（几十 ms 至一百多 ms），只要不频繁发生，使用串行回收器是可以接受的。</p><p>在 HotSpot 虚拟机中，使用<code>-XX:+UseSerialGC</code>参数可以指定年轻代和老年代都使用串行收集器。等价于新生代用 Serial GC，且老年代用 Serial Old GC</p><p><strong>总结</strong></p><p>这种垃圾收集器大家了解，现在已经不用串行的了。而且在限定单核 cpu 才可以用。现在都不是单核的了。</p><p>对于交互较强的应用而言，这种垃圾收集器是不能接受的。一般在 Java web 应用程序中是不会采用串行垃圾收集器的。</p><h2 id=134-parnew-回收器并行回收><a href=#134-parnew-%e5%9b%9e%e6%94%b6%e5%99%a8%e5%b9%b6%e8%a1%8c%e5%9b%9e%e6%94%b6 class=header-anchor>#</a>
13.4. ParNew 回收器：并行回收</h2><p>如果说 Serial GC 是年轻代中的单线程垃圾收集器，那么 ParNew 收集器则是 Serial 收集器的多线程版本。Par 是 Parallel 的缩写，New：只能处理的是新生代</p><p>ParNew 收集器除了采用<mark>并行回收</mark>的方式执行内存回收外，两款垃圾收集器之间几乎没有任何区别。ParNew 收集器在年轻代中同样也是采用<mark>复制算法、&ldquo;Stop-the-World"机制</mark>。</p><p>ParNew 是很多 JVM 运行在 Server 模式下新生代的默认垃圾收集器。</p><p><img src=https://logan.1357810.xyz/img/20220422/153020741-cd953aeb4e.png width=900 height=600 loading=lazy decoding=async alt=image-20200713102030127 class="gallery-image link-image" data-flex-grow=20 data-flex-basis=20px></p><ul><li>对于新生代，回收次数频繁，使用并行方式高效。</li><li>对于老年代，回收次数少，使用串行方式节省资源。（CPU 并行需要切换线程，串行可以省去切换线程的资源）</li></ul><p>由于 ParNew 收集器是基于并行回收，那么是否可以断定 ParNew 收集器的回收效率在任何场景下都会比 serial 收集器更高效？</p><ul><li>ParNew 收集器运行在多 CPU 的环境下，由于可以充分利用多 CPU、多核心等物理硬件资源优势，可以更快速地完成垃圾收集，提升程序的吞吐量。</li><li>但是<mark>在单个 CPU 的环境下，ParNew 收集器不比 Serial 收集器更高效</mark>。虽然 Serial 收集器是基于串行回收，但是由于 CPU 不需要频繁地做任务切换，因此可以有效避免多线程交互过程中产生的一些额外开销。</li></ul><p>因为除 Serial 外，目前只有 ParNew GC 能与 CMS 收集器配合工作</p><p>在程序中，开发人员可以通过选项&rdquo;<code>-XX:+UseParNewGC</code>&ldquo;手动指定使用 ParNew 收集器执行内存回收任务。它表示年轻代使用并行收集器，不影响老年代。</p><p><code>-XX:ParallelGCThreads</code>限制线程数量，默认开启和 CPU 核心数相同的线程数。</p><h2 id=135-parallel-回收器吞吐量优先><a href=#135-parallel-%e5%9b%9e%e6%94%b6%e5%99%a8%e5%90%9e%e5%90%90%e9%87%8f%e4%bc%98%e5%85%88 class=header-anchor>#</a>
13.5. Parallel 回收器：吞吐量优先</h2><p>HotSpot 的年轻代中除了拥有 ParNew 收集器是基于并行回收的以外，Parallel Scavenge 收集器同样也采用了<mark>复制算法、并行回收和"Stop the World"机制</mark>。</p><p>那么 Parallel 收集器的出现是否多此一举？</p><ul><li>和 ParNew 收集器不同，ParallelScavenge 收集器的目标则是达到一个<mark>可控制的吞吐量</mark>（Throughput），它也被称为吞吐量优先的垃圾收集器。</li><li>自适应调节策略也是 Parallel Scavenge 与 ParNew 一个重要区别。</li></ul><p>高吞吐量则可以高效率地利用 CPU 时间，尽快完成程序的运算任务，主要<mark>适合在后台运算而不需要太多交互的任务</mark>。因此，常见在服务器环境中使用。<mark>例如，那些执行批量处理、订单处理、工资支付、科学计算的应用程序</mark>。</p><p>Parallel 收集器在 JDK1.6 时提供了用于执行老年代垃圾收集的 Parallel Old 收集器，用来代替老年代的 Serial Old 收集器。</p><p>Parallel Old 收集器采用了<mark>标记-压缩算法</mark>，但同样也是基于<mark>并行回收和"Stop-the-World"机制</mark>。</p><p><img src=https://logan.1357810.xyz/img/20220422/153020741-6f0874edf6.png width=900 height=600 loading=lazy decoding=async alt=image-20200713110359441 class="gallery-image link-image" data-flex-grow=20 data-flex-basis=20px></p><p>在程序吞吐量优先的应用场景中，Parallel 收集器和 Parallel Old 收集器的组合，在 Server 模式下的内存回收性能很不错。在 Java8 中，默认是此垃圾收集器。</p><p><strong>参数配置</strong></p><ul><li><p><code>-XX:+UseParallelGC</code> 手动指定年轻代使用 Parallel 并行收集器执行内存回收任务。</p></li><li><p><code>-XX:+UseParallelOldGC</code> 手动指定老年代都是使用并行回收收集器。</p><ul><li>分别适用于新生代和老年代。默认 jdk8 是开启的。</li><li>上面两个参数，默认开启一个，另一个也会被开启。（互相激活）</li></ul></li><li><p><code>-XX:ParallelGCThreads</code> 设置年轻代并行收集器的线程数。一般地，最好与 CPU 数量相等，以避免过多的线程数影响垃圾收集性能。</p><p>$$ ParallelGCThreads = \begin{cases} CPU_Count & \text (CPU_Count &lt;= 8) \ 3 + (5 * CPU＿Count / 8) & \text (CPU_Count > 8) \end{cases} $$</p></li><li><p><code>-XX:MaxGCPauseMillis</code> 设置垃圾收集器最大停顿时间（即 STw 的时间）。单位是毫秒。</p><ul><li>为了尽可能地把停顿时间控制在 MaxGCPauseMills 以内，收集器在工作时会调整 Java 堆大小或者其他一些参数。</li><li>对于用户来讲，停顿时间越短体验越好。但是在服务器端，我们注重高并发，整体的吞吐量。所以服务器端适合 Parallel，进行控制。</li><li><mark>该参数使用需谨慎</mark>。</li></ul></li><li><p><code>-XX:GCTimeRatio</code> 垃圾收集时间占总时间的比例（=1/（N+1））。用于衡量吞吐量的大小。</p><ul><li>取值范围（0, 100）。默认值 99，也就是垃圾回收时间不超过 1%。</li><li>与前一个<code>-XX:MaxGCPauseMillis </code>参数有一定矛盾性。暂停时间越长，Radio 参数就容易超过设定的比例。</li></ul></li><li><p><code>-XX:+UseAdaptivesizePolicy</code> 设置 Parallel Scavenge 收集器具有<mark>自适应调节策略</mark></p><ul><li>在这种模式下，年轻代的大小、Eden 和 Survivor 的比例、晋升老年代的对象年龄等参数会被自动调整，已达到在堆大小、吞吐量和停顿时间之间的平衡点。</li><li>在手动调优比较困难的场合，可以直接使用这种自适应的方式，仅指定虚拟机的最大堆、目标的吞吐量（<code>GCTimeRatio</code>）和停顿时间（<code>MaxGCPauseMills</code>），让虚拟机自己完成调优工作。</li></ul></li></ul><h2 id=136-cms-回收器低延迟><a href=#136-cms-%e5%9b%9e%e6%94%b6%e5%99%a8%e4%bd%8e%e5%bb%b6%e8%bf%9f class=header-anchor>#</a>
13.6. CMS 回收器：低延迟</h2><p>在 JDK1.5 时期，Hotspot 推出了一款在<mark>强交互应用</mark>中几乎可认为有划时代意义的垃圾收集器：CMS（Concurrent-Mark-Sweep）收集器，<mark>这款收集器是 HotSpot 虚拟机中第一款真正意义上的并发收集器，它第一次实现了让垃圾收集线程与用户线程同时工作</mark>。</p><p>CMS 收集器的关注点是尽可能缩短垃圾收集时用户线程的停顿时间。停顿时间越短（低延迟）就越适合与用户交互的程序，良好的响应速度能提升用户体验。</p><ul><li><mark>目前很大一部分的 Java 应用集中在互联网站或者 B/S 系统的服务端上，这类应用尤其重视服务的响应速度，希望系统停顿时间最短</mark>，以给用户带来较好的体验。CMS 收集器就非常符合这类应用的需求。</li></ul><p>CMS 的垃圾收集算法采用<mark>标记-清除算法</mark>，并且也会"Stop-the-World&rdquo;</p><p>不幸的是，CMS 作为老年代的收集器，却无法与 JDK1.4.0 中已经存在的新生代收集器 Parallel Scavenge 配合工作，所以在 JDK1.5 中使用 CMS 来收集老年代的时候，新生代只能选择 ParNew 或者 Serial 收集器中的一个。</p><p>在 G1 出现之前，CMS 使用还是非常广泛的。一直到今天，仍然有很多系统使用 CMS GC。</p><p><img src=https://logan.1357810.xyz/img/20220422/153020741-66f93a72ad.png width=900 height=600 loading=lazy decoding=async alt=image-20200713205154007 class="gallery-image link-image" data-flex-grow=20 data-flex-basis=20px></p><p>CMS 整个过程比之前的收集器要复杂，整个过程分为 4 个主要阶段，即初始标记阶段、并发标记阶段、重新标记阶段和并发清除阶段</p><ul><li><strong>初始标记</strong>（Initial-Mark）阶段：在这个阶段中，程序中所有的工作线程都将会因为“Stop-the-World”机制而出现短暂的暂停，这个阶段的主要任务<mark>仅仅只是标记出 GCRoots 能直接关联到的对象</mark>。一旦标记完成之后就会恢复之前被暂停的所有应用线程。由于直接关联对象比较小，所以这里的<mark>速度非常快</mark>。</li><li><strong>并发标记</strong>（Concurrent-Mark）阶段：从 GC Roots 的<mark>直接关联对象开始遍历整个对象图的过程</mark>，这个过程耗时较长但是<mark>不需要停顿用户线程</mark>，可以与垃圾收集线程一起并发运行。但是可能会导致已经标记过的对象状态发生改变。</li><li><strong>重新标记</strong>（Remark）阶段：由于在并发标记阶段中，程序的工作线程会和垃圾收集线程同时运行或者交叉运行，因此为了<mark>修正并发标记期间，因用户程序继续运作而导致标记产生变动的那一部分对象的标记记录</mark>，这个阶段的停顿时间通常会比初始标记阶段稍长一些，但也远比并发标记阶段的时间短。</li><li><strong>并发清除</strong>（Concurrent-Sweep）阶段：GC线程开始对未标记的区域做清扫，释放内存空间，这个阶段如果有新增对象会被标记为黑色，不做任何处理。由于不需要移动存活对象，所以这个阶段也是可以与用户线程同时并发的</li><li>并发重置：重置本次GC过程中的标记数据</li></ul><p>尽管 CMS 收集器采用的是并发回收（非独占式），但是<mark>在其初始化标记和再次标记这两个阶段中仍然需要执行“Stop-the-World”机制</mark>暂停程序中的工作线程，不过暂停时间并不会太长，因此可以说明目前所有的垃圾收集器都做不到完全不需要“stop-the-World”，只是尽可能地缩短暂停时间。</p><p><mark>由于最耗费时间的并发标记与并发清除阶段都不需要暂停工作，所以整体的回收是低停顿的。</mark></p><p>另外，由于在垃圾收集阶段用户线程没有中断，<mark>所以在 CMS 回收过程中，还应该确保应用程序用户线程有足够的内存可用</mark>。因此，CMS 收集器不能像其他收集器那样等到老年代几乎完全被填满了再进行收集，而是<mark>当堆内存使用率达到某一阈值时，便开始进行回收</mark>，以确保应用程序在 CMS 工作过程中依然有足够的空间支持应用程序运行。要是 CMS 运行期间预留的内存无法满足程序需要，就会出现一次“<code>Concurrent Mode Failure</code>” 失败，这时虚拟机将启动后备预案：临时启用 Serial Old 收集器来重新进行老年代的垃圾收集，这样停顿时间就很长了。</p><p>CMS 收集器的垃圾收集算法采用的是标记清除算法，这意味着每次执行完内存回收后，由于被执行内存回收的无用对象所占用的内存空间极有可能是不连续的一些内存块，不可避免地将会<mark>产生一些内存碎片</mark>。那么 CMS 在为新对象分配内存空间时，将无法使用指针碰撞（Bump the Pointer）技术，而只能够选择空闲列表（Free List）执行内存分配。</p><p><img src=https://logan.1357810.xyz/img/20220422/153020741-aaa8760dfc.png width=900 height=600 loading=lazy decoding=async alt=image-20200713212230352 class="gallery-image link-image" data-flex-grow=20 data-flex-basis=20px></p><p><strong>有人会觉得既然 Mark Sweep 会造成内存碎片，那么为什么不把算法换成 Mark Compact？</strong></p><p>答案其实很简单，因为当并发清除的时候，用 Compact 整理内存的话，原来的用户线程使用的内存还怎么用呢？要保证用户线程能继续执行，前提的它运行的资源不受影响嘛。Mark Compact 更适合“Stop the World” 这种场景下使用</p><ul><li>通过参数 -XX:+UseCMSCompactAtFullCollection ，可以让jvm在执行标记清除后再做内存整理</li></ul><h3 id=1361-cms-的优点><a href=#1361-cms-%e7%9a%84%e4%bc%98%e7%82%b9 class=header-anchor>#</a>
13.6.1. CMS 的优点</h3><ul><li>并发收集</li><li>低延迟</li></ul><h3 id=1362-cms-的弊端><a href=#1362-cms-%e7%9a%84%e5%bc%8a%e7%ab%af class=header-anchor>#</a>
13.6.2. CMS 的弊端</h3><ul><li><mark>会产生内存碎片</mark>，导致并发清除后，用户线程可用的空间不足。在无法分配大对象的情况下，不得不提前触发 FullGC。</li><li><mark>CMS 收集器对 CPU 资源非常敏感</mark>。在并发阶段，它虽然不会导致用户停顿，但是会因为占用了一部分线程而导致应用程序变慢，总吞吐量会降低。</li><li><mark>CMS 收集器无法处理浮动垃圾</mark>。可能出现“<code>Concurrent Mode Failure</code>&ldquo;失败而导致另一次 Full GC 的产生。在并发标记阶段由于程序的工作线程和垃圾收集线程是同时运行或者交叉运行的，那么<mark>在并发标记阶段如果产生新的垃圾对象，CMS 将无法对这些垃圾对象进行标记，最终会导致这些新产生的垃圾对象没有被及时回收</mark>，从而只能在下一次执行 GC 时释放这些之前未被回收的内存空间。</li><li>CMS重新标记阶段只能处理漏标问题，不能处理浮动垃圾</li></ul><h3 id=136--三色标记><a href=#136--%e4%b8%89%e8%89%b2%e6%a0%87%e8%ae%b0 class=header-anchor>#</a>
13.6 三色标记</h3><p>三色标记法将对象的颜色分为了黑、灰、白，三种颜色。</p><ul><li><p><strong>白色</strong>：该对象没有被标记过（对象垃圾）。可达性分析算法刚开始阶段，所有对象都是白色的</p></li><li><p><strong>灰色</strong>：该对象已经被标记过了，但该对象下的直接属性没有全被标记完。（GC需要从此对象中去寻找垃圾）</p></li><li><p><strong>黑色</strong>：该对象已经被标记过了，且该对象下的直接属性也全部都被标记过了。（程序所需要的对象）</p></li></ul><ol><li>首先创建三个集合：白、灰、黑。</li><li>将所有对象放入白色集合中。</li><li>然后从根节点开始遍历所有直接对象（注意这里并不<strong>递归遍历</strong>），把遍历到的对象从白色集合放入灰色集合。CMS的初始标记</li><li>之后遍历灰色集合，将灰色对象引用的直接对象从白色集合放入灰色集合，之后将此灰色对象放入黑色集合。CMS的并发标记</li><li>重复 4 直到灰色中无任何对象</li><li>通过write-barrier检测对象有变化，重复以上操作</li><li>收集所有白色对象（垃圾）</li></ol><p><img src=https://logan.1357810.xyz/img/20220426/1650906474-962103593bc73f.image width=900 height=600 loading=lazy decoding=async alt=img class="gallery-image link-image" data-flex-grow=20 data-flex-basis=20px></p><ul><li><p>CMS中会产生浮动垃圾，在并发标记过程中，如果由于方法结束导致部分局部变量(GC Roots)被销毁，这个gcroot引用的对象之前又被扫描过(被标记为可达对象)，那么本轮GC不会回收这部分内存，这部分本应该回收但是没有回收到的内存，被称为浮动垃圾。浮动垃圾并不会影响垃圾回收的正确性，只是等到下一轮垃圾回收中才会被清除；</p><ul><li><mark>另外，针对并发标记(并发清理)开始后产生的新对象，通常的做法是直接全部当成黑色，本轮不会进行清除。这部分对象期间可能也会变成垃圾，这也算是浮动垃圾的一部分。</mark></li></ul></li><li><p>CMS中并发标记会产生漏标问题，会导致引用的对象被当成垃圾误删除，这是严重bug，必须解决；有两种解决方案：</p><p>1、<mark>增量更新(incremental update)</mark>：当黑色对象插入新的指向白色对象的引用关系时，就将这个新插入的引用记录下来，等到并发扫描结束之后，再将这些记录过的引用关系中的黑色对象为根，重新扫描一次，可以简化理解为，黑色对象一旦新插入了指向白色对象的引用之后，它就变回灰色对象了。</p><p>​ 因为增量更新不记录删除的引用关系，当某个引用关系被标记后，用户线程将该引用关系断开，这个断开操作不会被记录，所以断开的对象就不会被清除，产生了浮动垃圾。</p><p>2、<mark>原始快照(Snapshot At The Beginning,STAB)</mark>：当灰色对象要删除指向白色对象的引用关系时，就将这个要删除的引用记录下来，相当于保存当时引用链的快照。在并发扫描结束之后，再从这些记录过的引用关系中的对象当根结点扫描，这样就能把扫描到的对象标记为黑色，目的就是让这种对象在本轮gc清理中能存活下来，待下一次gc的时候重新扫描，这个对象也有可能是浮动垃圾。这也可以简化理解为，无论引用关系删除与否，都会按照刚刚开始扫描那一刻的对象图快照来进行搜索。</p><p>​ 对象可能会在 G1 收集期间死亡并且不会被收集。G1 使用一种称为开始快照 (SATB) 的技术来保证垃圾收集器找到所有活动对象。SATB 指出，出于收集的目的，在并发标记（整个堆上的标记）开始时处于活动状态的任何对象都被认为是活动的。SATB 允许以类似于 CMS 增量更新的方式浮动垃圾。</p><blockquote><p>Floating Garbage
Objects can die during a G1 collection and not be collected. G1 uses a technique called snapshot-at-the-beginning (SATB) to guarantee that all live objects are found by the garbage collector. SATB states that any object that is live at the start of the concurrent marking (a marking over the entire heap) is considered live for the purpose of the collection. SATB allows floating garbage in a way analogous to that of a CMS incremental update.</p></blockquote></li></ul><ul><li>以上无论是对对象引用关系记录的插入还是删除，虚拟机的记录操作都是通过写屏障实现的</li></ul><ul><li><mark>CMS重新标记阶段使用写屏障 + 增量更新的措施，不能处理浮动垃圾</mark></li><li><mark>G1最终标记阶段使用写屏障 +原始快照+RememberedSet的措施，能处理浮动垃圾，但是也可能会存在</mark>；处理浮动垃圾，配合<code>Rset</code>，去扫描哪些Region引用到当前的白色对象，若没有引用到当前对象，则回收</li></ul><p>常见的漏标：</p><p><img src=https://logan.1357810.xyz/img/20220426/1650905547-3bb5ecaa9bf201.png width=900 height=600 loading=lazy decoding=async alt=image-20220426005227093 class="gallery-image link-image" data-flex-grow=20 data-flex-basis=20px></p><ul><li>SATB效率高于增量更新的原因？</li></ul><p>因为SATB在重新标记环节只需要去重新扫描那些被推到堆栈中的引用，并配合<code>Rset</code>
来判断当前对象是否被引用来进行回收；</p><p>并且在最后<code>G1</code>
并不会选择回收所有垃圾对象，而是根据<code>Region</code>
的垃圾多少来判断与预估回收价值（指回收的垃圾与回收的<code>STW</code>
时间的一个预估值），将一个或者多个<code>Region</code>
放到<code>CSet</code>
中，最后将这些<code>Region</code>
中的存活对象压缩并复制到新的<code>Region</code>
中，清空原来的<code>Region</code></p><h2 id=61-写屏障><a href=#61-%e5%86%99%e5%b1%8f%e9%9a%9c class=header-anchor>#</a>
6.1 写屏障</h2><blockquote><p>这是JVM代码级别的屏障，相当于aop，和禁止指令重排的内存屏障没关系</p></blockquote><p>无论是增量更新还是原始快照，都是通过写屏障来实现的。</p><p>增量更新和原始快照都是对引用的操作，一个是新增引用，一个是删除引用，不管是新增还是删除，最终都要把他们收集到集合里去。那么如何收集呢？其实就是在赋值操作之前或者赋值操作之后，把引用丢到集合中去。 在赋值操作的前面或者后面做一些事情，这个过程我们把它叫做代码的操作屏障。</p><p>下面来看看赋值屏障的伪代码，以给某个对象的成员变量赋值为例，底层代码大概是这样的:：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-0-1><a class=lnlinks href=#hl-0-1>1</a>
</span><span class=lnt id=hl-0-2><a class=lnlinks href=#hl-0-2>2</a>
</span><span class=lnt id=hl-0-3><a class=lnlinks href=#hl-0-3>3</a>
</span><span class=lnt id=hl-0-4><a class=lnlinks href=#hl-0-4>4</a>
</span><span class=lnt id=hl-0-5><a class=lnlinks href=#hl-0-5>5</a>
</span><span class=lnt id=hl-0-6><a class=lnlinks href=#hl-0-6>6</a>
</span><span class=lnt id=hl-0-7><a class=lnlinks href=#hl-0-7>7</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-javascript data-lang=javascript><span class=line><span class=cl><span class=cm>/**
</span></span></span><span class=line><span class=cl><span class=cm> * @param field 某对象的成员变量，如 a.b.d
</span></span></span><span class=line><span class=cl><span class=cm> * @param new_value 新值，如 null
</span></span></span><span class=line><span class=cl><span class=cm> */</span>
</span></span><span class=line><span class=cl> <span class=nx>voidoop_field_store</span><span class=p>(</span><span class=nx>oop</span><span class=o>*</span><span class=nx>field</span><span class=p>,</span><span class=nx>oopnew_value</span><span class=p>){</span>
</span></span><span class=line><span class=cl> 	 <span class=o>*</span><span class=nx>field</span> <span class=o>=</span> <span class=nx>new_value</span><span class=p>;</span> <span class=c1>// 赋值操作
</span></span></span><span class=line><span class=cl><span class=c1></span> <span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div><p>所谓的写屏障，其实就是指在赋值操作前后，加入一些处理(可以参考AOP的概念):</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-1-1><a class=lnlinks href=#hl-1-1>1</a>
</span><span class=lnt id=hl-1-2><a class=lnlinks href=#hl-1-2>2</a>
</span><span class=lnt id=hl-1-3><a class=lnlinks href=#hl-1-3>3</a>
</span><span class=lnt id=hl-1-4><a class=lnlinks href=#hl-1-4>4</a>
</span><span class=lnt id=hl-1-5><a class=lnlinks href=#hl-1-5>5</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-javascript data-lang=javascript><span class=line><span class=cl><span class=nx>voidoop_field_store</span><span class=p>(</span><span class=nx>oop</span><span class=o>*</span><span class=nx>field</span><span class=p>,</span><span class=nx>oopnew_value</span><span class=p>){</span>
</span></span><span class=line><span class=cl>    <span class=nx>pre_write_barrier</span><span class=p>(</span><span class=nx>field</span><span class=p>);</span> <span class=c1>// 写屏障‐写前操作
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=o>*</span><span class=nx>field</span> <span class=o>=</span> <span class=nx>new_value</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=nx>post_write_barrier</span><span class=p>(</span><span class=nx>field</span><span class=p>,</span> <span class=nx>value</span><span class=p>);</span> <span class=c1>// 写屏障‐写后操作
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div><ul><li><strong>写屏障实现原始快照</strong></li></ul><p>原始快照是记录对引用的删除。比如在执行a.b.d=null的时候，利用写屏障，将原来B成员变量的引用 对象D记录下来:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-2-1><a class=lnlinks href=#hl-2-1>1</a>
</span><span class=lnt id=hl-2-2><a class=lnlinks href=#hl-2-2>2</a>
</span><span class=lnt id=hl-2-3><a class=lnlinks href=#hl-2-3>3</a>
</span><span class=lnt id=hl-2-4><a class=lnlinks href=#hl-2-4>4</a>
</span><span class=lnt id=hl-2-5><a class=lnlinks href=#hl-2-5>5</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-javascript data-lang=javascript><span class=line><span class=cl><span class=c1>// 写屏障代码
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=k>void</span> <span class=nx>pre_write_barrier</span><span class=p>(</span><span class=nx>oop</span><span class=o>*</span><span class=nx>field</span><span class=p>){</span>
</span></span><span class=line><span class=cl>    <span class=nx>oop</span> <span class=nx>old_value</span> <span class=o>=</span> <span class=o>*</span><span class=nx>field</span><span class=p>;</span> <span class=c1>// 获取旧值
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=nx>remark_set</span><span class=p>.</span><span class=nx>add</span><span class=p>(</span><span class=nx>old_value</span><span class=p>);</span> <span class=c1>// 记录原来的引用对象
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div><ul><li><strong>写屏障实现增量更新</strong></li></ul><p>当对象A的成员变量的引用发生变化时，比如新增引用(a.d = d)，我们可以利用写屏障，将A新的成员变量引用对象D 记录下来:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-3-1><a class=lnlinks href=#hl-3-1>1</a>
</span><span class=lnt id=hl-3-2><a class=lnlinks href=#hl-3-2>2</a>
</span><span class=lnt id=hl-3-3><a class=lnlinks href=#hl-3-3>3</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-javascript data-lang=javascript><span class=line><span class=cl><span class=k>void</span> <span class=nx>post_write_barrier</span><span class=p>(</span><span class=nx>oop</span><span class=o>*</span><span class=nx>field</span><span class=p>,</span><span class=nx>oopnew_value</span><span class=p>){</span> 
</span></span><span class=line><span class=cl>  <span class=nx>remark_set</span><span class=p>.</span><span class=nx>add</span><span class=p>(</span><span class=nx>new_value</span><span class=p>);</span> <span class=c1>// 记录新引用的对象
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div><p>这两块都是屏障代码，一个是在写前执行，一个是在写后执行。 删除操作要在写前执行， 赋值操作要在写后执行。</p><p>下面来看看hotspot源码是如何实现写屏障的，找到oop.inline.hpp文件</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-4-1><a class=lnlinks href=#hl-4-1>1</a>
</span><span class=lnt id=hl-4-2><a class=lnlinks href=#hl-4-2>2</a>
</span><span class=lnt id=hl-4-3><a class=lnlinks href=#hl-4-3>3</a>
</span><span class=lnt id=hl-4-4><a class=lnlinks href=#hl-4-4>4</a>
</span><span class=lnt id=hl-4-5><a class=lnlinks href=#hl-4-5>5</a>
</span><span class=lnt id=hl-4-6><a class=lnlinks href=#hl-4-6>6</a>
</span><span class=lnt id=hl-4-7><a class=lnlinks href=#hl-4-7>7</a>
</span><span class=lnt id=hl-4-8><a class=lnlinks href=#hl-4-8>8</a>
</span><span class=lnt id=hl-4-9><a class=lnlinks href=#hl-4-9>9</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-javascript data-lang=javascript><span class=line><span class=cl><span class=cm>/**
</span></span></span><span class=line><span class=cl><span class=cm> * c++底层调用的赋值方法 
</span></span></span><span class=line><span class=cl><span class=cm> */</span>
</span></span><span class=line><span class=cl><span class=nx>template</span> <span class=o>&lt;</span><span class=kr>class</span> <span class=nx>T</span><span class=o>&gt;</span> <span class=nx>inline</span> <span class=k>void</span> <span class=nx>oop_store</span><span class=p>(</span><span class=kr>volatile</span> <span class=nx>T</span><span class=o>*</span> <span class=nx>p</span><span class=p>,</span> <span class=nx>oop</span> <span class=nx>v</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=nx>update_barrier_set_pre</span><span class=p>((</span><span class=nx>T</span><span class=o>*</span><span class=p>)</span><span class=nx>p</span><span class=p>,</span> <span class=nx>v</span><span class=p>);</span>   <span class=c1>// cast away volatile
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=c1>// Used by release_obj_field_put, so use release_store_ptr.
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=nx>oopDesc</span><span class=o>::</span><span class=nx>release_encode_store_heap_oop</span><span class=p>(</span><span class=nx>p</span><span class=p>,</span> <span class=nx>v</span><span class=p>);</span>
</span></span><span class=line><span class=cl>  <span class=nx>update_barrier_set</span><span class=p>((</span><span class=k>void</span><span class=o>*</span><span class=p>)</span><span class=nx>p</span><span class=p>,</span> <span class=nx>v</span><span class=p>);</span>    <span class=c1>// cast away type
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div><p>这就是一个赋值操作。update_barrier_set_pre((T*)p, v);是一个写前屏障，update_barrier_set((void*)p, v);是一个写后屏障。也就是说在赋值之前和之后增加了一段操作代码。其实可以看出来这段代码和我们的伪代码差不多。名字虽不同，但是含义是一样的。</p><p>再看看SATB在hotspot源码中是如何实现写屏障的。</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-5-1><a class=lnlinks href=#hl-5-1> 1</a>
</span><span class=lnt id=hl-5-2><a class=lnlinks href=#hl-5-2> 2</a>
</span><span class=lnt id=hl-5-3><a class=lnlinks href=#hl-5-3> 3</a>
</span><span class=lnt id=hl-5-4><a class=lnlinks href=#hl-5-4> 4</a>
</span><span class=lnt id=hl-5-5><a class=lnlinks href=#hl-5-5> 5</a>
</span><span class=lnt id=hl-5-6><a class=lnlinks href=#hl-5-6> 6</a>
</span><span class=lnt id=hl-5-7><a class=lnlinks href=#hl-5-7> 7</a>
</span><span class=lnt id=hl-5-8><a class=lnlinks href=#hl-5-8> 8</a>
</span><span class=lnt id=hl-5-9><a class=lnlinks href=#hl-5-9> 9</a>
</span><span class=lnt id=hl-5-10><a class=lnlinks href=#hl-5-10>10</a>
</span><span class=lnt id=hl-5-11><a class=lnlinks href=#hl-5-11>11</a>
</span><span class=lnt id=hl-5-12><a class=lnlinks href=#hl-5-12>12</a>
</span><span class=lnt id=hl-5-13><a class=lnlinks href=#hl-5-13>13</a>
</span><span class=lnt id=hl-5-14><a class=lnlinks href=#hl-5-14>14</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-javascript data-lang=javascript><span class=line><span class=cl><span class=k>void</span> <span class=nx>G1SATBCardTableModRefBS</span><span class=o>::</span><span class=nx>enqueue</span><span class=p>(</span><span class=nx>oop</span> <span class=nx>pre_val</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=c1>// Nulls should have been already filtered.
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=nx>assert</span><span class=p>(</span><span class=nx>pre_val</span><span class=o>-&gt;</span><span class=nx>is_oop</span><span class=p>(</span><span class=kc>true</span><span class=p>),</span> <span class=s2>&#34;Error&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=k>if</span> <span class=p>(</span><span class=o>!</span><span class=nx>JavaThread</span><span class=o>::</span><span class=nx>satb_mark_queue_set</span><span class=p>().</span><span class=nx>is_active</span><span class=p>())</span> <span class=k>return</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=nx>Thread</span><span class=o>*</span> <span class=nx>thr</span> <span class=o>=</span> <span class=nx>Thread</span><span class=o>::</span><span class=nx>current</span><span class=p>();</span>
</span></span><span class=line><span class=cl>  <span class=k>if</span> <span class=p>(</span><span class=nx>thr</span><span class=o>-&gt;</span><span class=nx>is_Java_thread</span><span class=p>())</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=nx>JavaThread</span><span class=o>*</span> <span class=nx>jt</span> <span class=o>=</span> <span class=p>(</span><span class=nx>JavaThread</span><span class=o>*</span><span class=p>)</span><span class=nx>thr</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=nx>jt</span><span class=o>-&gt;</span><span class=nx>satb_mark_queue</span><span class=p>().</span><span class=nx>enqueue</span><span class=p>(</span><span class=nx>pre_val</span><span class=p>);</span>
</span></span><span class=line><span class=cl>  <span class=p>}</span> <span class=k>else</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=nx>MutexLockerEx</span> <span class=nx>x</span><span class=p>(</span><span class=nx>Shared_SATB_Q_lock</span><span class=p>,</span> <span class=nx>Mutex</span><span class=o>::</span><span class=nx>_no_safepoint_check_flag</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=nx>JavaThread</span><span class=o>::</span><span class=nx>satb_mark_queue_set</span><span class=p>().</span><span class=nx>shared_satb_queue</span><span class=p>()</span><span class=o>-&gt;</span><span class=nx>enqueue</span><span class=p>(</span><span class=nx>pre_val</span><span class=p>);</span>
</span></span><span class=line><span class=cl>  <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div><p>我们看到这句话satb_mark_queue_set().shared_satb_queue()->enqueue(pre_val); 将旧值放到队列里。这时为什么会放到队列里面呢？为了提高效率。因为是写操作，在写操作之前和之后增加逻辑，是会影响原来代码的效率的，为了避免对源代码的影响，放入到队列中进行处理。</p><h2 id=62-读屏障><a href=#62-%e8%af%bb%e5%b1%8f%e9%9a%9c class=header-anchor>#</a>
6.2 读屏障</h2><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-6-1><a class=lnlinks href=#hl-6-1>1</a>
</span><span class=lnt id=hl-6-2><a class=lnlinks href=#hl-6-2>2</a>
</span><span class=lnt id=hl-6-3><a class=lnlinks href=#hl-6-3>3</a>
</span><span class=lnt id=hl-6-4><a class=lnlinks href=#hl-6-4>4</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-javascript data-lang=javascript><span class=line><span class=cl><span class=nx>oopoop_field_load</span><span class=p>(</span><span class=nx>oop</span><span class=o>*</span><span class=nx>field</span><span class=p>){</span>
</span></span><span class=line><span class=cl>	 <span class=nx>pre_load_barrier</span><span class=p>(</span><span class=nx>field</span><span class=p>);</span> <span class=c1>// 读屏障‐读取前操作
</span></span></span><span class=line><span class=cl><span class=c1></span>   <span class=k>return</span> <span class=o>*</span><span class=nx>field</span><span class=p>;</span> 
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div><p>读屏障是直接针对第一步:D d = a.b.d，当读取成员变量时，一律记录下来:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-7-1><a class=lnlinks href=#hl-7-1>1</a>
</span><span class=lnt id=hl-7-2><a class=lnlinks href=#hl-7-2>2</a>
</span><span class=lnt id=hl-7-3><a class=lnlinks href=#hl-7-3>3</a>
</span><span class=lnt id=hl-7-4><a class=lnlinks href=#hl-7-4>4</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-javascript data-lang=javascript><span class=line><span class=cl><span class=nx>voidpre_load_barrier</span><span class=p>(</span><span class=nx>oop</span><span class=o>*</span><span class=nx>field</span><span class=p>){</span>
</span></span><span class=line><span class=cl>	 <span class=nx>oop</span> <span class=nx>old_value</span> <span class=o>=</span> <span class=o>*</span><span class=nx>field</span><span class=p>;</span>
</span></span><span class=line><span class=cl>	 <span class=nx>remark_set</span><span class=p>.</span><span class=nx>add</span><span class=p>(</span><span class=nx>old_value</span><span class=p>);</span> <span class=c1>// 记录读取到的对象
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div><p>现代追踪式(可达性分析)的垃圾回收器几乎都借鉴了三色标记的算法思想，尽管实现的方式不尽相同:比如白色/黑色 集合一般都不会出现(但是有其他体现颜色的地方)、灰色集合可以通过栈/队列/缓存日志等方式进行实现、遍历方式可 以是广度/深度遍历等等。</p><h2 id=63-各种垃圾收集器对漏标的处理方案><a href=#63-%e5%90%84%e7%a7%8d%e5%9e%83%e5%9c%be%e6%94%b6%e9%9b%86%e5%99%a8%e5%af%b9%e6%bc%8f%e6%a0%87%e7%9a%84%e5%a4%84%e7%90%86%e6%96%b9%e6%a1%88 class=header-anchor>#</a>
6.3 各种垃圾收集器对漏标的处理方案</h2><p>对于读写屏障，以Java HotSpot VM为例，其并发标记时对漏标的处理方案如下:</p><ul><li>CMS：采用的是写屏障 + 增量更新</li><li>G1： 采用的是写屏障 + 原汁快照（SATB）</li><li>ZGC：采用的是读屏障</li></ul><p>工程实现中，读写屏障还有其他功能，比如写屏障可以用于记录跨代/区引用的变化，读屏障可以用于支持移动对象的并 发执行等。功能之外，还有性能的考虑，所以对于选择哪种，每款垃圾回收器都有自己的想法。</p><h2 id=64-记忆集和卡表><a href=#64-%e8%ae%b0%e5%bf%86%e9%9b%86%e5%92%8c%e5%8d%a1%e8%a1%a8 class=header-anchor>#</a>
6.4 记忆集和卡表</h2><h3 id=1记忆集remember-set><a href=#1%e8%ae%b0%e5%bf%86%e9%9b%86remember-set class=header-anchor>#</a>
1.记忆集（Remember Set）</h3><p>在新生代触发Minor GC进行GC Root可达性扫描的时候，可能会碰到跨代引用。比如：新生代的一个对象被老年代引用了，这个时候，在垃圾回收的时候，我们不应该把这块空间回收掉。那怎么办呢？要去扫描一遍老年代么？这显然不行，效率太低了。为了解决这个问题，GC在扫描的时候，会把老年代引用的对象放在一个叫做记忆集的集合中。</p><p>这样在垃圾回收的时候，除了会扫描GC Root下的对象，还会扫描一遍记忆集中的引用。记忆集是存储在新生代的空间，保存着老年代对新生代内存的引用关系。记忆集就是为了解决对象的跨代引用问题。</p><p>垃圾收集过程中， 收集器只需要通过记忆集来判断某一块非收集区域是否存在指向收集区域的指针即可，无需了解跨代引用指针的全部细节。</p><h3 id=2卡表card-table><a href=#2%e5%8d%a1%e8%a1%a8card-table class=header-anchor>#</a>
2.卡表（Card Table）</h3><p>hotspot使用的是卡表（cardtable）来实现记忆集。卡表其实就是记忆集的一个实现，卡表和记忆集的关系就像HashMap和Map的关系。记忆集相当于一个概念，而jdk中是通过卡表来实现的。到底是如何实现的呢？</p><p><img src=https://logan.1357810.xyz/img/20220426/1650910288-d07867b199f96b.png width=900 height=600 loading=lazy decoding=async alt=img class="gallery-image link-image" data-flex-grow=20 data-flex-basis=20px></p><p>卡表是使用字节数组实现的，卡表的每一个元素对应着其标志的内存区域里一块待定大小的内存块。这些待定的内存块就是“卡页”。堆空间分为新生代和老年代，卡表会把老年代划分为一块一块小的格子，这些小格子就是“卡页”。卡页划分是按照512字节大小进行划分的。如果有一个卡页引用了新生代的对象，那么就将这个卡页就会被标记为“dirty”。卡表是一个数组，里面记录了所有卡页的状态，用010101来标记卡页是否引用了新生代对象。如果是就标记为1，不是就保持原来的0. 数组里除了存放卡页的状态，还有卡页的地址。在垃圾收集器进行扫描的时候，除了扫描GC Root之外，还会扫描卡表里那些状态为1的卡页里的对象。 卡页是在老年代，维护卡页的卡表是在年轻代。</p><h3 id=1363-设置的参数><a href=#1363-%e8%ae%be%e7%bd%ae%e7%9a%84%e5%8f%82%e6%95%b0 class=header-anchor>#</a>
13.6.3. 设置的参数</h3><ul><li><p><code>-XX:+UseConcMarkSweepGC </code>手动指定使用 CMS 收集器执行内存回收任务。</p><p>开启该参数后会自动将<code>-xx:+UseParNewGC</code>打开。即：ParNew（Young 区用）+CMS（Old 区用）+ Serial Old 的组合。</p></li><li><p><code>-XX:CMSInitiatingOccupancyFraction</code> 设置堆内存使用率的阈值，一旦达到该阈值，便开始进行回收。</p><ul><li>JDK5 及以前版本的默认值为 68，即当老年代的空间使用率达到 68%时，会执行一次 CMS 回收。<mark>JDK6 及以上版本默认值为 92%</mark></li><li>如果内存增长缓慢，则可以设置一个稍大的值，大的阀值可以有效降低 CMS 的触发频率，减少老年代回收的次数可以较为明显地改善应用程序性能。反之，如果应用程序内存使用率增长很快，则应该降低这个阈值，以避免频繁触发老年代串行收集器。因此通过该选项便可以有效降低 Ful1Gc 的执行次数。</li><li><code>-XX:+UseCMSInitiatingOccupanyOnly</code> 只使用设定的阈值(CMSInitiatingOccupanyFraction),如果不指定，jvm仅在第一次使用设定值，后续会自动调整阈值</li></ul></li><li><p><code>-XX:+UseCMSCompactAtFullCollection</code> 用于指定在执行完 Full GC 后对内存空间进行压缩整理，以此避免内存碎片的产生。不过由于内存压缩整理过程无法并发执行，所带来的问题就是停顿时间变得更长了。默认开启</p></li><li><p><code>-XX:CMSFullGCsBeforeCompaction</code> 设置在执行多少次 Full GC 后对内存空间进行压缩整理，默认为0。</p></li><li><p><code>-XX:CMSScavengeBeforeRemark</code>,在CMS GC前启动一次minorGC，目的减少老年代对新生代的引用，降低CMS GC的标记时段的开销，一般CMS的GC耗时80%都在标记阶段，默认关闭</p></li><li><p><code>-XX:+CMSParallelInitialMarkEnabled</code>,表示在初始标记阶段多线程执行，缩短STW，默认开启</p></li><li><p><code>-XX:+CMSParallelRemarkEnabled</code>,CMSParallelRemarkEnabled表示在重新标记阶段多线程执行，缩短STW，默认开启</p></li><li><p><code>-XX:ParallelcMSThreads</code> 设置 CMS 的线程数量。</p><ul><li>CMS 默认启动的线程数是（ParallelGCThreads+3）/4，ParallelGCThreads 是年轻代并行收集器的线程数。当 CPU 资源比较紧张时，受到 CMS 收集器线程的影响，应用程序的性能在垃圾回收阶段可能会非常糟糕。</li></ul></li></ul><h3 id=小结><a href=#%e5%b0%8f%e7%bb%93 class=header-anchor>#</a>
小结</h3><p>HotSpot 有这么多的垃圾回收器，那么如果有人问，Serial GC、Parallel GC、Concurrent Mark Sweep GC 这三个 Gc 有什么不同呢？</p><p>请记住以下口令：</p><ul><li>如果你想要最小化地使用内存和并行开销，请选 Serial GC；</li><li>如果你想要最大化应用程序的吞吐量，请选 Parallel GC；</li><li>如果你想要最小化 GC 的中断或停顿时间，请选 CMS GC。</li></ul><h3 id=1364-jdk-后续版本中-cms-的变化><a href=#1364-jdk-%e5%90%8e%e7%bb%ad%e7%89%88%e6%9c%ac%e4%b8%ad-cms-%e7%9a%84%e5%8f%98%e5%8c%96 class=header-anchor>#</a>
13.6.4. JDK 后续版本中 CMS 的变化</h3><p>JDK9 新特性：CMS 被标记为 Deprecate 了（JEP291）</p><ul><li>如果对 JDK9 及以上版本的 HotSpot 虚拟机使用参数<code>-XX: +UseConcMarkSweepGC</code>来开启 CMS 收集器的话，用户会收到一个警告信息，提示 CMS 未来将会被废弃。</li></ul><p>JDK14 新特性：删除 CMS 垃圾回收器（JEP363）</p><ul><li>移除了 CMS 垃圾收集器，如果在 JDK14 中使用 <code>-XX:+UseConcMarkSweepGC</code>的话，JVM 不会报错，只是给出一个 warning 信息，但是不会 exit。JVM 会自动回退以默认 GC 方式启动 JVM</li></ul><h2 id=137-g1-回收器区域化分代式><a href=#137-g1-%e5%9b%9e%e6%94%b6%e5%99%a8%e5%8c%ba%e5%9f%9f%e5%8c%96%e5%88%86%e4%bb%a3%e5%bc%8f class=header-anchor>#</a>
13.7. G1 回收器：区域化分代式</h2><p><strong>既然我们已经有了前面几个强大的 GC，为什么还要发布 Garbage First（G1）？</strong></p><p>原因就在于应用程序所应对的<mark>业务越来越庞大、复杂，用户越来越多</mark>，没有 GC 就不能保证应用程序正常进行，而经常造成 STW 的 GC 又跟不上实际的需求，所以才会不断地尝试对 GC 进行优化。G1（Garbage-First）垃圾回收器是在 Java7 update4 之后引入的一个新的垃圾回收器，是当今收集器技术发展的最前沿成果之一。</p><p>与此同时，为了适应现在<mark>不断扩大的内存和不断增加的处理器数量</mark>，进一步降低暂停时间（pause time），同时兼顾良好的吞吐量。</p><p><mark>官方给 G1 设定的目标是在延迟可控的情况下获得尽可能高的吞吐量，所以才担当起“全功能收集器”的重任与期望。</mark></p><p><strong>为什么名字叫 Garbage First(G1)呢？</strong></p><p>因为 G1 是一个并行回收器，它把堆内存分割为很多不相关的区域（Region）（物理上不连续的）。使用不同的 Region 来表示 Eden、幸存者 0 区，幸存者 1 区，老年代等。</p><p>G1 GC 有计划地避免在整个 Java 堆中进行全区域的垃圾收集。G1 跟踪各个 Region 里面的垃圾堆积的价值大小（回收所获得的空间大小以及回收所需时间的经验值），在后台维护一个优先列表，<mark>每次根据允许的收集时间，优先回收价值最大的 Region</mark>。</p><p>由于这种方式的侧重点在于回收垃圾最大量的区间（Region），所以我们给 G1 一个名字：垃圾优先（Garbage First）。</p><p>G1（Garbage-First）是一款面向服务端应用的垃圾收集器，<mark>主要针对配备多核 CPU 及大容量内存的机器</mark>，以极高概率满足 GC 停顿时间的同时，还兼具高吞吐量的性能特征。</p><p>在 JDK1.7 版本正式启用，移除了 Experimenta1 的标识，是<mark>JDK9 以后的默认垃圾回收器</mark>，取代了 CMS 回收器以及 Parallel+Parallel Old 组合。被 Oracle 官方称为“<mark>全功能的垃圾收集器</mark>”。</p><p>与此同时，CMS 已经在 JDK9 中被标记为废弃（deprecated）。在 jdk8 中还不是默认的垃圾回收器，需要使用<code>-XX:+UseG1GC</code>来启用。</p><h3 id=1371-g1-回收器的特点优势><a href=#1371-g1-%e5%9b%9e%e6%94%b6%e5%99%a8%e7%9a%84%e7%89%b9%e7%82%b9%e4%bc%98%e5%8a%bf class=header-anchor>#</a>
13.7.1. G1 回收器的特点（优势）</h3><p>与其他 GC 收集器相比，G1 使用了全新的分区算法，其特点如下所示：</p><h4 id=并行与并发><a href=#%e5%b9%b6%e8%a1%8c%e4%b8%8e%e5%b9%b6%e5%8f%91 class=header-anchor>#</a>
并行与并发</h4><ul><li>并行性：G1 在回收期间，可以有多个 GC 线程同时工作，有效利用多核计算能力。此时用户线程 STW</li><li>并发性：G1 拥有与应用程序交替执行的能力，部分工作可以和应用程序同时执行，因此，一般来说，不会在整个回收阶段发生完全阻塞应用程序的情况</li></ul><h4 id=分代收集><a href=#%e5%88%86%e4%bb%a3%e6%94%b6%e9%9b%86 class=header-anchor>#</a>
分代收集</h4><ul><li>从分代上看，<mark>G1 依然属于分代型垃圾回收器</mark>，它会区分年轻代和老年代，年轻代依然有 Eden 区和 Survivor 区。但从堆的结构上看，它不要求整个 Eden 区、年轻代或者老年代都是连续的，也不再坚持固定大小和固定数量。</li><li>将<mark>堆空间分为若干个区域（Region），这些区域中包含了逻辑上的年轻代和老年代</mark>。</li><li>和之前的各类回收器不同，它同时<mark>兼顾年轻代和老年代</mark>。对比其他回收器，或者工作在年轻代，或者工作在老年代；</li></ul><p><img src=https://logan.1357810.xyz/img/20220422/153020741-087e0241b6.png width=900 height=600 loading=lazy decoding=async alt=image-20200713215105293 class="gallery-image link-image" data-flex-grow=20 data-flex-basis=20px></p><p><img src=https://logan.1357810.xyz/img/20220422/153020741-2cea0769b8.png width=900 height=600 loading=lazy decoding=async alt=image-20200713215133839 class="gallery-image link-image" data-flex-grow=20 data-flex-basis=20px></p><h4 id=空间整合><a href=#%e7%a9%ba%e9%97%b4%e6%95%b4%e5%90%88 class=header-anchor>#</a>
空间整合</h4><ul><li>CMS：“标记-清除”算法、内存碎片、若干次 Gc 后进行一次碎片整理</li><li>G1 将内存划分为一个个的 region。内存的回收是以 region 作为基本单位的。<mark>Region 之间是复制算法</mark>，但整体上实际可看作是<mark>标记-压缩（Mark-Compact）算法</mark>，两种算法都可以避免内存碎片。这种特性有利于程序长时间运行，分配大对象时不会因为无法找到连续内存空间而提前触发下一次 GC。尤其是当 Java 堆非常大的时候，G1 的优势更加明显。</li></ul><h4 id=可预测的停顿时间模型即软实时-soft-real-time><a href=#%e5%8f%af%e9%a2%84%e6%b5%8b%e7%9a%84%e5%81%9c%e9%a1%bf%e6%97%b6%e9%97%b4%e6%a8%a1%e5%9e%8b%e5%8d%b3%e8%bd%af%e5%ae%9e%e6%97%b6-soft-real-time class=header-anchor>#</a>
可预测的停顿时间模型（即：软实时 soft real-time）</h4><p>这是 G1 相对于 CMS 的另一大优势，G1 除了追求低停顿外，还能建立可预测的停顿时间模型，能让使用者明确指定在一个长度为 M 毫秒的时间片段内，消耗在垃圾收集上的时间不得超过 N 毫秒。</p><ul><li>由于分区的原因，G1 可以只选取部分区域进行内存回收，这样缩小了回收的范围，因此对于全局停顿情况的发生也能得到较好的控制。</li><li>G1 跟踪各个 Region 里面的垃圾堆积的价值大小（回收所获得的空间大小以及回收所需时间的经验值），在后台维护一个优先列表，<mark>每次根据允许的收集时间，优先回收价值最大的 Region</mark>。保证了 G1 收集器在有限的时间内可以获取尽可能高的收集效率。</li><li>相比于 CMSGC，G1 未必能做到 CMS 在最好情况下的延时停顿，但是最差情况要好很多。</li></ul><h3 id=1372-g1-垃圾收集器的缺点><a href=#1372-g1-%e5%9e%83%e5%9c%be%e6%94%b6%e9%9b%86%e5%99%a8%e7%9a%84%e7%bc%ba%e7%82%b9 class=header-anchor>#</a>
13.7.2. G1 垃圾收集器的缺点</h3><p>相较于 CMS，G1 还不具备全方位、压倒性优势。比如在用户程序运行过程中，G1 无论是为了垃圾收集产生的内存占用（Footprint）还是程序运行时的额外执行负载（Overload）都要比 CMS 要高。</p><p>从经验上来说，在小内存应用上 CMS 的表现大概率会优于 G1，而 G1 在大内存应用上则发挥其优势。平衡点在 6-8GB 之间。</p><h3 id=1373-g1-回收器的参数设置><a href=#1373-g1-%e5%9b%9e%e6%94%b6%e5%99%a8%e7%9a%84%e5%8f%82%e6%95%b0%e8%ae%be%e7%bd%ae class=header-anchor>#</a>
13.7.3. G1 回收器的参数设置</h3><ul><li><code>-XX:+UseG1GC</code>：手动指定使用 G1 垃圾收集器执行内存回收任务</li><li><code>-XX:G1HeapRegionSize</code> 设置每个 Region 的大小。值是 2 的幂，范围是 1MB 到 32MB 之间，目标是根据最小的 Java 堆大小划分出约 2048 个区域。默认是堆内存的 1/2000。</li><li><code>-XX:MaxGCPauseMillis</code> 设置期望达到的最大 GC 停顿时间指标（JVM 会尽力实现，但不保证达到）。默认值是 200ms（人的平均反应速度）</li><li><code>-XX:+ParallelGCThread</code> 设置 STW 工作线程数的值。最多设置为 8（上面说过 Parallel 回收器的线程计算公式，当 CPU_Count > 8 时，ParallelGCThreads 也会大于 8）</li><li><code>-XX:ConcGCThreads</code> 设置并发标记的线程数。将 n 设置为并行垃圾回收线程数（ParallelGCThreads）的 1/4 左右。</li><li><code>-XX:InitiatingHeapOccupancyPercent</code> 设置触发并发 GC 周期的 Java 堆占用率阈值。超过此值，就触发 GC。默认值是 45。</li></ul><h3 id=1374-g1-收集器的常见操作步骤><a href=#1374-g1-%e6%94%b6%e9%9b%86%e5%99%a8%e7%9a%84%e5%b8%b8%e8%a7%81%e6%93%8d%e4%bd%9c%e6%ad%a5%e9%aa%a4 class=header-anchor>#</a>
13.7.4. G1 收集器的常见操作步骤</h3><p>G1 的设计原则就是简化 JVM 性能调优，开发人员只需要简单的三步即可完成调优：</p><ul><li>第一步：开启 G1 垃圾收集器</li><li>第二步：设置堆的最大内存</li><li>第三步：设置最大的停顿时间</li></ul><p>G1 中提供了三种垃圾回收模式：Young GC、Mixed GC 和 Full GC，在不同的条件下被触发。</p><h3 id=1375-g1-收集器的适用场景><a href=#1375-g1-%e6%94%b6%e9%9b%86%e5%99%a8%e7%9a%84%e9%80%82%e7%94%a8%e5%9c%ba%e6%99%af class=header-anchor>#</a>
13.7.5. G1 收集器的适用场景</h3><p>面向服务端应用，针对具有大内存、多处理器的机器。（在普通大小的堆里表现并不惊喜）</p><p>最主要的应用是需要低 GC 延迟，并具有大堆的应用程序提供解决方案；如：在堆大小约 6GB 或更大时，可预测的暂停时间可以低于 0.5 秒；（G1 通过每次只清理一部分而不是全部的 Region 的增量式清理来保证每次 GC 停顿时间不会过长）。</p><p>用来替换掉 JDK1.5 中的 CMS 收集器；在下面的情况时，使用 G1 可能比 CMS 好：</p><ul><li>超过 50%的 Java 堆被活动数据占用；</li><li>对象分配频率或年代提升频率变化很大；</li><li>GC 停顿时间过长（长于 0.5 至 1 秒）</li></ul><p>HotSpot 垃圾收集器里，除了 G1 以外，其他的垃圾收集器使用内置的 JVM 线程执行 GC 的多线程操作，而 G1 GC 可以采用应用线程承担后台运行的 GC 工作，即当 JVM 的 GC 线程处理速度慢时，系统会调用应用程序线程帮助加速垃圾回收过程。</p><h3 id=1376-分区-region化整为零><a href=#1376-%e5%88%86%e5%8c%ba-region%e5%8c%96%e6%95%b4%e4%b8%ba%e9%9b%b6 class=header-anchor>#</a>
13.7.6. 分区 Region：化整为零</h3><p>使用 G1 收集器时，它将整个 Java 堆划分成约 2048 个大小相同的独立 Region 块，每个 Region 块大小根据堆空间的实际大小而定，整体被控制在 1MB 到 32MB 之间，且为 2 的 N 次幂，即 1MB，2MB，4MB，8MB，16MB，32MB。可以通过<code>-XX:G1HeapRegionSize</code>设定。<mark>所有的 Region 大小相同，且在 JVM 生命周期内不会被改变。</mark></p><p>虽然还保留有新生代和老年代的概念，但新生代和老年代不再是物理隔离的了，它们都是一部分 Region（不需要连续）的集合。通过 Region 的动态分配方式实现逻辑上的连续。</p><p><img src=https://logan.1357810.xyz/img/20220422/153020741-54081704f5.png width=900 height=600 loading=lazy decoding=async alt=image-20200713223244886 class="gallery-image link-image" data-flex-grow=20 data-flex-basis=20px></p><p>一个 region 有可能属于 Eden，Survivor 或者 Old/Tenured 内存区域。但是一个 region 只可能属于一个角色。图中的 E 表示该 region 属于 Eden 内存区域，S 表示属于 survivor 内存区域，O 表示属于 Old 内存区域。图中空白的表示未使用的内存空间。</p><p>G1 垃圾收集器还增加了一种新的内存区域，叫做 Humongous 内存区域，如图中的 H 块。主要用于存储大对象，如果超过 1.5 个 region，就放到 H。</p><p>设置 H 的原因：对于堆中的对象，默认直接会被分配到老年代，但是如果它是一个短期存在的大对象就会对垃圾收集器造成负面影响。为了解决这个问题，G1 划分了一个 Humongous 区，它用来专门存放大对象。<mark>如果一个 H 区装不下一个大对象，那么 G1 会寻找连续的 H 区来存储。</mark>为了能找到连续的 H 区，有时候不得不启动 Full GC。G1 的大多数行为都把 H 区作为老年代的一部分来看待。</p><p>每个 Region 都是通过指针碰撞来分配空间</p><p><img src=https://logan.1357810.xyz/img/20220422/153020741-4e6708b64c.png width=900 height=600 loading=lazy decoding=async alt=image-20200713223509993 class="gallery-image link-image" data-flex-grow=20 data-flex-basis=20px></p><h3 id=1377-g1-垃圾回收器的回收过程><a href=#1377-g1-%e5%9e%83%e5%9c%be%e5%9b%9e%e6%94%b6%e5%99%a8%e7%9a%84%e5%9b%9e%e6%94%b6%e8%bf%87%e7%a8%8b class=header-anchor>#</a>
13.7.7. G1 垃圾回收器的回收过程</h3><p><img src=https://logan.1357810.xyz/img/20220426/1650955647-3d45254267f3f1.png width=900 height=600 loading=lazy decoding=async alt=image-20220426144726900 class="gallery-image link-image" data-flex-grow=20 data-flex-basis=20px></p><p><img src=https://logan.1357810.xyz/img/20220426/1650955730-6a22704e049a00.png width=900 height=600 loading=lazy decoding=async alt=image-20220426144849963 class="gallery-image link-image" data-flex-grow=20 data-flex-basis=20px></p><p>G1GC 的垃圾回收过程主要包括如下三个环节：</p><ul><li><p>年轻代 GC（Young GC）</p></li><li><p>老年代并发标记过程（Concurrent Marking）</p></li><li><p>混合回收（Mixed GC）</p><p>（如果需要，单线程、独占式、高强度的 Full GC 还是继续存在的。它针对 GC 的评估失败提供了一种失败保护机制，即强力回收。）</p></li></ul><p><img src=https://logan.1357810.xyz/img/20220422/153020741-7c259547af.png width=900 height=600 loading=lazy decoding=async alt=image-20200713224113996 class="gallery-image link-image" data-flex-grow=20 data-flex-basis=20px></p><p>顺时针，Young gc -> Young gc + Concurrent mark->Mixed GC 顺序，进行垃圾回收。</p><p>应用程序分配内存，<mark>当年轻代的 Eden 区用尽时开始年轻代回收过程</mark>；G1 的年轻代收集阶段是一个<mark>并行的独占式</mark>收集器。在年轻代回收期，G1GC 暂停所有应用程序线程，启动多线程执行年轻代回收。然后<mark>从年轻代区间移动存活对象到 Survivor 区间或者老年区间，也有可能是两个区间都会涉及</mark>。</p><p>当堆内存使用达到一定值（默认 45%）时，开始老年代并发标记过程。</p><p>标记完成马上开始混合回收过程。对于一个混合回收期，G1 GC 从老年区间移动存活对象到空闲区间，这些空闲区间也就成为了老年代的一部分。和年轻代不同，老年代的 G1 回收器和其他 GC 不同，<mark>G1 的老年代回收器不需要整个老年代被回收，一次只需要扫描/回收一小部分老年代的 Region 就可以了</mark>。同时，这个老年代 Region 是和年轻代一起被回收的。</p><p>举个例子：一个 Web 服务器，Java 进程最大堆内存为 4G，每分钟响应 1500 个请求，每 45 秒钟会新分配大约 2G 的内存。G1 会每 45 秒钟进行一次年轻代回收，每 31 个小时整个堆的使用率会达到 45%，会开始老年代并发标记过程，标记完成后开始四到五次的混合回收。</p><h3 id=1378-remembered-set><a href=#1378-remembered-set class=header-anchor>#</a>
13.7.8. Remembered Set</h3><ul><li><p>一个对象被不同区域引用的问题</p></li><li><p>一个 Region 不可能是孤立的，一个 Region 中的对象可能被其他任意 Region 中对象引用，判断对象存活时，是否需要扫描整个 Java 堆才能保证准确？</p></li><li><p>在其他的分代收集器，也存在这样的问题（而 G1 更突出）回收新生代也不得不同时扫描老年代？</p></li><li><p>这样的话会降低 MinorGC 的效率；</p></li></ul><p><strong>解决方法：</strong></p><p>无论 G1 还是其他分代收集器，JVM 都是使用 Remembered Set 来避免全局扫描：</p><p><mark>每个 Region 都有一个对应的 Remembered Set；</mark></p><p>每次 Reference 类型数据写操作时，都会产生一个 Write Barrier 暂时中断操作；</p><p>然后检查将要写入的引用指向的对象是否和该 Reference 类型数据在不同的 Region（其他收集器：检查老年代对象是否引用了新生代对象）；</p><p>如果不同，通过 CardTable 把相关引用信息记录到引用指向对象的所在 Region 对应的 Remembered Set 中；</p><p>当进行垃圾收集时，在 GC 根节点的枚举范围加入 Remembered Set；就可以保证不进行全局扫描，也不会有遗漏。</p><p><img src=https://logan.1357810.xyz/img/20220422/153020741-3af2bc87cd.png width=900 height=600 loading=lazy decoding=async alt=image-20200713224716715 class="gallery-image link-image" data-flex-grow=20 data-flex-basis=20px></p><h3 id=1379-g1-回收过程一年轻代-gc><a href=#1379-g1-%e5%9b%9e%e6%94%b6%e8%bf%87%e7%a8%8b%e4%b8%80%e5%b9%b4%e8%bd%bb%e4%bb%a3-gc class=header-anchor>#</a>
13.7.9. G1 回收过程一：年轻代 GC</h3><p>JVM 启动时，G1 先准备好 Eden 区，程序在运行过程中不断创建对象到 Eden 区，当 Eden 空间耗尽时，G1 会启动一次年轻代垃圾回收过程。</p><p>年轻代垃圾回收只会回收 Eden 区和 Survivor 区。</p><p>首先 G1 停止应用程序的执行（Stop-The-World），G1 创建回收集（Collection Set），回收集是指需要被回收的内存分段的集合，年轻代回收过程的回收集包含年轻代 Eden 区和 Survivor 区所有的内存分段。</p><p><img src=https://logan.1357810.xyz/img/20220422/153020741-1ec99a133b.png width=900 height=600 loading=lazy decoding=async alt=image-20200713225100632 class="gallery-image link-image" data-flex-grow=20 data-flex-basis=20px></p><p>然后开始如下回收过程：</p><ol><li><mark>第一阶段，扫描根</mark>。根是指 static 变量指向的对象，正在执行的方法调用链条上的局部变量等。根引用连同 RSet 记录的外部引用作为扫描存活对象的入口。</li><li><mark>第二阶段，更新 RSet</mark>。处理 dirty card queue（见备注）中的 card，更新 RSet。此阶段完成后，<mark>RSet 可以准确的反映老年代对所在的内存分段中对象的引用</mark>。</li><li><mark>第三阶段，处理 RSet</mark>。识别被老年代对象指向的 Eden 中的对象，这些被指向的 Eden 中的对象被认为是存活的对象。</li><li><mark>第四阶段，复制对象</mark>。此阶段，对象树被遍历，Eden 区内存段中存活的对象会被复制到 Survivor 区中空的内存分段，Survivor 区内存段中存活的对象如果年龄未达阈值，年龄会加 1，达到阀值会被会被复制到 Old 区中空的内存分段。如果 Survivor 空间不够，Eden 空间的部分数据会直接晋升到老年代空间。</li><li><mark>第五阶段，处理引用</mark>。处理 Soft，Weak，Phantom，Final，JNI Weak 等引用。最终 Eden 空间的数据为空，GC 停止工作，而目标内存中的对象都是连续存储的，没有碎片，所以复制过程可以达到内存整理的效果，减少碎片。</li></ol><h3 id=13710-g1-回收过程二并发标记过程><a href=#13710-g1-%e5%9b%9e%e6%94%b6%e8%bf%87%e7%a8%8b%e4%ba%8c%e5%b9%b6%e5%8f%91%e6%a0%87%e8%ae%b0%e8%bf%87%e7%a8%8b class=header-anchor>#</a>
13.7.10. G1 回收过程二：并发标记过程</h3><ol><li><mark>初始标记阶段</mark>：标记从根节点直接可达的对象。这个阶段是 STW 的，并且会触发一次年轻代 GC。</li><li><mark>根区域扫描（Root Region Scanning）</mark>：G1 GC 扫描 Survivor 区直接可达的老年代区域对象，并标记被引用的对象。这一过程必须在 YoungGC 之前完成。</li><li><mark>并发标记（Concurrent Marking）</mark>：在整个堆中进行并发标记（和应用程序并发执行），此过程可能被 YoungGC 中断。在并发标记阶段，<mark>若发现区域对象中的所有对象都是垃圾，那这个区域会被立即回收</mark>。同时，并发标记过程中，会计算每个区域的对象活性（区域中存活对象的比例）。</li><li><mark>再次标记（Remark）</mark>：由于应用程序持续进行，需要修正上一次的标记结果。是 STW 的。G1 中采用了比 CMS 更快的初始快照算法：snapshot-at-the-beginning（SATB）。</li><li><mark>独占清理（cleanup，STW）</mark>：计算各个区域的存活对象和 GC 回收比例，并进行排序，识别可以混合回收的区域。为下阶段做铺垫。是 STW 的。这个阶段并不会实际上去做垃圾的收集</li><li><mark>并发清理阶段</mark>：识别并清理完全空闲的区域。</li></ol><h3 id=13711-g1-回收过程三混合回收><a href=#13711-g1-%e5%9b%9e%e6%94%b6%e8%bf%87%e7%a8%8b%e4%b8%89%e6%b7%b7%e5%90%88%e5%9b%9e%e6%94%b6 class=header-anchor>#</a>
13.7.11. G1 回收过程三：混合回收</h3><p>当越来越多的对象晋升到老年代 o1d region 时，为了避免堆内存被耗尽，虚拟机会触发一个混合的垃圾收集器，即 Mixed GC，该算法并不是一个 Old GC，除了回收整个 Young Region，还会回收一部分的 Old Region。这里需要注意：<mark>是一部分老年代，而不是全部老年代</mark>。可以选择哪些 Old Region 进行收集，从而可以对垃圾回收的耗时时间进行控制。也要注意的是 Mixed GC 并不是 Full GC。</p><p><img src=https://logan.1357810.xyz/img/20220422/153020741-1a30560c40.png width=900 height=600 loading=lazy decoding=async alt=image-20200713225810871 class="gallery-image link-image" data-flex-grow=20 data-flex-basis=20px></p><p>并发标记结束以后，老年代中百分百为垃圾的内存分段被回收了，部分为垃圾的内存分段被计算了出来。默认情况下，这些老年代的内存分段会分 8 次（可以通过<code>-XX:G1MixedGCCountTarget</code>设置）被回收</p><p>混合回收的回收集（Collection Set）包括八分之一的老年代内存分段，Eden 区内存分段，Survivor 区内存分段。混合回收的算法和年轻代回收的算法完全一样，只是回收集多了老年代的内存分段。具体过程请参考上面的年轻代回收过程。</p><p>由于老年代中的内存分段默认分 8 次回收，G1 会优先回收垃圾多的内存分段。垃圾占内存分段比例越高的，越会被先回收。并且有一个阈值会决定内存分段是否被回收，<code>-XX:G1MixedGCLiveThresholdPercent</code>，默认为 65%，意思是垃圾占内存分段比例要达到 65%才会被回收。如果垃圾占比太低，意味着存活的对象占比高，在复制的时候会花费更多的时间。</p><p>混合回收并不一定要进行 8 次。有一个阈值<code>-XX:G1HeapWastePercent</code>，默认值为 10%，意思是允许整个堆内存中有 10%的空间被浪费，意味着如果发现可以回收的垃圾占堆内存的比例低于 10%，则不再进行混合回收。因为 GC 会花费很多的时间但是回收到的内存却很少。</p><h3 id=13712-g1-回收可选的过程四full-gc><a href=#13712-g1-%e5%9b%9e%e6%94%b6%e5%8f%af%e9%80%89%e7%9a%84%e8%bf%87%e7%a8%8b%e5%9b%9bfull-gc class=header-anchor>#</a>
13.7.12. G1 回收可选的过程四：Full GC</h3><p>G1 的初衷就是要避免 Full GC 的出现。但是如果上述方式不能正常工作，G1 会停止应用程序的执行（Stop-The-World），使用单线程的内存回收算法进行垃圾回收，性能会非常差，应用程序停顿时间会很长。</p><p>要避免 Full GC 的发生，一旦发生需要进行调整。什么时候会发生 Full GC 呢？比如<mark>堆内存太小</mark>，当 G1 在复制存活对象的时候没有空的内存分段可用，则会回退到 Full GC，这种情况可以通过增大内存解决。</p><p>导致 G1 Full GC 的原因可能有两个：</p><ul><li>Evacuation 的时候没有足够的 to-space 来存放晋升的对象；</li><li>并发处理过程完成之前空间耗尽。</li></ul><h3 id=13713-补充><a href=#13713-%e8%a1%a5%e5%85%85 class=header-anchor>#</a>
13.7.13. 补充</h3><p>从 Oracle 官方透露出来的信息可获知，回收阶段（Evacuation）其实本也有想过设计成与用户程序一起并发执行，但这件事情做起来比较复杂，考虑到 G1 只是回一部分 Region，停顿时间是用户可控制的，所以并不迫切去实现，而<mark>选择把这个特性放到了 G1 之后出现的低延迟垃圾收集器（即 ZGC）中</mark>。另外，还考虑到 G1 不是仅仅面向低延迟，停顿用户线程能够最大幅度提高垃圾收集效率，为了保证吞吐量所以才选择了完全暂停用户线程的实现方案。</p><h3 id=13714-g1-回收器优化建议><a href=#13714-g1-%e5%9b%9e%e6%94%b6%e5%99%a8%e4%bc%98%e5%8c%96%e5%bb%ba%e8%ae%ae class=header-anchor>#</a>
13.7.14. G1 回收器优化建议</h3><p>年轻代大小</p><ul><li>避免使用<code>-Xmn</code>或<code>-XX:NewRatio</code>等相关选项显式设置年轻代大小</li><li>固定年轻代的大小会覆盖暂停时间目标</li></ul><p>暂停时间目标不要太过严苛</p><ul><li>G1 GC 的吞吐量目标是 90%的应用程序时间和 10%的垃圾回收时间</li><li>评估 G1 GC 的吞吐量时，暂停时间目标不要太严苛。目标太过严苛表示你愿意承受更多的垃圾回收开销，而这些会直接影响到吞吐量。</li></ul><h2 id=138-垃圾回收器总结><a href=#138-%e5%9e%83%e5%9c%be%e5%9b%9e%e6%94%b6%e5%99%a8%e6%80%bb%e7%bb%93 class=header-anchor>#</a>
13.8. 垃圾回收器总结</h2><h3 id=1381-7-种经典垃圾回收器总结><a href=#1381-7-%e7%a7%8d%e7%bb%8f%e5%85%b8%e5%9e%83%e5%9c%be%e5%9b%9e%e6%94%b6%e5%99%a8%e6%80%bb%e7%bb%93 class=header-anchor>#</a>
13.8.1. 7 种经典垃圾回收器总结</h3><p>截止 JDK1.8，一共有 7 款不同的垃圾收集器。每一款的垃圾收集器都有不同的特点，在具体使用的时候，需要根据具体的情况选用不同的垃圾收集器。</p><div class=table-wrapper><table><thead><tr><th style=text-align:left>垃圾收集器</th><th style=text-align:left>分类</th><th style=text-align:left>作用位置</th><th style=text-align:left>使用算法</th><th style=text-align:left>特点</th><th style=text-align:left>适用场景</th></tr></thead><tbody><tr><td style=text-align:left>Serial</td><td style=text-align:left>串行运行</td><td style=text-align:left>作用于新生代</td><td style=text-align:left>复制算法</td><td style=text-align:left>响应速度优先</td><td style=text-align:left>适用于单 CPU 环境下的 client 模式</td></tr><tr><td style=text-align:left>ParNew</td><td style=text-align:left>并行运行</td><td style=text-align:left>作用于新生代</td><td style=text-align:left>复制算法</td><td style=text-align:left>响应速度优先</td><td style=text-align:left>多 CPU 环境 Server 模式下与 CMS 配合使用</td></tr><tr><td style=text-align:left>Parallel</td><td style=text-align:left>并行运行</td><td style=text-align:left>作用于新生代</td><td style=text-align:left>复制算法</td><td style=text-align:left>吞吐量优先</td><td style=text-align:left>适用于后台运算而不需要太多交互的场景</td></tr><tr><td style=text-align:left>Serial Old</td><td style=text-align:left>串行运行</td><td style=text-align:left>作用于老年代</td><td style=text-align:left>标记-压缩算法</td><td style=text-align:left>响应速度优先</td><td style=text-align:left>适用于单 CPU 环境下的 Client 模式</td></tr><tr><td style=text-align:left>Parallel Old</td><td style=text-align:left>并行运行</td><td style=text-align:left>作用于老年代</td><td style=text-align:left>标记-压缩算法</td><td style=text-align:left>吞吐量优先</td><td style=text-align:left>适用于后台运算而不需要太多交互的场景</td></tr><tr><td style=text-align:left>CMS</td><td style=text-align:left>并发运行</td><td style=text-align:left>作用于老年代</td><td style=text-align:left>标记-清除算法</td><td style=text-align:left>响应速度优先</td><td style=text-align:left>适用于互联网或 B／S 业务</td></tr><tr><td style=text-align:left>G1</td><td style=text-align:left>并发、并行运行</td><td style=text-align:left>作用于新生代、老年代</td><td style=text-align:left>标记-压缩算法、复制算法</td><td style=text-align:left>响应速度优先</td><td style=text-align:left>面向服务端应用</td></tr></tbody></table></div><p>GC 发展阶段：Serial => Parallel（并行）=> CMS（并发）=> G1 => ZGC</p><h3 id=1382-垃圾回收器组合><a href=#1382-%e5%9e%83%e5%9c%be%e5%9b%9e%e6%94%b6%e5%99%a8%e7%bb%84%e5%90%88 class=header-anchor>#</a>
13.8.2. 垃圾回收器组合</h3><p>不同厂商、不同版本的虚拟机实现差距比较大。HotSpot 虚拟机在 JDK7/8 后所有收集器及组合如下图</p><p><img src=https://logan.1357810.xyz/img/20220422/153020741-ae115b87cb.png width=900 height=600 loading=lazy decoding=async alt=image-20200714080151020 class="gallery-image link-image" data-flex-grow=20 data-flex-basis=20px></p><ol><li><p>两个收集器间有连线，表明它们可以搭配使用：Serial/Serial Old、Serial/CMS、ParNew/Serial Old、ParNew/CMS、Parallel Scavenge/Serial Old、Parallel Scavenge/Parallel Old、G1;</p></li><li><p>其中 Serial Old 作为 CMS 出现＂<code>Concurrent Mode Failure</code>＂失败的后备预案。</p></li><li><p>（红色虚线）由于维护和兼容性测试的成本，在 JDK 8 时将 Serial ＋ CMS、ParNew ＋ Serial old 这两个组合声明为 Deprecated（JEP 173），并在 JDK 9 中</p></li></ol><p>完全取消了这些组合的支持（JEP214），即：移除。</p><ol start=4><li><p>（绿色虚线）JDK 14 中：弃用 ParallelScavenge 和 SeriaOold GC 组合(JEP 366)</p></li><li><p>（绿色虚框）JDK 14 中：删除 CMS 垃圾回收器（JEP 363）</p></li></ol><h3 id=1383-怎么选择垃圾回收器><a href=#1383-%e6%80%8e%e4%b9%88%e9%80%89%e6%8b%a9%e5%9e%83%e5%9c%be%e5%9b%9e%e6%94%b6%e5%99%a8 class=header-anchor>#</a>
13.8.3. 怎么选择垃圾回收器</h3><p>内存角度：4G以下可以用parallel，4-8G可以用parNew+CMS，8G以上可以用G1，几百G以上可以用ZGC</p><ul><li>业务应用对吞吐量要求较高，对响应时间没有特别要求的，推荐使用并行收集器。如：科学计算和后台处理程序等等。</li><li>对响应时间要求较高的中大型应用程序，推荐使用并发收集器。如：web服务器等。</li><li>对应JDK版本1.8以上，多CPU处理器且内存资源不是瓶颈，建议优先考虑使用G1回收器。</li><li>单线程应用使用串行收集器。</li></ul><p>堆内存：</p><ol><li>应用程序运行时，计算老年代存活对象的占用空间大小X。程序整个堆大小（Xmx和Xms）设置为X的3~4倍；永久代PermSize和MaxPermSize设置为X的1.2~1.5倍。年轻代Xmn的设置为X的1~1.5倍。老年代内存大小设置为X的2~3倍。</li><li>JDK官方建议年轻代占整个堆大小空间的3/8左右。</li><li>完成一次Full GC后，应该释放出70%的堆空间（30%的空间仍然占用）。</li><li>并发量比较大的情况应当适量增大年轻代的空间</li></ol><p>Java 垃圾收集器的配置对于 JVM 优化来说是一个很重要的选择，选择合适的垃圾收集器可以让 JVM 的性能有一个很大的提升。</p><p>怎么选择垃圾收集器？</p><ol><li><p>优先调整堆的大小让 JVM 自适应完成。</p></li><li><p>如果内存小于 100M，使用串行收集器</p></li><li><p>如果是单核、单机程序，并且没有停顿时间的要求，串行收集器</p></li><li><p>如果是多 CPU、需要高吞吐量、允许停顿时间超过 1 秒，选择并行或者 JVM 自己选择</p></li><li><p>如果是多 CPU、追求低停顿时间，需快速响应（比如延迟不能超过 1 秒，如互联网应用），使用并发收集器</p><p>官方推荐 G1，性能高。<mark>现在互联网的项目，基本都是使用 G1</mark>。</p></li></ol><p>最后需要明确一个观点：</p><ol><li>没有最好的收集器，更没有万能的收集</li><li>调优永远是针对特定场景、特定需求，不存在一劳永逸的收集器</li></ol><p><strong>面试</strong></p><p>对于垃圾收集，面试官可以循序渐进从理论、实践各种角度深入，也未必是要求面试者什么都懂。但如果你懂得原理，一定会成为面试中的加分项。 这里较通用、基础性的部分如下：</p><ul><li><p>垃圾收集的算法有哪些？如何判断一个对象是否可以回收？</p></li><li><p>垃圾收集器工作的基本流程。</p></li></ul><p>另外，大家需要多关注垃圾回收器这一章的各种常用的参数</p><h2 id=139-gc-日志分析><a href=#139-gc-%e6%97%a5%e5%bf%97%e5%88%86%e6%9e%90 class=header-anchor>#</a>
13.9. GC 日志分析</h2><p>通过阅读 Gc 日志，我们可以了解 Java 虚拟机内存分配与回收策略。 内存分配与垃圾回收的参数列表</p><ul><li><code>-XX:+PrintGC</code> 输出 GC 日志。类似：<code>-verbose:gc</code></li><li><code>-XX:+PrintGCDetails</code> 输出 GC 的详细日志</li><li><code>-XX:+PrintGCTimestamps</code> 输出 GC 的时间戳（以基准时间的形式）</li><li><code>-XX:+PrintGCDatestamps</code> 输出 GcC 的时间戳（以日期的形式，如 2013-05-04T21：53：59.234+0800）</li><li><code>-XX:+PrintHeapAtGC</code> 在进行 GC 的前后打印出堆的信息</li><li><code>-Xloggc:../logs/gc.log</code> 日志文件的输出路径</li></ul><p>打开 GC 日志</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-8-1><a class=lnlinks href=#hl-8-1>1</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-shell data-lang=shell><span class=line><span class=cl>-verbose:gc
</span></span></code></pre></td></tr></table></div></div><p>这个只会显示总的 GC 堆的变化，如下：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-9-1><a class=lnlinks href=#hl-9-1>1</a>
</span><span class=lnt id=hl-9-2><a class=lnlinks href=#hl-9-2>2</a>
</span><span class=lnt id=hl-9-3><a class=lnlinks href=#hl-9-3>3</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=o>[</span><span class=n>GC</span><span class=w> </span><span class=p>(</span><span class=n>Allocation</span><span class=w> </span><span class=n>Failure</span><span class=p>)</span><span class=w> </span><span class=n>80832K</span><span class=o>-&gt;</span><span class=n>19298K</span><span class=p>(</span><span class=n>227840K</span><span class=p>),</span><span class=n>0</span><span class=p>.</span><span class=na>0084018</span><span class=w> </span><span class=n>secs</span><span class=o>]</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=o>[</span><span class=n>GC</span><span class=w> </span><span class=p>(</span><span class=n>Metadata</span><span class=w> </span><span class=n>GC</span><span class=w> </span><span class=n>Threshold</span><span class=p>)</span><span class=w> </span><span class=n>109499K</span><span class=o>-&gt;</span><span class=n>21465K</span><span class=p>(</span><span class=n>228352K</span><span class=p>),</span><span class=n>0</span><span class=p>.</span><span class=na>0184066</span><span class=w> </span><span class=n>secs</span><span class=o>]</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=o>[</span><span class=n>Full</span><span class=w> </span><span class=nf>GC</span><span class=w> </span><span class=p>(</span><span class=n>Metadata</span><span class=w> </span><span class=n>GC</span><span class=w> </span><span class=n>Threshold</span><span class=p>)</span><span class=w> </span><span class=n>21465K</span><span class=o>-&gt;</span><span class=n>16716K</span><span class=p>(</span><span class=n>201728K</span><span class=p>),</span><span class=n>0</span><span class=p>.</span><span class=na>0619261</span><span class=w> </span><span class=n>secs</span><span class=o>]</span><span class=w>
</span></span></span></code></pre></td></tr></table></div></div><p>参数解析</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-10-1><a class=lnlinks href=#hl-10-1>1</a>
</span><span class=lnt id=hl-10-2><a class=lnlinks href=#hl-10-2>2</a>
</span><span class=lnt id=hl-10-3><a class=lnlinks href=#hl-10-3>3</a>
</span><span class=lnt id=hl-10-4><a class=lnlinks href=#hl-10-4>4</a>
</span><span class=lnt id=hl-10-5><a class=lnlinks href=#hl-10-5>5</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=n>GC</span><span class=err>、</span><span class=n>Full</span><span class=w> </span><span class=n>GC</span><span class=err>：</span><span class=n>GC的类型</span><span class=err>，</span><span class=n>GC只在新生代上进行</span><span class=err>，</span><span class=n>Full</span><span class=w> </span><span class=n>GC包括永生代</span><span class=err>，</span><span class=n>新生代</span><span class=err>，</span><span class=n>老年代</span><span class=err>。</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=n>Allocation</span><span class=w> </span><span class=n>Failure</span><span class=err>：</span><span class=n>GC发生的原因</span><span class=err>。</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=n>80832K</span><span class=o>-&gt;</span><span class=n>19298K</span><span class=err>：</span><span class=n>堆在GC前的大小和GC后的大小</span><span class=err>。</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=n>228840k</span><span class=err>：</span><span class=n>现在的堆大小</span><span class=err>。</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=n>0</span><span class=p>.</span><span class=na>0084018</span><span class=w> </span><span class=n>secs</span><span class=err>：</span><span class=n>GC持续的时间</span><span class=err>。</span><span class=w>
</span></span></span></code></pre></td></tr></table></div></div><p>打开 GC 日志</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-11-1><a class=lnlinks href=#hl-11-1>1</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-shell data-lang=shell><span class=line><span class=cl>-verbose:gc -XX:+PrintGCDetails
</span></span></code></pre></td></tr></table></div></div><p>输入信息如下</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-12-1><a class=lnlinks href=#hl-12-1>1</a>
</span><span class=lnt id=hl-12-2><a class=lnlinks href=#hl-12-2>2</a>
</span><span class=lnt id=hl-12-3><a class=lnlinks href=#hl-12-3>3</a>
</span><span class=lnt id=hl-12-4><a class=lnlinks href=#hl-12-4>4</a>
</span><span class=lnt id=hl-12-5><a class=lnlinks href=#hl-12-5>5</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=o>[</span><span class=n>GC</span><span class=w> </span><span class=p>(</span><span class=n>Allocation</span><span class=w> </span><span class=n>Failure</span><span class=p>)</span><span class=w> </span><span class=o>[</span><span class=n>PSYoungGen</span><span class=p>:</span><span class=n>70640K</span><span class=o>-&gt;</span><span class=n>10116K</span><span class=p>(</span><span class=n>141312K</span><span class=p>)</span><span class=o>]</span><span class=w> </span><span class=n>80541K</span><span class=o>-&gt;</span><span class=n>20017K</span><span class=p>(</span><span class=n>227328K</span><span class=p>),</span><span class=n>0</span><span class=p>.</span><span class=na>0172573</span><span class=w> </span><span class=n>secs</span><span class=o>]</span><span class=w> </span><span class=o>[</span><span class=n>Times</span><span class=p>:</span><span class=n>user</span><span class=o>=</span><span class=n>0</span><span class=p>.</span><span class=na>03</span><span class=w> </span><span class=n>sys</span><span class=o>=</span><span class=n>0</span><span class=p>.</span><span class=na>00</span><span class=p>,</span><span class=n>real</span><span class=o>=</span><span class=n>0</span><span class=p>.</span><span class=na>02</span><span class=w> </span><span class=n>secs</span><span class=o>]</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=o>[</span><span class=n>GC</span><span class=w> </span><span class=p>(</span><span class=n>Metadata</span><span class=w> </span><span class=n>GC</span><span class=w> </span><span class=n>Threshold</span><span class=p>)</span><span class=w> </span><span class=o>[</span><span class=n>PSYoungGen</span><span class=p>:</span><span class=n>98859K</span><span class=o>-&gt;</span><span class=n>8154K</span><span class=p>(</span><span class=n>142336K</span><span class=p>)</span><span class=o>]</span><span class=w> </span><span class=n>108760K</span><span class=o>-&gt;</span><span class=n>21261K</span><span class=p>(</span><span class=n>228352K</span><span class=p>),</span><span class=n>0</span><span class=p>.</span><span class=na>0151573</span><span class=w> </span><span class=n>secs</span><span class=o>]</span><span class=w> </span><span class=o>[</span><span class=n>Times</span><span class=p>:</span><span class=n>user</span><span class=o>=</span><span class=n>0</span><span class=p>.</span><span class=na>00</span><span class=w> </span><span class=n>sys</span><span class=o>=</span><span class=n>0</span><span class=p>.</span><span class=na>01</span><span class=p>,</span><span class=n>real</span><span class=o>=</span><span class=n>0</span><span class=p>.</span><span class=na>02</span><span class=w> </span><span class=n>secs</span><span class=o>]</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=o>[</span><span class=n>Full</span><span class=w> </span><span class=nf>GC</span><span class=w> </span><span class=p>(</span><span class=n>Metadata</span><span class=w> </span><span class=n>GC</span><span class=w> </span><span class=n>Threshold</span><span class=p>)</span><span class=o>[</span><span class=n>PSYoungGen</span><span class=p>:</span><span class=n>8154K</span><span class=o>-&gt;</span><span class=n>0K</span><span class=p>(</span><span class=n>142336K</span><span class=p>)</span><span class=o>]</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=o>[</span><span class=n>ParOldGen</span><span class=p>:</span><span class=n>13107K</span><span class=o>-&gt;</span><span class=n>16809K</span><span class=p>(</span><span class=n>62464K</span><span class=p>)</span><span class=o>]</span><span class=w> </span><span class=n>21261K</span><span class=o>-&gt;</span><span class=n>16809K</span><span class=p>(</span><span class=n>204800K</span><span class=p>),</span><span class=o>[</span><span class=n>Metaspace</span><span class=p>:</span><span class=n>20599K</span><span class=o>-&gt;</span><span class=n>20599K</span><span class=p>(</span><span class=n>1067008K</span><span class=p>)</span><span class=o>]</span><span class=p>,</span><span class=n>0</span><span class=p>.</span><span class=na>0639732</span><span class=w> </span><span class=n>secs</span><span class=o>]</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=o>[</span><span class=n>Times</span><span class=p>:</span><span class=n>user</span><span class=o>=</span><span class=n>0</span><span class=p>.</span><span class=na>14</span><span class=w> </span><span class=n>sys</span><span class=o>=</span><span class=n>0</span><span class=p>.</span><span class=na>00</span><span class=p>,</span><span class=n>real</span><span class=o>=</span><span class=n>0</span><span class=p>.</span><span class=na>06</span><span class=w> </span><span class=n>secs</span><span class=o>]</span><span class=w>
</span></span></span></code></pre></td></tr></table></div></div><p>参数解析</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-13-1><a class=lnlinks href=#hl-13-1>1</a>
</span><span class=lnt id=hl-13-2><a class=lnlinks href=#hl-13-2>2</a>
</span><span class=lnt id=hl-13-3><a class=lnlinks href=#hl-13-3>3</a>
</span><span class=lnt id=hl-13-4><a class=lnlinks href=#hl-13-4>4</a>
</span><span class=lnt id=hl-13-5><a class=lnlinks href=#hl-13-5>5</a>
</span><span class=lnt id=hl-13-6><a class=lnlinks href=#hl-13-6>6</a>
</span><span class=lnt id=hl-13-7><a class=lnlinks href=#hl-13-7>7</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=n>GC</span><span class=err>，</span><span class=n>Full</span><span class=w> </span><span class=n>FC</span><span class=err>：</span><span class=n>同样是GC的类型</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=n>Allocation</span><span class=w> </span><span class=n>Failure</span><span class=err>：</span><span class=n>GC原因</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=n>PSYoungGen</span><span class=err>：</span><span class=n>使用了Parallel</span><span class=w> </span><span class=n>Scavenge并行垃圾收集器的新生代GC前后大小的变化</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=n>ParOldGen</span><span class=err>：</span><span class=n>使用了Parallel</span><span class=w> </span><span class=n>Old并行垃圾收集器的老年代GC前后大小的变化</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=n>Metaspace</span><span class=err>：</span><span class=w> </span><span class=n>元数据区GC前后大小的变化</span><span class=err>，</span><span class=n>JDK1</span><span class=p>.</span><span class=na>8中引入了元数据区以替代永久代</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=n>xxx</span><span class=w> </span><span class=n>secs</span><span class=err>：</span><span class=n>指GC花费的时间</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=n>Times</span><span class=err>：</span><span class=n>user</span><span class=err>：</span><span class=n>指的是垃圾收集器花费的所有CPU时间</span><span class=err>，</span><span class=n>sys</span><span class=err>：</span><span class=n>花费在等待系统调用或系统事件的时间</span><span class=err>，</span><span class=n>real</span><span class=err>：</span><span class=n>GC从开始到结束的时间</span><span class=err>，</span><span class=n>包括其他进程占用时间片的实际时间</span><span class=err>。</span><span class=w>
</span></span></span></code></pre></td></tr></table></div></div><p>打开 GC 日志</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-14-1><a class=lnlinks href=#hl-14-1>1</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-shell data-lang=shell><span class=line><span class=cl>-verbose:gc -XX:+PrintGCDetails -XX:+PrintGCTimestamps -XX:+PrintGCDatestamps
</span></span></code></pre></td></tr></table></div></div><p>输入信息如下</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-15-1><a class=lnlinks href=#hl-15-1>1</a>
</span><span class=lnt id=hl-15-2><a class=lnlinks href=#hl-15-2>2</a>
</span><span class=lnt id=hl-15-3><a class=lnlinks href=#hl-15-3>3</a>
</span><span class=lnt id=hl-15-4><a class=lnlinks href=#hl-15-4>4</a>
</span><span class=lnt id=hl-15-5><a class=lnlinks href=#hl-15-5>5</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=n>2019</span><span class=o>-</span><span class=n>09</span><span class=o>-</span><span class=n>24T22</span><span class=p>:</span><span class=n>15</span><span class=p>:</span><span class=n>24</span><span class=p>.</span><span class=na>518</span><span class=o>+</span><span class=n>0800</span><span class=p>:</span><span class=w> </span><span class=n>3</span><span class=p>.</span><span class=na>287</span><span class=p>:</span><span class=w> </span><span class=o>[</span><span class=n>GC</span><span class=w> </span><span class=p>(</span><span class=n>Allocation</span><span class=w> </span><span class=n>Failure</span><span class=p>)</span><span class=w> </span><span class=o>[</span><span class=n>PSYoungGen</span><span class=p>:</span><span class=n>136162K</span><span class=o>-&gt;</span><span class=n>5113K</span><span class=p>(</span><span class=n>136192K</span><span class=p>)</span><span class=o>]</span><span class=w> </span><span class=n>141425K</span><span class=o>-&gt;</span><span class=n>17632K</span><span class=p>(</span><span class=n>222208K</span><span class=p>),</span><span class=n>0</span><span class=p>.</span><span class=na>0248249</span><span class=w> </span><span class=n>secs</span><span class=o>]</span><span class=w> </span><span class=o>[</span><span class=n>Times</span><span class=p>:</span><span class=n>user</span><span class=o>=</span><span class=n>0</span><span class=p>.</span><span class=na>05</span><span class=w> </span><span class=n>sys</span><span class=o>=</span><span class=n>0</span><span class=p>.</span><span class=na>00</span><span class=p>,</span><span class=n>real</span><span class=o>=</span><span class=n>0</span><span class=p>.</span><span class=na>03</span><span class=w> </span><span class=n>secs</span><span class=o>]</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=n>2019</span><span class=o>-</span><span class=n>09</span><span class=o>-</span><span class=n>24T22</span><span class=p>:</span><span class=n>15</span><span class=p>:</span><span class=n>25</span><span class=p>.</span><span class=na>559</span><span class=o>+</span><span class=n>0800</span><span class=p>:</span><span class=w> </span><span class=n>4</span><span class=p>.</span><span class=na>329</span><span class=p>:</span><span class=w> </span><span class=o>[</span><span class=n>GC</span><span class=w> </span><span class=p>(</span><span class=n>Metadata</span><span class=w> </span><span class=n>GC</span><span class=w> </span><span class=n>Threshold</span><span class=p>)</span><span class=w> </span><span class=o>[</span><span class=n>PSYoungGen</span><span class=p>:</span><span class=n>97578K</span><span class=o>-&gt;</span><span class=n>10068K</span><span class=p>(</span><span class=n>274944K</span><span class=p>)</span><span class=o>]</span><span class=w> </span><span class=n>110096K</span><span class=o>-&gt;</span><span class=n>22658K</span><span class=p>(</span><span class=n>360960K</span><span class=p>),</span><span class=n>0</span><span class=p>.</span><span class=na>0094071</span><span class=w> </span><span class=n>secs</span><span class=o>]</span><span class=w> </span><span class=o>[</span><span class=n>Times</span><span class=p>:</span><span class=w> </span><span class=n>user</span><span class=o>=</span><span class=n>0</span><span class=p>.</span><span class=na>00</span><span class=w> </span><span class=n>sys</span><span class=o>=</span><span class=n>0</span><span class=p>.</span><span class=na>00</span><span class=p>,</span><span class=n>real</span><span class=o>=</span><span class=n>0</span><span class=p>.</span><span class=na>01</span><span class=w> </span><span class=n>secs</span><span class=o>]</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=n>2019</span><span class=o>-</span><span class=n>09</span><span class=o>-</span><span class=n>24T22</span><span class=p>:</span><span class=n>15</span><span class=p>:</span><span class=n>25</span><span class=p>.</span><span class=na>569</span><span class=o>+</span><span class=n>0800</span><span class=p>:</span><span class=w> </span><span class=n>4</span><span class=p>.</span><span class=na>338</span><span class=p>:</span><span class=w> </span><span class=o>[</span><span class=n>Full</span><span class=w> </span><span class=nf>GC</span><span class=w> </span><span class=p>(</span><span class=n>Metadata</span><span class=w> </span><span class=n>GC</span><span class=w> </span><span class=n>Threshold</span><span class=p>)</span><span class=w> </span><span class=o>[</span><span class=n>PSYoungGen</span><span class=p>:</span><span class=n>10068K</span><span class=o>-&gt;</span><span class=n>0K</span><span class=p>(</span><span class=n>274944K</span><span class=p>)</span><span class=o>][</span><span class=n>ParoldGen</span><span class=p>:</span><span class=n>12590K</span><span class=o>-&gt;</span><span class=n>13564K</span><span class=p>(</span><span class=n>56320K</span><span class=p>)</span><span class=o>]</span><span class=w> </span><span class=n>22658K</span><span class=o>-&gt;</span><span class=n>13564K</span><span class=p>(</span><span class=n>331264K</span><span class=p>),</span><span class=o>[</span><span class=n>Metaspace</span><span class=p>:</span><span class=n>20590K</span><span class=o>-&gt;</span><span class=n>20590K</span><span class=p>(</span><span class=n>1067008K</span><span class=p>)</span><span class=o>]</span><span class=p>,</span><span class=n>0</span><span class=p>.</span><span class=na>0494875</span><span class=w> </span><span class=n>secs</span><span class=o>]</span><span class=w> </span><span class=o>[</span><span class=n>Times</span><span class=p>:</span><span class=w> </span><span class=n>user</span><span class=o>=</span><span class=n>0</span><span class=p>.</span><span class=na>17</span><span class=w> </span><span class=n>sys</span><span class=o>=</span><span class=n>0</span><span class=p>.</span><span class=na>02</span><span class=p>,</span><span class=n>real</span><span class=o>=</span><span class=n>0</span><span class=p>.</span><span class=na>05</span><span class=w> </span><span class=n>secs</span><span class=o>]</span><span class=w>
</span></span></span></code></pre></td></tr></table></div></div><p>说明：带上了日期和实践</p><p>如果想把 GC 日志存到文件的话，是下面的参数：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-16-1><a class=lnlinks href=#hl-16-1>1</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-shell data-lang=shell><span class=line><span class=cl>-Xloggc:/path/to/gc.log
</span></span></code></pre></td></tr></table></div></div><p><strong>日志补充说明</strong></p><ul><li><p>&ldquo;<code>[GC</code>&ldquo;和&rdquo;<code>[Full GC</code>&ldquo;说明了这次垃圾收集的停顿类型，如果有"Full"则说明 GC 发生了"Stop The World&rdquo;</p></li><li><p>使用 Serial 收集器在新生代的名字是 Default New Generation，因此显示的是&rdquo;<code>[DefNew</code>&rdquo;</p></li><li><p>使用 ParNew 收集器在新生代的名字会变成&rdquo;<code>[ParNew</code>"，意思是"Parallel New Generation"</p></li><li><p>使用 Parallel scavenge 收集器在新生代的名字是”<code>[PSYoungGen</code>"</p></li><li><p>老年代的收集和新生代道理一样，名字也是收集器决定的</p></li><li><p>使用 G1 收集器的话，会显示为"garbage-first heap"</p></li><li><p><mark>Allocation Failure</mark></p><p>表明本次引起 GC 的原因是因为在年轻代中没有足够的空间能够存储新的数据了。</p></li><li><p><mark>[PSYoungGen：5986K->696K(8704K) ] 5986K->704K(9216K)</mark></p><p>中括号内：GC 回收前年轻代大小，回收后大小，（年轻代总大小）</p><p>括号外：GC 回收前年轻代和老年代大小，回收后大小，（年轻代和老年代总大小）</p></li><li><p><mark>user 代表用户态回收耗时，sys 内核态回收耗时，rea 实际耗时</mark>。由于多核的原因，时间总和可能会超过 real 时间</p></li></ul><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-17-1><a class=lnlinks href=#hl-17-1> 1</a>
</span><span class=lnt id=hl-17-2><a class=lnlinks href=#hl-17-2> 2</a>
</span><span class=lnt id=hl-17-3><a class=lnlinks href=#hl-17-3> 3</a>
</span><span class=lnt id=hl-17-4><a class=lnlinks href=#hl-17-4> 4</a>
</span><span class=lnt id=hl-17-5><a class=lnlinks href=#hl-17-5> 5</a>
</span><span class=lnt id=hl-17-6><a class=lnlinks href=#hl-17-6> 6</a>
</span><span class=lnt id=hl-17-7><a class=lnlinks href=#hl-17-7> 7</a>
</span><span class=lnt id=hl-17-8><a class=lnlinks href=#hl-17-8> 8</a>
</span><span class=lnt id=hl-17-9><a class=lnlinks href=#hl-17-9> 9</a>
</span><span class=lnt id=hl-17-10><a class=lnlinks href=#hl-17-10>10</a>
</span><span class=lnt id=hl-17-11><a class=lnlinks href=#hl-17-11>11</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=n>Heap</span><span class=err>（</span><span class=n>堆</span><span class=err>）</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=n>PSYoungGen</span><span class=err>（</span><span class=n>Parallel</span><span class=w> </span><span class=n>Scavenge收集器新生代</span><span class=err>）</span><span class=n>total</span><span class=w> </span><span class=n>9216K</span><span class=err>，</span><span class=n>used</span><span class=w> </span><span class=n>6234K</span><span class=w> </span><span class=o>[</span><span class=n>0x00000000ff600000</span><span class=p>,</span><span class=n>0x0000000100000000</span><span class=p>,</span><span class=n>0x0000000100000000</span><span class=p>)</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=n>eden</span><span class=w> </span><span class=n>space</span><span class=err>（</span><span class=n>堆中的Eden区默认占比是8</span><span class=err>）</span><span class=n>8192K</span><span class=err>，</span><span class=n>768</span><span class=w> </span><span class=n>used</span><span class=w> </span><span class=o>[</span><span class=n>0x00000000ff600000</span><span class=p>,</span><span class=n>0x00000000ffc16b08</span><span class=p>,</span><span class=n>0x00000000ffe00000</span><span class=p>)</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=n>from</span><span class=w> </span><span class=n>space</span><span class=err>（</span><span class=n>堆中的Survivor</span><span class=err>，</span><span class=n>这里是From</span><span class=w> </span><span class=n>Survivor区默认占比是1</span><span class=err>）</span><span class=n>1024K</span><span class=err>，</span><span class=w> </span><span class=n>0</span><span class=o>%</span><span class=w> </span><span class=n>used</span><span class=w> </span><span class=o>[</span><span class=n>0x00000000fff00000</span><span class=p>,</span><span class=n>0x00000000fff00000</span><span class=p>,</span><span class=n>0x0000000100000000</span><span class=p>)</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=n>to</span><span class=w> </span><span class=n>space</span><span class=err>（</span><span class=n>堆中的Survivor</span><span class=err>，</span><span class=n>这里是to</span><span class=w> </span><span class=n>Survivor区默认占比是1</span><span class=err>，</span><span class=n>需要先了解一下堆的分配策略</span><span class=err>）</span><span class=n>1024K</span><span class=p>,</span><span class=w> </span><span class=n>0</span><span class=o>%</span><span class=w> </span><span class=n>used</span><span class=w> </span><span class=o>[</span><span class=n>0x00000000ffe00000</span><span class=p>,</span><span class=n>0x00000000ffe00000</span><span class=p>,</span><span class=n>0x00000000fff00000</span><span class=p>)</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=n>ParOldGen</span><span class=err>（</span><span class=n>老年代总大小和使用大小</span><span class=err>）</span><span class=n>total</span><span class=w> </span><span class=n>10240K</span><span class=err>，</span><span class=w> </span><span class=n>used</span><span class=w> </span><span class=n>7001K</span><span class=w> </span><span class=err>［</span><span class=n>0x00000000fec00000</span><span class=p>,</span><span class=n>0x00000000ff600000</span><span class=p>,</span><span class=n>0x00000000ff600000</span><span class=p>)</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=n>object</span><span class=w> </span><span class=n>space</span><span class=err>（</span><span class=n>显示个使用百分比</span><span class=err>）</span><span class=n>10240K</span><span class=err>，</span><span class=n>688</span><span class=w> </span><span class=n>used</span><span class=w> </span><span class=o>[</span><span class=n>0x00000000fec00000</span><span class=p>,</span><span class=n>0x00000000ff2d6630</span><span class=p>,</span><span class=n>0x00000000ff600000</span><span class=p>)</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=n>PSPermGen</span><span class=err>（</span><span class=n>永久代总大小和使用大小</span><span class=err>）</span><span class=n>total</span><span class=w> </span><span class=n>21504K</span><span class=err>，</span><span class=w> </span><span class=n>used</span><span class=w> </span><span class=n>4949K</span><span class=w> </span><span class=o>[</span><span class=n>0x00000000f9a00000</span><span class=p>,</span><span class=n>0x00000000faf00000</span><span class=p>,</span><span class=n>0x00000000fec00000</span><span class=p>)</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=n>object</span><span class=w> </span><span class=n>space</span><span class=err>（</span><span class=n>显示个使用百分比</span><span class=err>，</span><span class=n>自己能算出来</span><span class=err>）</span><span class=n>21504K</span><span class=err>，</span><span class=w> </span><span class=n>238</span><span class=w> </span><span class=n>used</span><span class=w> </span><span class=o>[</span><span class=n>0x00000000f9a00000</span><span class=p>,</span><span class=n>0x00000000f9ed55e0</span><span class=p>,</span><span class=n>0x00000000faf00000</span><span class=p>)</span><span class=w>
</span></span></span></code></pre></td></tr></table></div></div><h3 id=minor-gc-日志><a href=#minor-gc-%e6%97%a5%e5%bf%97 class=header-anchor>#</a>
Minor GC 日志</h3><p><img src=https://logan.1357810.xyz/img/20220422/153020741-2cdef56df9.png width=900 height=600 loading=lazy decoding=async alt=image-20200714082555688 class="gallery-image link-image" data-flex-grow=20 data-flex-basis=20px></p><h3 id=full-gc-日志><a href=#full-gc-%e6%97%a5%e5%bf%97 class=header-anchor>#</a>
Full GC 日志</h3><p><img src=https://logan.1357810.xyz/img/20220422/153020742-f1c4895d7c.png width=900 height=600 loading=lazy decoding=async alt=image-20210512194815354 class="gallery-image link-image" data-flex-grow=20 data-flex-basis=20px></p><p><strong>举例</strong></p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-18-1><a class=lnlinks href=#hl-18-1> 1</a>
</span><span class=lnt id=hl-18-2><a class=lnlinks href=#hl-18-2> 2</a>
</span><span class=lnt id=hl-18-3><a class=lnlinks href=#hl-18-3> 3</a>
</span><span class=lnt id=hl-18-4><a class=lnlinks href=#hl-18-4> 4</a>
</span><span class=lnt id=hl-18-5><a class=lnlinks href=#hl-18-5> 5</a>
</span><span class=lnt id=hl-18-6><a class=lnlinks href=#hl-18-6> 6</a>
</span><span class=lnt id=hl-18-7><a class=lnlinks href=#hl-18-7> 7</a>
</span><span class=lnt id=hl-18-8><a class=lnlinks href=#hl-18-8> 8</a>
</span><span class=lnt id=hl-18-9><a class=lnlinks href=#hl-18-9> 9</a>
</span><span class=lnt id=hl-18-10><a class=lnlinks href=#hl-18-10>10</a>
</span><span class=lnt id=hl-18-11><a class=lnlinks href=#hl-18-11>11</a>
</span><span class=lnt id=hl-18-12><a class=lnlinks href=#hl-18-12>12</a>
</span><span class=lnt id=hl-18-13><a class=lnlinks href=#hl-18-13>13</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=kd>private</span><span class=w> </span><span class=kd>static</span><span class=w> </span><span class=kd>final</span><span class=w> </span><span class=kt>int</span><span class=w> </span><span class=n>_1MB</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>1024</span><span class=w> </span><span class=o>*</span><span class=w> </span><span class=n>1024</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=kd>public</span><span class=w> </span><span class=kd>static</span><span class=w> </span><span class=kt>void</span><span class=w> </span><span class=nf>testAllocation</span><span class=p>()</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=kt>byte</span><span class=o>[]</span><span class=w> </span><span class=n>allocation1</span><span class=p>,</span><span class=w> </span><span class=n>allocation2</span><span class=p>,</span><span class=w> </span><span class=n>allocation3</span><span class=p>,</span><span class=w> </span><span class=n>allocation4</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=n>allocation1</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=k>new</span><span class=w> </span><span class=kt>byte</span><span class=o>[</span><span class=n>2</span><span class=w> </span><span class=o>*</span><span class=w> </span><span class=n>_1MB</span><span class=o>]</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=n>allocation2</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=k>new</span><span class=w> </span><span class=kt>byte</span><span class=o>[</span><span class=n>2</span><span class=w> </span><span class=o>*</span><span class=w> </span><span class=n>_1MB</span><span class=o>]</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=n>allocation3</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=k>new</span><span class=w> </span><span class=kt>byte</span><span class=o>[</span><span class=n>2</span><span class=w> </span><span class=o>*</span><span class=w> </span><span class=n>_1MB</span><span class=o>]</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=n>allocation4</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=k>new</span><span class=w> </span><span class=kt>byte</span><span class=o>[</span><span class=n>4</span><span class=w> </span><span class=o>*</span><span class=w> </span><span class=n>_1MB</span><span class=o>]</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=kd>public</span><span class=w> </span><span class=kd>static</span><span class=w> </span><span class=kt>void</span><span class=w> </span><span class=nf>main</span><span class=p>(</span><span class=n>String</span><span class=o>[]</span><span class=w> </span><span class=n>args</span><span class=p>)</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=n>testAllocation</span><span class=p>();</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>}</span><span class=w>
</span></span></span></code></pre></td></tr></table></div></div><p>设置 JVM 参数</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-19-1><a class=lnlinks href=#hl-19-1>1</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-shell data-lang=shell><span class=line><span class=cl>-Xms20m -Xmx20m -Xmn10m -XX:SurvivorRatio<span class=o>=</span><span class=m>8</span> -XX:+PrintGCDetails -XX:+UseParallelGC
</span></span></code></pre></td></tr></table></div></div><p><strong>图示</strong></p><p><img src=https://logan.1357810.xyz/img/20220422/153020742-d1c5f2aa8d.png width=900 height=600 loading=lazy decoding=async alt=image-20200714083332238 class="gallery-image link-image" data-flex-grow=20 data-flex-basis=20px></p><p><img src=https://logan.1357810.xyz/img/20220422/153020742-5e93a8c008.png width=900 height=600 loading=lazy decoding=async alt=image-20200714083526790 class="gallery-image link-image" data-flex-grow=20 data-flex-basis=20px></p><ul><li><p>上图是JDK1.7情况：Eden区已经有三个2M对象，这时新创建的4M对象无法放入Eden，触发minorGC。因为from和to区都是1M的空间，Eden中的每个2M对象都放不进Survivor区，所以会放入老年代</p></li><li><p>JDK1.8情况：Eden区已经有三个2M对象，这时新创建的4M对象无法放入Eden，这时会判断新增的对象是否大于Eden区总空间的二分之一，然后直接把4M对象放入老年代</p></li></ul><p>可以用一些工具去分析这些 GC 日志</p><ul><li><p>将GC日志保存到文件：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-20-1><a class=lnlinks href=#hl-20-1>1</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-sh data-lang=sh><span class=line><span class=cl>-Xloggc:/path/to/gc.log
</span></span></code></pre></td></tr></table></div></div></li><li><p>常用的日志分析工具有：GCViewer、GCEasy、GCHisto、GCLogViewer、Hpjmeter、garbagecat 等</p></li></ul><h2 id=13x-垃圾回收器的新发展><a href=#13x-%e5%9e%83%e5%9c%be%e5%9b%9e%e6%94%b6%e5%99%a8%e7%9a%84%e6%96%b0%e5%8f%91%e5%b1%95 class=header-anchor>#</a>
13.X. 垃圾回收器的新发展</h2><p>GC 仍然处于飞速发展之中，目前的默认选项<mark>G1 GC 在不断的进行改进</mark>，很多我们原来认为的缺点，例如串行的 Fu11GC、Card Table 扫描的低效等，都已经被大幅改进，例如，JDK10 以后，Fu11GC 已经是并行运行，在很多场景下，其表现还略优于 ParallelGC 的并行 Ful1GC 实现。</p><p>即使是 Serial GC，虽然比较古老，但是简单的设计和实现未必就是过时的，它本身的开销，不管是 GC 相关数据结构的开销，还是线程的开销，都是非常小的，所以随着云计算的兴起，<mark>在 Serverless 等新的应用场景下，Serial GC 找到了新的舞台</mark>。</p><p>比较不幸的是 CMSGC，因为其算法的理论缺陷等原因，虽然现在还有非常大的用户群体，但在 JDK9 中已经被标记为废弃，并在 JDK14 版本中移除</p><h3 id=13x1-jdk11-新特性><a href=#13x1-jdk11-%e6%96%b0%e7%89%b9%e6%80%a7 class=header-anchor>#</a>
13.X.1. JDK11 新特性</h3><p>Epsilon:A No-Op GarbageCollector（Epsilon 垃圾回收器，&ldquo;No-Op（无操作）&ldquo;回收器）<a class=link href=http://openidk.iava.net/jeps/318 target=_blank rel=noopener>http://openidk.iava.net/jeps/318
<span style=white-space:nowrap><svg width=".7em" height=".7em" viewBox="0 0 21 21" xmlns="http://www.w3.org/2000/svg"><path d="m13 3 3.293 3.293-7 7 1.414 1.414 7-7L21 11V3z" fill="currentcolor"/><path d="M19 19H5V5h7l-2-2H5c-1.103.0-2 .897-2 2v14c0 1.103.897 2 2 2h14c1.103.0 2-.897 2-2v-5l-2-2v7z" fill="currentcolor"/></span></a></p><p>ZGC:A Scalable Low-Latency Garbage Collector（Experimental）（ZGC：可伸缩的低延迟垃圾回收器，处于实验性阶段）<a class=link href=http://openidk.iava.net/jeps/318 target=_blank rel=noopener>http://openidk.iava.net/jeps/333
<span style=white-space:nowrap><svg width=".7em" height=".7em" viewBox="0 0 21 21" xmlns="http://www.w3.org/2000/svg"><path d="m13 3 3.293 3.293-7 7 1.414 1.414 7-7L21 11V3z" fill="currentcolor"/><path d="M19 19H5V5h7l-2-2H5c-1.103.0-2 .897-2 2v14c0 1.103.897 2 2 2h14c1.103.0 2-.897 2-2v-5l-2-2v7z" fill="currentcolor"/></span></a></p><p><img src=https://logan.1357810.xyz/img/20220422/153020742-79d7199de5.png width=900 height=600 loading=lazy decoding=async alt=image-20210512195426194 class="gallery-image link-image" data-flex-grow=20 data-flex-basis=20px></p><p>现在 G1 回收器已成为默认回收器好几年了。</p><p>我们还看到了引入了两个新的收集器：ZGC（JDK11 出现）和 Shenandoah（Open JDK12）。主打特点：低停顿时间</p><p><img src=https://logan.1357810.xyz/img/20220422/153020742-112ef0e6e6.png width=900 height=600 loading=lazy decoding=async alt=image-20210512195528695 class="gallery-image link-image" data-flex-grow=20 data-flex-basis=20px></p><h3 id=13x2-open-jdk12-的-shenandoash-gc><a href=#13x2-open-jdk12-%e7%9a%84-shenandoash-gc class=header-anchor>#</a>
13.X.2. Open JDK12 的 Shenandoash GC</h3><p><mark>Open JDK12 的 Shenandoash GC：低停顿时间的 GC（实验性）</mark></p><p><mark>Shenandoah，无疑是众多 GC 中最孤独的一个。</mark>是第一款不由 oracle 公司团队领导开发的 Hotspot 垃圾收集器。不可避免的<mark>受到官方的排挤</mark>。比如号称 OpenJDK 和 OracleJDK 没有区别的 Oracle 公司仍拒绝在 OracleJDK12 中支持 Shenandoah。</p><p>Shenandoah 垃圾回收器最初由 RedHat 进行的一项垃圾收集器研究项目 Pauseless GC 的实现，<mark>旨在针对 JVM 上的内存回收实现低停顿的需求</mark>.。在 2014 年贡献给 OpenJDK。</p><p>Red Hat 研发 Shenandoah 团队对外宣称，<mark>Shenandoah 垃圾回收器的暂停时间与堆大小无关，这意味着无论将堆设置为 200MB 还是 200GB，99.9%的目标都可以把垃圾收集的停顿时间限制在十毫秒以内。</mark>不过实际使用性能将取决于实际工作堆的大小和工作负载。</p><p><img src=https://logan.1357810.xyz/img/20220422/153020742-e100f81c37.png width=900 height=600 loading=lazy decoding=async alt=image-20200714090608807 class="gallery-image link-image" data-flex-grow=20 data-flex-basis=20px></p><p>这是 RedHat 在 2016 年发表的论文数据，测试内容是使用 Es 对 200GB 的维基百科数据进行索引。从结果看：</p><ul><li>停顿时间比其他几款收集器确实有了质的飞跃，但也未实现最大停顿时间控制在十毫秒以内的目标。</li><li>而吞吐量方面出现了明显的下降，总运行时间是所有测试收集器里最长的。</li></ul><p>总结</p><ul><li>Shenandoah GC 的弱项：高运行负担下的吞吐量下降。</li><li>Shenandoah GC 的强项：低延迟时间。</li><li>Shenandoah GC 的工作过程大致分为九个阶段，这里就不再赘述。在之前 Java12 新特性视频里有过介绍。</li></ul><p>【Java12 新特性地址】</p><p><a class=link href="http://www.atguigu.com/download_detail.shtml?v=222" target=_blank rel=noopener>http://www.atguigu.com/download_detail.shtml?v=222
<span style=white-space:nowrap><svg width=".7em" height=".7em" viewBox="0 0 21 21" xmlns="http://www.w3.org/2000/svg"><path d="m13 3 3.293 3.293-7 7 1.414 1.414 7-7L21 11V3z" fill="currentcolor"/><path d="M19 19H5V5h7l-2-2H5c-1.103.0-2 .897-2 2v14c0 1.103.897 2 2 2h14c1.103.0 2-.897 2-2v-5l-2-2v7z" fill="currentcolor"/></span></a></p><p>或</p><p><a class=link href="https://www.bilibili.com/video/BV1jJ411M7kQ?from=search&amp;seid=12339069673726242866" target=_blank rel=noopener>https://www.bilibili.com/video/BV1jJ411M7kQ?from=search&amp;seid=12339069673726242866
<span style=white-space:nowrap><svg width=".7em" height=".7em" viewBox="0 0 21 21" xmlns="http://www.w3.org/2000/svg"><path d="m13 3 3.293 3.293-7 7 1.414 1.414 7-7L21 11V3z" fill="currentcolor"/><path d="M19 19H5V5h7l-2-2H5c-1.103.0-2 .897-2 2v14c0 1.103.897 2 2 2h14c1.103.0 2-.897 2-2v-5l-2-2v7z" fill="currentcolor"/></span></a></p><h3 id=13x3-令人震惊革命性的-zgc><a href=#13x3-%e4%bb%a4%e4%ba%ba%e9%9c%87%e6%83%8a%e9%9d%a9%e5%91%bd%e6%80%a7%e7%9a%84-zgc class=header-anchor>#</a>
13.X.3. 令人震惊、革命性的 ZGC</h3><p>官方地址：<a class=link href=https://docs.oracle.com/en/java/javase/12/gctuning/ target=_blank rel=noopener>https://docs.oracle.com/en/java/javase/12/gctuning/
<span style=white-space:nowrap><svg width=".7em" height=".7em" viewBox="0 0 21 21" xmlns="http://www.w3.org/2000/svg"><path d="m13 3 3.293 3.293-7 7 1.414 1.414 7-7L21 11V3z" fill="currentcolor"/><path d="M19 19H5V5h7l-2-2H5c-1.103.0-2 .897-2 2v14c0 1.103.897 2 2 2h14c1.103.0 2-.897 2-2v-5l-2-2v7z" fill="currentcolor"/></span></a></p><p><img src=https://logan.1357810.xyz/img/20220422/153020742-cf93e0a2ff.png width=900 height=600 loading=lazy decoding=async alt=image-20210512200236647 class="gallery-image link-image" data-flex-grow=20 data-flex-basis=20px></p><p>ZGC 与 Shenandoah 目标高度相似，<mark>在尽可能对吞吐量影响不大的前提下，实现在任意堆内存大小下都可以把垃圾收集的停颇时间限制在十毫秒以内的低延迟。</mark></p><p>《深入理解 Java 虚拟机》一书中这样定义 ZGC：ZGC 收集器是一款基于 Region 内存布局的，（暂时）不设分代的，使用了读屏障、染色指针和内存多重映射等技术来实现<mark>可并发的标记-压缩算法</mark>的，以<mark>低延迟为首要目标</mark>的一款垃圾收集器。</p><p>ZGC 的工作过程可以分为 4 个阶段：<mark>并发标记 - 并发预备重分配 - 并发重分配 - 并发重映射</mark> 等。</p><p>ZGC 几乎在所有地方并发执行的，除了初始标记的是 STw 的。所以停顿时间几乎就耗费在初始标记上，这部分的实际时间是非常少的。</p><p>测试数据：</p><p><img src=https://logan.1357810.xyz/img/20220422/153020742-e12dc992ac.png width=900 height=600 loading=lazy decoding=async alt=image-20200714091201073 class="gallery-image link-image" data-flex-grow=20 data-flex-basis=20px></p><p><img src=https://logan.1357810.xyz/img/20220422/153020742-e53c20feca.png width=900 height=600 loading=lazy decoding=async alt=image-20200714091401511 class="gallery-image link-image" data-flex-grow=20 data-flex-basis=20px></p><p>在 ZGC 的强项停顿时间测试上，它毫不留情的将 Parallel、G1 拉开了两个数量级的差距。无论平均停顿、95％停顿、99％停顿、99.9％停顿，还是最大停顿时间，ZGC 都能毫不费劲控制在 10 毫秒以内。</p><p>虽然 ZGC 还在试验状态，没有完成所有特性，但此时性能已经相当亮眼，用“令人震惊、革命性”来形容，不为过。 <mark>未来将在服务端、大内存、低延迟应用的首选垃圾收集器。</mark></p><p><img src=https://logan.1357810.xyz/img/20220422/153020742-00dd18d6cf.png width=900 height=600 loading=lazy decoding=async alt=image-20200714093243028 class="gallery-image link-image" data-flex-grow=20 data-flex-basis=20px></p><p><mark>JEP 364：ZGC 应用在 macos 上</mark></p><p><mark>JEP 365：ZGC 应用在 Windows 上</mark></p><p>JDK14 之前，ZGC 仅 Linux 才支持。</p><p>尽管许多使用 zGc 的用户都使用类 Linux 的环境，但在 Windows 和 macos 上，人们也需要 ZGC 进行开发部署和测试。许多桌面应用也可以从 ZGC 中受益。因此，ZGC 特性被移植到了 Windows 和 macos 上。</p><p>现在 mac 或 Windows 上也能使用 zGC 了，示例如下：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-21-1><a class=lnlinks href=#hl-21-1>1</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-shell data-lang=shell><span class=line><span class=cl>-XX:+UnlockExperimentalVMOptions -XX:+UseZGC
</span></span></code></pre></td></tr></table></div></div><ul><li>颜色指针</li><li>有浮动垃圾</li><li>不能指针压缩</li><li>使用读屏障</li></ul><p><img src=https://logan.1357810.xyz/img/20220426/1650958056-27a9c5dfbdb846.png width=900 height=600 loading=lazy decoding=async alt=image-20220426152736171 class="gallery-image link-image" data-flex-grow=20 data-flex-basis=20px></p><p><img src=https://logan.1357810.xyz/img/20220426/1650958115-efc12b79d1e299.png width=900 height=600 loading=lazy decoding=async alt=image-20220426152835012 class="gallery-image link-image" data-flex-grow=20 data-flex-basis=20px></p><p>Marked1和Marked0标示颜色</p><p><img src=https://logan.1357810.xyz/img/20220426/1650958184-51295957d0a3f4.png width=900 height=600 loading=lazy decoding=async alt=image-20220426152944578 class="gallery-image link-image" data-flex-grow=20 data-flex-basis=20px></p><h3 id=13x4-其他垃圾回收器aligc><a href=#13x4-%e5%85%b6%e4%bb%96%e5%9e%83%e5%9c%be%e5%9b%9e%e6%94%b6%e5%99%a8aligc class=header-anchor>#</a>
13.X.4. 其他垃圾回收器：AliGC</h3><p>AliGC 是阿里巴巴 JVM 团队基于 G1 算法，面向大堆（LargeHeap）应用场景。指定场景下的对比：</p><p><img src=https://logan.1357810.xyz/img/20220422/153020742-388379915d.png width=900 height=600 loading=lazy decoding=async alt=image-20200714093604012 class="gallery-image link-image" data-flex-grow=20 data-flex-basis=20px></p><p>当然，其它厂商也提供了各种别具一格的 GC 实现，例如比较有名的低延迟 GC：Zing，有兴趣可以参考提供的链接 <a class=link href=https://www.infoq.com/articles/azul_gc_in_detail target=_blank rel=noopener>https://www.infoq.com/articles/azul_gc_in_detail
<span style=white-space:nowrap><svg width=".7em" height=".7em" viewBox="0 0 21 21" xmlns="http://www.w3.org/2000/svg"><path d="m13 3 3.293 3.293-7 7 1.414 1.414 7-7L21 11V3z" fill="currentcolor"/><path d="M19 19H5V5h7l-2-2H5c-1.103.0-2 .897-2 2v14c0 1.103.897 2 2 2h14c1.103.0 2-.897 2-2v-5l-2-2v7z" fill="currentcolor"/></span></a></p></section><footer class=article-footer><section class=article-tags><a href=/tags/jvm/>JVM</a></section><section class=article-copyright><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-copyright" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><circle cx="12" cy="12" r="9"/><path d="M14.5 9a3.5 4 0 100 6"/></svg>
<span>Licensed under CC BY-NC-SA 4.0</span></section><section class=article-lastmod><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-clock" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><circle cx="12" cy="12" r="9"/><polyline points="12 7 12 12 15 15"/></svg>
<span>最后更新于 2024年5月8日 21:39</span></section></footer></article><aside class=related-content--wrapper><h2 class=section-title>相关文章</h2><div class=related-content><div class="flex article-list--tile"><article><a href=/p/2023/05/11895611/><div class=article-details><h2 class=article-title>01-概述篇</h2></div></a></article><article><a href=/p/2023/05/14915117/><div class=article-details><h2 class=article-title>02-JVM监控及诊断工具-命令行篇</h2></div></a></article><article><a href=/p/2023/05/49167k49/><div class=article-details><h2 class=article-title>03-JVM监控及诊断工具-GUI篇</h2></div></a></article><article><a href=/p/2023/05/84511h84/><div class=article-details><h2 class=article-title>03-运行时数据区及程序计数器</h2></div></a></article><article><a href=/p/2023/05/45117945/><div class=article-details><h2 class=article-title>04-JVM运行时参数</h2></div></a></article></div></div></aside><link rel=preload as=style onload='this.rel="stylesheet"' href=https://cdn.bootcdn.net/ajax/libs/waline/2.15.8/waline.min.css crossorigin=anonymous><script src=https://cdn.bootcdn.net/ajax/libs/waline/2.15.8/waline.min.js crossorigin=anonymous></script><div id=waline class=waline-container></div><style>.waline-container{background-color:var(--card-background);border-radius:var(--card-border-radius);box-shadow:var(--shadow-l1);padding:var(--card-padding);--waline-font-size:var(--article-font-size)}.waline-container .wl-count{color:var(--card-text-color-main)}</style><script>Waline.init({copyright:!1,dark:'html[data-scheme="dark"]',el:"#waline",emoji:["https://unpkg.com/@waline/emojis@1.2.0/weibo"],lang:"zh-cn",locale:{admin:"Admin",placeholder:null},requiredMeta:["nick"],serverURL:"https://waline.wssw.fun/",turnstileKey:"0x4AAAAAAAZ2cXI-LS3tIUAh",wordLimit:100})</script><footer class=site-footer><section class=copyright>&copy;
2020 -
2024 &nbsp;&nbsp;by &nbsp; logan</section><section class=powerby>发表了88篇文章 ·
总计566.00k字</section><section class=powerby><div class=powerby><span id=busuanzi_container_site_pv>本站总访问量<span id=busuanzi_value_site_pv></span>次
</span><span id=busuanzi_container_site_uv>本站访客数<span id=busuanzi_value_site_uv></span>人次</span></div></section></footer><div class=pswp tabindex=-1 role=dialog aria-hidden=true><div class=pswp__bg></div><div class=pswp__scroll-wrap><div class=pswp__container><div class=pswp__item></div><div class=pswp__item></div><div class=pswp__item></div></div><div class="pswp__ui pswp__ui--hidden"><div class=pswp__top-bar><div class=pswp__counter></div><button class="pswp__button pswp__button--close" title="Close (Esc)"></button>
<button class="pswp__button pswp__button--share" title=Share></button>
<button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button>
<button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button><div class=pswp__preloader><div class=pswp__preloader__icn><div class=pswp__preloader__cut><div class=pswp__preloader__donut></div></div></div></div></div><div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap"><div class=pswp__share-tooltip></div></div><button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)">
</button>
<button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)"></button><div class=pswp__caption><div class=pswp__caption__center></div></div></div></div></div><script src=https://cdn.bootcdn.net/ajax/libs/photoswipe/4.1.3/photoswipe.min.js crossorigin=anonymous defer></script><link rel=preload as=style onload='this.rel="stylesheet"' href=https://cdn.bootcdn.net/ajax/libs/photoswipe/4.1.3/photoswipe.min.css crossorigin=anonymous><script src=https://cdn.bootcdn.net/ajax/libs/photoswipe/4.1.3/photoswipe-ui-default.min.js crossorigin=anonymous defer></script><link rel=preload as=style onload='this.rel="stylesheet"' href=https://cdn.bootcdn.net/ajax/libs/photoswipe/4.1.3/default-skin/default-skin.min.css crossorigin=anonymous></main></div><script type=text/javascript src=/ts/main.js defer></script><a href=javascript:void(0) class=right_things id=back-to-top title=返回顶部></a><style>html{scroll-behavior:smooth}#back-to-top{z-index:998!important;transition:1.5s ease,opacity 2s ease,visibility 2s ease,right .8s ease;opacity:0;display:inline-block;visibility:hidden;position:fixed;bottom:10px;right:10px;width:55px;height:55px;font-size:30px;text-align:center;line-height:50px;border-radius:20px;box-shadow:var(--shadow-l1);cursor:pointer;color:var(--body-text-color);background-image:linear-gradient(-20deg,#e9defa 0%,#fbfcdb 100%); [data-scheme="dark"] & { background-image: linear-gradient(60deg, #241348 0%, #4d0404 100%); }}#back-to-top:before{content:' ';display:inline-block;position:relative;top:0;transform:rotate(135deg);height:10px;width:10px;border-width:0 0 2px 2px;border-style:solid}#back-to-top:hover{transform:scale(1.1,1.1);background-image:linear-gradient(-225deg,#E3FDF5 0%,#FFE6FA 100%); [data-scheme="dark"] & { background-image: linear-gradient(60deg, #432581 0%, #861818 100%); }}#back-to-top:hover:before{border-color:#2674e0}@media screen and (max-width:768px){#back-to-top{width:35px;height:35px;font-size:10px;right:15px}}</style><script>function resizeRight(){var t=document.querySelectorAll(".right_things"),e=window.innerWidth;t.length>0&&t.forEach(function(t){e>2100?t.style.right="280px":e>1800?t.style.right="120px":e<1800&&(t.style.right="10px")})}window.addEventListener("resize",function(){requestAnimationFrame(resizeRight)});function backToTop(){window.scrollTo({top:0,behavior:"smooth"})}window.onload=function(){requestAnimationFrame(resizeRight);var t=this.document.documentElement.scrollTop||this.document.body.scrollTop,e=this.document.getElementById("back-to-top");t>0?(e.style.visibility="visible",e.style.opacity="1"):(e.style.opacity="0",e.style.visibility="hidden")},window.onscroll=function(){var t=this.document.documentElement.scrollTop||this.document.body.scrollTop,e=this.document.getElementById("back-to-top");t<400?(e.style.opacity="0",e.style.visibility="hidden"):(e.style.visibility="visible",e.style.opacity="1",e.addEventListener("click",backToTop,!1))}</script><style>.toggle-toc-inner,.toggle-toc-inner svg{z-index:1!important;pointer-events:none}.toggle-toc-inner{width:100%;height:100%;display:flex;align-items:center;justify-content:center}.toggle-toc-inner svg{display:none}#toc-container{display:none;position:fixed;bottom:120px;right:80px;padding:5px;border:1px solid #96979a50;border-radius:var(--card-border-radius);box-shadow:rgba(14,30,37,.12)0 2px 4px,rgba(14,30,37,.32)0 2px 16px;z-index:997!important;max-height:80vh;overflow-y:auto;width:auto;max-width:500px;background-image:linear-gradient(-20deg,#e9defa 0%,#fbfcdb 100%); [data-scheme="dark"] & { background-image: linear-gradient(60deg, #241348 0%, #4d0404 100%); color: #FFFFFFB2; }}#TableOfContents{background-image:linear-gradient(-20deg,#e9defa 0%,#fbfcdb 100%); [data-scheme="dark"] & { background-image: linear-gradient(60deg, #241348 0%, #4d0404 100%); }}#TableOfContents a:hover{font-weight:bolder}[data-scheme=dark] #TableOfContents a{color:#ffffffb2}[data-scheme=dark] #TableOfContents a:hover{color:#052ed3}#toggle-toc{transition:1.5s ease,opacity 2s ease,visibility 2s ease,right .8s ease;opacity:0;display:block;visibility:hidden;position:fixed;bottom:75px;right:10px;width:55px;height:55px;font-size:1.7rem;padding:5px;z-index:1000!important;border:0 solid #96979a50;border-radius:20px;box-shadow:var(--shadow-l1);color:#707070;cursor:pointer;background-image:linear-gradient(-20deg,#e9defa 0%,#fbfcdb 100%); [data-scheme="dark"] & { background-image: linear-gradient(60deg, #241348 0%, #4d0404 100%); color: #FFFFFFB2; } animation: jump 0.3s 4;animation-delay:.6s}#toggle-toc:hover{transform:scale(1.1,1.1);background-image:linear-gradient(-225deg,#E3FDF5 0%,#FFE6FA 100%); [data-scheme="dark"] & { background-image: linear-gradient(60deg, #432581 0%, #861818 100%); }}.widget--toc #TableOfContents{overflow-x:auto;max-height:66vh;width:auto}.toggle-toc-inner::before{content:'目录'}@media screen and (max-width:1280px){#toc-container{bottom:100px;right:70px;max-width:400px}}@media screen and (max-width:768px){#toggle-toc{width:35px;height:35px;font-size:10px;bottom:60px;right:15px}.toggle-toc-inner::before{content:''}.toggle-toc-inner svg{display:block}#toc-container{bottom:100px;right:60px;max-width:290px}}</style><a id=toggle-toc class=right_things title=目录 href=javascript:void(0)><div class=toggle-toc-inner><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-menu-2" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"/><path d="M4 6h16"/><path d="M4 12h16"/><path d="M4 18h16"/></svg></div></a><section class="widget archives" id=toc-container><h2 class=section-title style=padding-left:10px>目录</h2><div class=widget--toc><nav id=TableOfContents><ol><li><a href=#13-垃圾回收器>13. 垃圾回收器</a><ol><li><a href=#131-gc-分类与性能指标>13.1. GC 分类与性能指标</a><ol><li><a href=#1311-垃圾回收器概述>13.1.1. 垃圾回收器概述</a></li><li><a href=#1312-垃圾收集器分类>13.1.2. 垃圾收集器分类</a></li><li><a href=#1313-评估-gc-的性能指标>13.1.3. 评估 GC 的性能指标</a><ol><li><a href=#吞吐量>吞吐量</a></li><li><a href=#暂停时间>暂停时间</a></li><li><a href=#吞吐量-vs-暂停时间>吞吐量 vs 暂停时间</a></li></ol></li></ol></li><li><a href=#132-不同的垃圾回收器概述>13.2. 不同的垃圾回收器概述</a><ol><li><a href=#1321-垃圾回收器发展史>13.2.1. 垃圾回收器发展史</a></li><li><a href=#1322-7-种经典的垃圾收集器>13.2.2. 7 种经典的垃圾收集器</a></li><li><a href=#1323-7-款经典收集器与垃圾分代之间的关系>13.2.3. 7 款经典收集器与垃圾分代之间的关系</a></li><li><a href=#1324-垃圾收集器的组合关系>13.2.4. 垃圾收集器的组合关系</a></li><li><a href=#1325-不同的垃圾收集器概述>13.2.5. 不同的垃圾收集器概述</a></li><li><a href=#1326-如何查看默认垃圾收集器>13.2.6. 如何查看默认垃圾收集器</a></li></ol></li><li><a href=#133-serial-回收器串行回收>13.3. Serial 回收器：串行回收</a></li><li><a href=#134-parnew-回收器并行回收>13.4. ParNew 回收器：并行回收</a></li><li><a href=#135-parallel-回收器吞吐量优先>13.5. Parallel 回收器：吞吐量优先</a></li><li><a href=#136-cms-回收器低延迟>13.6. CMS 回收器：低延迟</a><ol><li><a href=#1361-cms-的优点>13.6.1. CMS 的优点</a></li><li><a href=#1362-cms-的弊端>13.6.2. CMS 的弊端</a></li><li><a href=#136--三色标记>13.6 三色标记</a></li></ol></li><li><a href=#61-写屏障>6.1 写屏障</a></li><li><a href=#62-读屏障>6.2 读屏障</a></li><li><a href=#63-各种垃圾收集器对漏标的处理方案>6.3 各种垃圾收集器对漏标的处理方案</a></li><li><a href=#64-记忆集和卡表>6.4 记忆集和卡表</a><ol><li><a href=#1记忆集remember-set>1.记忆集（Remember Set）</a></li><li><a href=#2卡表card-table>2.卡表（Card Table）</a></li><li><a href=#1363-设置的参数>13.6.3. 设置的参数</a></li><li><a href=#小结>小结</a></li><li><a href=#1364-jdk-后续版本中-cms-的变化>13.6.4. JDK 后续版本中 CMS 的变化</a></li></ol></li><li><a href=#137-g1-回收器区域化分代式>13.7. G1 回收器：区域化分代式</a><ol><li><a href=#1371-g1-回收器的特点优势>13.7.1. G1 回收器的特点（优势）</a><ol><li><a href=#并行与并发>并行与并发</a></li><li><a href=#分代收集>分代收集</a></li><li><a href=#空间整合>空间整合</a></li><li><a href=#可预测的停顿时间模型即软实时-soft-real-time>可预测的停顿时间模型（即：软实时 soft real-time）</a></li></ol></li><li><a href=#1372-g1-垃圾收集器的缺点>13.7.2. G1 垃圾收集器的缺点</a></li><li><a href=#1373-g1-回收器的参数设置>13.7.3. G1 回收器的参数设置</a></li><li><a href=#1374-g1-收集器的常见操作步骤>13.7.4. G1 收集器的常见操作步骤</a></li><li><a href=#1375-g1-收集器的适用场景>13.7.5. G1 收集器的适用场景</a></li><li><a href=#1376-分区-region化整为零>13.7.6. 分区 Region：化整为零</a></li><li><a href=#1377-g1-垃圾回收器的回收过程>13.7.7. G1 垃圾回收器的回收过程</a></li><li><a href=#1378-remembered-set>13.7.8. Remembered Set</a></li><li><a href=#1379-g1-回收过程一年轻代-gc>13.7.9. G1 回收过程一：年轻代 GC</a></li><li><a href=#13710-g1-回收过程二并发标记过程>13.7.10. G1 回收过程二：并发标记过程</a></li><li><a href=#13711-g1-回收过程三混合回收>13.7.11. G1 回收过程三：混合回收</a></li><li><a href=#13712-g1-回收可选的过程四full-gc>13.7.12. G1 回收可选的过程四：Full GC</a></li><li><a href=#13713-补充>13.7.13. 补充</a></li><li><a href=#13714-g1-回收器优化建议>13.7.14. G1 回收器优化建议</a></li></ol></li><li><a href=#138-垃圾回收器总结>13.8. 垃圾回收器总结</a><ol><li><a href=#1381-7-种经典垃圾回收器总结>13.8.1. 7 种经典垃圾回收器总结</a></li><li><a href=#1382-垃圾回收器组合>13.8.2. 垃圾回收器组合</a></li><li><a href=#1383-怎么选择垃圾回收器>13.8.3. 怎么选择垃圾回收器</a></li></ol></li><li><a href=#139-gc-日志分析>13.9. GC 日志分析</a><ol><li><a href=#minor-gc-日志>Minor GC 日志</a></li><li><a href=#full-gc-日志>Full GC 日志</a></li></ol></li><li><a href=#13x-垃圾回收器的新发展>13.X. 垃圾回收器的新发展</a><ol><li><a href=#13x1-jdk11-新特性>13.X.1. JDK11 新特性</a></li><li><a href=#13x2-open-jdk12-的-shenandoash-gc>13.X.2. Open JDK12 的 Shenandoash GC</a></li><li><a href=#13x3-令人震惊革命性的-zgc>13.X.3. 令人震惊、革命性的 ZGC</a></li><li><a href=#13x4-其他垃圾回收器aligc>13.X.4. 其他垃圾回收器：AliGC</a></li></ol></li></ol></li></ol></nav></div></section><script>var toggleButton=document.getElementById("toggle-toc"),tocContainer=document.getElementById("toc-container"),scrollThreshold=400;function extracted(){var e=window.scrollY||window.pageYOffset;e>=scrollThreshold?(toggleButton.style.visibility="visible",toggleButton.style.opacity="1"):(toggleButton.style.opacity="0",toggleButton.style.visibility="hidden")}window.addEventListener("scroll",function(){extracted()}),window.onload=function(){extracted()},toggleButton.addEventListener("click",function(e){tocContainer.style.display==="none"||tocContainer.style.display===""?tocContainer.style.display="block":tocContainer.style.display="none",e.stopPropagation()}),"ontouchstart"in window||toggleButton.addEventListener("mouseover",function(){tocContainer.style.display="block"}),document.addEventListener("click",function(e){!tocContainer.contains(e.target)&&!toggleButton.contains(e.target)&&e.target!==toggleButton&&e.target!==tocContainer&&(tocContainer.style.display="none")})</script><script src=https://cdn.bootcdn.net/ajax/libs/nprogress/0.2.0/nprogress.min.js crossorigin=anonymous></script><div class=top-scroll-bar></div><style>.top-scroll-bar,.page-load-progress-bar{position:fixed;top:0;left:0;z-index:9999;display:none;width:0;height:4px;border-radius:5px;background-image:linear-gradient(to right,#5a0ca6 0%,rgba(208,114,155,.84) 50%,#29d 100%); [data-scheme="light"] & { background-image: linear-gradient(to right, #78ee6e 0%, #5069e3 50%, #29d 100%); }}#nprogress{pointer-events:none}#nprogress .my_bar{background-image:linear-gradient(to right,#5a0ca6 0%,rgba(208,114,155,.84) 50%,#29d 100%); [data-scheme="light"] & { background-image: linear-gradient(to right, #78ee6e 0%, #5069e3 50%, #29d 100%); } position: fixed;z-index:9999;top:0;left:0;border-radius:10px;width:100%;height:5px}#nprogress .my_peg{display:block;position:absolute;right:0;width:100px;height:100%;box-shadow:0 0 10px #29d,0 0 5px #29d;opacity:1;-webkit-transform:rotate(3deg)translate(0,-4px);-ms-transform:rotate(3deg)translate(0,-4px);transform:rotate(3deg)translate(0,-4px)}#nprogress .my_spinner{display:block;position:fixed;z-index:1031;top:15px;right:15px}#nprogress .my_spinner-icon{width:25px;height:25px;box-sizing:border-box;border:solid 3px transparent;border-top-color:#29d;border-left-color:#29d;border-radius:50%;-webkit-animation:nprogress-spinner 400ms linear infinite;animation:nprogress-spinner 400ms linear infinite}.nprogress-custom-parent{overflow:hidden;position:relative}.nprogress-custom-parent #nprogress .my_spinner,.nprogress-custom-parent #nprogress .my_bar{position:absolute}@-webkit-keyframes nprogress-spinner{0%{-webkit-transform:rotate(0)}100%{-webkit-transform:rotate(360deg)}}@keyframes nprogress-spinner{0%{transform:rotate(0)}100%{transform:rotate(360deg)}}</style><script>var my_template='<div class="my_bar" role="bar"><div class="my_peg"></div></div><div class="my_spinner" role="spinner"><div class="my_spinner-icon"></div></div>';NProgress.configure({template:my_template}),NProgress.start(),document.addEventListener("readystatechange",()=>{if(document.readyState==="interactive"&&NProgress.inc(.6),document.readyState==="complete"){NProgress.done(!0),NProgress.configure({template:my_template,minimum:0,trickle:!1,showSpinner:!1});var e=document.querySelector(".top-scroll-bar");window.addEventListener("scroll",function(){var t=document.documentElement.scrollTop||document.body.scrollTop,n=document.documentElement.scrollHeight-document.documentElement.clientHeight,s=t/n*100;e.style.width=s+"%",e.style.display="block"})}})</script><script>function loadScript(e,t){var n=document.querySelector('script[src="'+e+'"]'),s=!1;n.onload=function(){s||(s=!0,t&&window[t]())},n.onreadystatechange=function(){!s&&(n.readyState==="loaded"||n.readyState==="complete")&&(s=!0,t&&window[t]())}}</script></body></html>