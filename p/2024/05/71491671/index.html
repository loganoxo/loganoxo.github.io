<!doctype html><html lang=zh-cn dir=ltr><head><meta charset=utf-8><meta name=viewport content='width=device-width,initial-scale=1'><meta name=description content="JVM底层原理"><meta name=keywords content="JVM"><title>11-垃圾回收概述及算法</title>
<link rel=canonical href=https://logan.wssw.fun/p/2024/05/71491671/><link rel=stylesheet href=/scss/style.min.13aa7f8d1031a866f598038f5f109d260d836a6b68cfc49d43713498eb7a1e2b.css><meta property='og:title' content="11-垃圾回收概述及算法"><meta property='og:description' content="JVM底层原理"><meta property='og:url' content='https://logan.wssw.fun/p/2024/05/71491671/'><meta property='og:site_name' content='Logan的博客'><meta property='og:type' content='article'><meta property='article:section' content='Draft'><meta property='article:tag' content='JVM'><meta property='article:published_time' content='2024-05-03T03:17:32+08:00'><meta property='article:modified_time' content='2024-05-04T14:09:37+00:00'><meta name=twitter:title content="11-垃圾回收概述及算法"><meta name=twitter:description content="JVM底层原理"><link rel=apple-touch-icon sizes=180x180 href=/apple-touch-icon.png><link rel=icon type=image/png sizes=32x32 href=/favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=/favicon-16x16.png><link rel=manifest href=/site.webmanifest><script async src="https://www.googletagmanager.com/gtag/js?id=G-R7GQB9XXQW"></script><script>var doNotTrack=!1;if(!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-R7GQB9XXQW",{anonymize_ip:!1})}</script><meta name=google-site-verification content="3CAZCWVpDIWQxfZCqLMpov13bCzaH1QdnlHZTNnNjfM"><link rel=preload as=style onload='this.rel="stylesheet"' href=https://cdn.bootcdn.net/ajax/libs/lxgw-wenkai-screen-webfont/1.7.0/style.min.css crossorigin=anonymous><script src=https://cdn.bootcdn.net/ajax/libs/busuanzi/2.3.0/bsz.pure.mini.min.js crossorigin=anonymous async></script><meta name=referrer content="no-referrer-when-downgrade"><script src=/js/sceneanimation.min.8c8c65611aaf0c8996e6d8a06f3e3bc82e6c8d2d2ab542e7cde8df7bceeeba9e.js integrity="sha256-jIxlYRqvDImW5tigbz47yC5sjS0qtULnzejfe87uup4=" crossorigin=anonymous async></script></head><body class=article-page><script>(function(){const e="StackColorScheme";localStorage.getItem(e)||localStorage.setItem(e,"dark")})()</script><script>(function(){const t="StackColorScheme",e=localStorage.getItem(t),n=window.matchMedia("(prefers-color-scheme: dark)").matches===!0;e==="dark"||e==="auto"&&n?document.documentElement.dataset.scheme="dark":document.documentElement.dataset.scheme="light"})()</script><div class="container main-container flex on-phone--column extended"><aside class="sidebar left-sidebar sticky"><button class="hamburger hamburger--spin" type=button id=toggle-menu aria-label=切换菜单>
<span class=hamburger-box><span class=hamburger-inner></span></span></button><header><figure class=site-avatar><a href=/><img src=/img/avatar-3K_hu560d426f92925c766fafa78be2429fd1_3226_300x0_resize_box_3.png width=300 height=300 class=site-logo loading=lazy decoding=async alt=Avatar>
</a><span class=emoji>🍥</span></figure><div class=site-meta><h1 class=site-name><a href=/>Logan🌀</a></h1><h2 class=site-description>Starry serenade ✍️</h2></div></header><ol class=menu-social><li><a href=https://github.com/loganoxo target=_blank title=GitHub rel=me><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-brand-github" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"/><path d="M9 19c-4.3 1.4-4.3-2.5-6-3m12 5v-3.5c0-1 .1-1.4-.5-2 2.8-.3 5.5-1.4 5.5-6a4.6 4.6.0 00-1.3-3.2 4.2 4.2.0 00-.1-3.2s-1.1-.3-3.5 1.3a12.3 12.3.0 00-6.2.0C6.5 2.8 5.4 3.1 5.4 3.1a4.2 4.2.0 00-.1 3.2A4.6 4.6.0 004 9.5c0 4.6 2.7 5.7 5.5 6-.6.6-.6 1.2-.5 2V21"/></svg></a></li><li><a href=https://blog.csdn.net/u014229652 target=_blank title=my_csdn rel=me><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-copyright" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><circle cx="12" cy="12" r="9"/><path d="M14.5 9a3.5 4 0 100 6"/></svg></a></li><li><a href=https://twitter.com target=_blank title=Twitter rel=me><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-brand-twitter" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"/><path d="M22 4.01c-1 .49-1.98.689-3 .99-1.121-1.265-2.783-1.335-4.38-.737S11.977 6.323 12 8v1c-3.245.083-6.135-1.395-8-4 0 0-4.182 7.433 4 11-1.872 1.247-3.739 2.088-6 2 3.308 1.803 6.913 2.423 10.034 1.517 3.58-1.04 6.522-3.723 7.651-7.742a13.84 13.84.0 00.497-3.753C20.18 7.773 21.692 5.25 22 4.009z"/></svg></a></li></ol><ol class=menu id=main-menu><li><a href=/><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-home" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><polyline points="5 12 3 12 12 3 21 12 19 12"/><path d="M5 12v7a2 2 0 002 2h10a2 2 0 002-2v-7"/><path d="M9 21v-6a2 2 0 012-2h2a2 2 0 012 2v6"/></svg>
<span>主页</span></a></li><li><a href=/articles/><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-heart" width="44" height="44" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"/><path d="M19.5 12.572 12 20l-7.5-7.428A5 5 0 1112 6.006a5 5 0 117.5 6.572"/></svg>
<span>我的</span></a></li><li><a href=/page/archives/><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-archive" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><rect x="3" y="4" width="18" height="4" rx="2"/><path d="M5 8v10a2 2 0 002 2h10a2 2 0 002-2V8"/><line x1="10" y1="12" x2="14" y2="12"/></svg>
<span>归档</span></a></li><li><a href=/page/photos/><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-camera" width="44" height="44" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"/><path d="M5 7h1a2 2 0 002-2 1 1 0 011-1h6a1 1 0 011 1 2 2 0 002 2h1a2 2 0 012 2v9a2 2 0 01-2 2H5a2 2 0 01-2-2V9a2 2 0 012-2"/><path d="M9 13a3 3 0 106 0 3 3 0 00-6 0"/></svg>
<span>相册</span></a></li><li><a href=/page/search/><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-search" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><circle cx="10" cy="10" r="7"/><line x1="21" y1="21" x2="15" y2="15"/></svg>
<span>搜索</span></a></li><li><a href=/timeline/><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-fish-christianity" width="44" height="44" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"/><path d="M22 7S16.354 17 9.692 17c-3.226.025-6.194-1.905-7.692-5 1.498-3.095 4.466-5.025 7.692-5C16.354 7 22 17 22 17"/></svg>
<span>年轴</span></a></li><li><a href=/page/links/><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-link" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><path d="M10 14a3.5 3.5.0 005 0l4-4a3.5 3.5.0 00-5-5l-.5.5"/><path d="M14 10a3.5 3.5.0 00-5 0l-4 4a3.5 3.5.0 005 5l.5-.5"/></svg>
<span>友链</span></a></li><li><a href=/page/about/><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-user" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><circle cx="12" cy="7" r="4"/><path d="M6 21v-2a4 4 0 014-4h4a4 4 0 014 4v2"/></svg>
<span>关于</span></a></li><li class=menu-bottom-section><ol class=menu><li id=dark-mode-toggle><svg class="icon icon-tabler icon-tabler-toggle-left" viewBox="0 0 1025 1024" xmlns="http://www.w3.org/2000/svg" p-id="14930" width="128" height="128"><path d="M253.939302 502.92736a269.74208 269.74208.0 00122.90048 235.84768 257.024 257.024.0 00259.95264 9.07264c81.46944-44.27776 135.70048-130.49856 139.0592-226.7136 5.14048-147.3536-107.37664-270.1312-250.63424-275.1488-145.32608-5.05856-266.1376 109.568-271.27808 256.94208zM531.730022.3072c16.384.57344 32.256 15.48288 31.62112 33.8944l-3.72736 106.43456c-.57344 16.384-15.4624 32.256-33.8944 31.60064-16.384-.57344-32.23552-15.4624-31.60064-33.8944l3.72736-106.43456c2.74432-20.3776 15.4624-32.23552 33.87392-31.60064zm493.89568 527.52384c-.57344 16.384-13.35296 30.26944-33.8944 31.60064l-104.36608-3.64544c-16.384-.57344-32.19456-17.53088-31.62112-33.8944.57344-16.384 15.48288-32.256 33.8944-31.60064l104.38656 3.64544a32.3584 32.3584.0 0131.60064 33.8944zm-855.53152-29.9008c-.57344 16.384-13.35296 30.28992-33.8944 31.62112l-104.38656-3.64544c-16.384-.57344-32.17408-17.5104-31.60064-33.8944.57344-16.384 15.4624-32.256 33.8944-31.60064l104.38656 3.64544a32.3584 32.3584.0 0131.60064 33.8944zm325.91872 525.76256c-16.384-.57344-32.256-15.48288-31.62112-33.8944l3.72736-106.43456c.57344-16.384 15.4624-32.256 33.8944-31.60064 16.384.57344 32.23552 15.4624 31.60064 33.8944l-3.72736 106.43456c-2.74432 20.3776-17.5104 32.1536-33.87392 31.60064zm401.32608-871.26016c11.85792 12.6976 11.0592 35.2256-1.6384 47.06304l-78.37696 73.09312c-12.6976 11.85792-33.1776 11.14112-47.08352-1.6384-11.83744-12.6976-11.0592-35.2256 1.6384-47.08352l78.39744-73.09312c16.85504-13.74208 35.2256-11.0592 47.06304 1.6384zm-15.50336 737.1776c-12.6976 11.85792-31.1296 11.22304-47.06304-1.6384l-70.9632-80.34304c-11.85792-12.6976-11.0592-35.2256 1.6384-47.08352s35.2256-11.0592 47.08352 1.6384l73.07264 78.37696c9.728 14.68416 8.94976 37.21216-3.76832 49.0496zm-596.31616-645.8368c-12.6976 11.85792-31.1296 11.20256-47.06304-1.6384l-73.09312-78.37696c-11.85792-12.6976-11.0592-35.2256 1.6384-47.08352s35.2256-11.0592 47.08352 1.6384l73.09312 78.37696c11.776 14.7456 11.0592 35.2256-1.6384 47.08352zm-138.24 614.05184c-11.85792-12.71808-11.0592-35.2256 1.6384-47.08352l78.37696-73.09312c12.6976-11.83744 33.1776-11.12064 47.08352 1.6384 11.83744 12.71808 11.0592 35.2256-1.6384 47.104l-78.39744 73.07264c-16.7936 11.71456-35.2256 11.0592-47.06304-1.6384z" fill="#ffb948"/></svg>
<svg class="icon icon-tabler icon-tabler-toggle-right" viewBox="0 0 1024 1024" xmlns="http://www.w3.org/2000/svg" width="128" height="128"><path d="M578.256332 591.814252v-82.970701m0 95.54202a12.655127 12.655127.0 01-12.571318-12.571319v-82.970701a12.571318 12.571318.0 1125.142636.0v82.970701a12.571318 12.571318.0 01-12.571318 12.571319z" fill="#f89b1b"/><path d="M598.873294 479.342858a36.959676 36.959676.0 01-27.573092-61.59946 52.380493 52.380493.0 1062.521357 36.540632 36.875867 36.875867.0 01-34.948265 25.058828zm204.0744-109.035234v-82.970701m0 95.542019a12.571318 12.571318.0 01-12.571318-12.571318v-82.970701a12.571318 12.571318.0 1125.142636.0v82.970701a12.571318 12.571318.0 01-12.571318 12.571318z" fill="#f89b1b"/><path d="M823.9837 257.83623a36.959676 36.959676.0 01-27.6569-61.515651 52.129067 52.129067.0 1064.616576 50.285273 53.050963 53.050963.0 00-2.011411-14.163685A36.875867 36.875867.0 01823.9837 257.83623z" fill="#f89b1b"/><path d="M803.282929 328.822274a59.588049 59.588049.0 0159.588049 59.588048V785.66398H743.694881V388.410322a59.588049 59.588049.0 0159.588048-59.588048zM581.776301 551.16699a143.145411 143.145411.0 01143.145411 143.145411V837.54162H438.463272V694.312401A143.145411 143.145411.0 01581.776301 551.16699z" fill="#612273"/><path d="M600.968514 198.667225l-49.111951-4.693292a8.380879 8.380879.0 01-7.039938-5.196145l-17.599845-42.658674a8.380879 8.380879.0 00-15.672244.0l-17.432228 42.658674a8.380879 8.380879.0 01-7.039938 5.196145l-49.11195 4.693292a8.380879 8.380879.0 00-4.777101 14.750347l36.959676 32.51781a8.380879 8.380879.0 012.681881 8.380878l-11.06276 45.67579a8.380879 8.380879.0 0012.487509 9.302776L515.232123 285.074086a8.380879 8.380879.0 018.380879.0l40.982497 24.136931a8.380879 8.380879.0 0012.571319-9.302776l-10.978952-45.675789a8.380879 8.380879.0 012.681882-8.380879L606.08085 213.417572a8.380879 8.380879.0 00-5.028528-14.750347z" fill="#fed150"/><path d="M470.897274 246.77347l1.927602-8.380879a8.380879 8.380879.0 00-2.681881-8.380879l-35.032074-30.506399a8.380879 8.380879.0 00-1.927602 13.912259l36.959676 32.51781a6.788512 6.788512.0 01.754279.838088zM603.98563 199.589122l-34.948265 30.674016a8.380879 8.380879.0 00-2.681881 8.380879l1.927602 8.380879a6.788512 6.788512.0 01.754279-.838088l37.043485-32.769236a8.380879 8.380879.0 00-2.09522-13.82845zm-28.578797 92.189667a8.380879 8.380879.0 01-10.643716 1.759985l-40.982498-24.053123a8.380879 8.380879.0 00-8.380879.0L474.249625 293.454965a8.380879 8.380879.0 01-10.643716-1.676176l-1.927602 8.380879a8.380879 8.380879.0 0012.487509 9.302775l41.066307-24.388357a8.380879 8.380879.0 018.380879.0l40.982497 24.136931a8.380879 8.380879.0 0012.571319-9.302776z" fill="#fed150" opacity=".5"/><path d="M434.608068 426.543321l-28.159753-2.681881a4.86091 4.86091.0 01-4.022822-3.017117l-10.057054-24.388357a4.86091 4.86091.0 00-8.967541.0l-9.973245 24.388357a4.693292 4.693292.0 01-4.022822 3.017117l-28.159753 2.681881a4.86091 4.86091.0 00-2.76569 8.380879l21.203623 18.605551a4.944719 4.944719.0 011.592367 4.777101L354.654484 484.455194a4.86091 4.86091.0 007.123747 5.363762l23.466461-13.82845a5.196145 5.196145.0 014.944718.0l23.466461 13.82845a4.86091 4.86091.0 007.123747-5.363762l-6.285659-26.064533a4.86091 4.86091.0 011.508558-4.777101l21.203624-18.605551a4.86091 4.86091.0 00-2.849499-8.380879z" fill="#fed150"/><path d="M360.102055 454.032604l1.173323-4.609484a4.944719 4.944719.0 00-1.592367-5.112336l-20.0303-17.683654a4.944719 4.944719.0 00-1.173323 8.380879l21.203623 18.605551zm76.182189-26.98643-20.0303 17.26461a4.86091 4.86091.0 00-1.508559 4.777101l1.173323 4.693292v-.502852l21.203624-18.605551a4.86091 4.86091.0 00-.838088-7.6266zM419.94153 479.845711a4.777101 4.777101.0 01-6.034233 1.005705l-23.46646-13.82845a5.196145 5.196145.0 00-4.944719.0l-23.466461 13.82845a4.777101 4.777101.0 01-6.034233-1.005705l-1.089514 4.609483a4.86091 4.86091.0 007.123747 5.363762l23.466461-13.82845a5.196145 5.196145.0 014.944719.0l23.46646 13.82845a4.86091 4.86091.0 007.123747-5.363762z" fill="#fed150" opacity=".5"/><path d="M635.413926 803.68287A414.685886 414.685886.0 01459.41547 18.729756 9.805628 9.805628.0 00453.967898.124205a513.831683 513.831683.0 10567.050264 607.027056 9.805628 9.805628.0 00-18.186507-6.704704A414.350651 414.350651.0 01635.413926 803.68287z" fill="#fed150" p-id="22313"/><path d="M50.931434 292.868303a460.110249 460.110249.0 00275.311871 359.455895 413.847798 413.847798.0 01133.339782-633.594442A9.805628 9.805628.0 00453.967898.124205 513.915492 513.915492.0 0050.931434 292.868303z" fill="#fed150" opacity=".4" p-id="22314"/><path d="M1006.016389 597.261823A513.664065 513.664065.0 013.914704 475.320036c-.670471 10.308481-1.257132 20.616962-1.257132 31.093061a513.831683 513.831683.0 001018.36059 100.570546 9.805628 9.805628.0 00-15.001773-9.72182zM231.539373 332.258434c0 7.458982.67047 14.917964 1.257132 22.293138A414.769695 414.769695.0 01459.583087 18.729756 9.805628 9.805628.0 00453.967898.124205a505.869848 505.869848.0 00-94.620122 20.868388A413.177328 413.177328.0 00231.539373 332.258434z" fill="#fed150" opacity=".5" p-id="22315"/><path d="M715.032275 421.514794m17.683654.0h141.217809q17.683654.0 17.683655 17.683654v-.083809q0 17.683654-17.683655 17.683655H732.715929q-17.683654.0-17.683654-17.683655v.083809q0-17.683654 17.683654-17.683654z" fill="#eb3d72" p-id="22316"/><path d="M205.139605 319.603307c4.441866-6.872321 22.041711-45.340555-11.817039-67.047031s-51.626214 8.380879-51.626214 8.380879a25.142637 25.142637.0 1042.742482 27.489282s2.179029 5.950424-6.537085 18.437934-25.142637 12.236083-43.077718.754279-47.01673-65.789899-.67047-138.787354c1.592367-2.514264 3.352352-4.693292 5.028527-7.039938a26.818812 26.818812.0 00-23.047417-2.430455 33.523515 33.523515.0 00-18.689359 17.683654c-31.260678 64.36515-22.628373 127.724594 21.203623 155.884347 48.944333 31.093061 82.048804-6.453277 86.49067-13.325597zM734.224488 931.491272c6.453277-2.681881 37.713955-21.45505 24.304548-53.386198s-40.647262-19.35983-40.647262-19.35983a21.874094 21.874094.0 1016.761757 40.312027s-1.340941 5.363762-13.577023 9.973246S697.264812 905.259122 689.889638 888.497364s-1.340941-69.561295 67.047031-98.894371c2.346646-1.005705 4.693292-1.676176 7.039938-2.514263a31.931148 31.931148.0 00-1.927602-3.352352 28.578797 28.578797.0 00-38.635851-7.542791c-51.87764 30.841634-74.422204 81.545951-57.325212 122.277023 19.778874 46.262451 61.59946 35.786353 68.136546 33.020662zM279.813236 802.844782c-5.950424-3.687587-39.390131-18.354125-57.660447 11.146569s7.794217 44.334849 7.794217 44.334849a21.874094 21.874094.0 1023.047417-36.875867s5.112336-2.011411 16.007479 5.279954 10.811334 21.622667 1.173323 37.211102-55.984271 41.317733-119.511333 2.430455c-2.179029-1.340941-4.106631-2.849499-6.118041-4.274249a22.376947 22.376947.0 00-1.676176 3.51997 28.662606 28.662606.0 0016.342714 36.037779c55.146183 24.388357 109.538087 13.409406 132.920739-24.136931 26.399768-42.9101-6.369468-70.902235-12.319892-74.673631zM431.00429 694.312401h302.298301m0 20.952197H431.00429a20.952197 20.952197.0 010-41.904394h302.298301a20.952197 20.952197.0 010 41.904394z" fill="#eb3d72" p-id="22317"/><path d="M255.760113 683.082023m-30.171164.0a30.171164 30.171164.0 1060.342328.0 30.171164 30.171164.0 10-60.342328.0z" fill="#fed150" opacity=".4" p-id="22318"/><path d="M356.246851 840.977781m-30.171164.0a30.171164 30.171164.0 1060.342328.0 30.171164 30.171164.0 10-60.342328.0z" fill="#fed150" opacity=".4" p-id="22319"/><path d="M54.870447 472.135302m-30.171164.0a30.171164 30.171164.0 1060.342328.0 30.171164 30.171164.0 10-60.342328.0z" fill="#fed150" opacity=".4" p-id="22320"/><path d="M561.410765 873.914635m-30.171164.0a30.171164 30.171164.0 1060.342328.0 30.171164 30.171164.0 10-60.342328.0z" fill="#fed150" opacity=".5" p-id="22321"/><path d="M445.167976 825.13792m-19.862683.0a19.862683 19.862683.0 1039.725365.0 19.862683 19.862683.0 10-39.725365.0z" fill="#fed150" opacity=".5" p-id="22322"/><path d="M149.406761 689.786726m-19.862683.0a19.862683 19.862683.0 1039.725365.0 19.862683 19.862683.0 10-39.725365.0z" fill="#fed150" opacity=".5" p-id="22323"/><path d="M132.225959 633.299603m-18.940786.0a18.940786 18.940786.0 1037.881572.0 18.940786 18.940786.0 10-37.881572.0z" fill="#fed150" opacity=".4" p-id="22324"/><path d="M475.339139 906.935297m-18.940786.0a18.940786 18.940786.0 1037.881573.0 18.940786 18.940786.0 10-37.881573.0z" fill="#fed150" opacity=".4" p-id="22325"/></svg>
<span>主题</span></li></ol></li></ol></aside><main class="main full-width"><div class=breadcrumb><li><a href=/>首页</a></li><li><a href=/p/>Drafts</a></li><li class=active><a href=/p/2024/05/71491671/>11-垃圾回收概述及算法</a></li></div><article class=main-article><header class="article-header not-page"><section class="main-hero-waves-area waves-area"><svg class="waves-svg" xmlns="http://www.w3.org/2000/svg" viewBox="0 24 150 28" preserveAspectRatio="none" shape-rendering="auto"><defs><path id="gentle-wave" d="M-160 44c30 0 58-18 88-18s58 18 88 18 58-18 88-18 58 18 88 18v44h-352z"/></defs><g class="parallax"><use href="#gentle-wave" x="48" y="0"/><use href="#gentle-wave" x="48" y="3"/><use href="#gentle-wave" x="48" y="5"/><use href="#gentle-wave" x="48" y="7"/></g></svg></section><style>.main-hero-waves-area{--icat-post-waveone:rgba(17, 17, 17, 0.78);--icat-post-wavetwo:rgba(17, 17, 17, 0.51);--icat-post-wavethree:rgba(17, 17, 17, 0.212);--icat-post-wavefour:rgb(17, 17, 17);opacity:1; [data-scheme="light"] & { --icat-post-waveone: rgba(255, 255, 255, 0.741); --icat-post-wavetwo: rgba(255, 255, 255, 0.51); --icat-post-wavethree: rgba(255, 255, 255, 0.212); --icat-post-wavefour: #fff; }}.waves-area{width:100%;position:absolute;left:0;bottom:0;z-index:5}.waves-area .waves-svg{width:100%;height:8rem}@media screen and (max-width:768px){.waves-area .waves-svg{height:40px;min-height:40px}}.waves-area .waves-svg .parallax>use{-webkit-animation:move-forever 25s cubic-bezier(.55,.5,.45,.5)infinite;-moz-animation:move-forever 25s cubic-bezier(.55,.5,.45,.5)infinite;-o-animation:move-forever 25s cubic-bezier(.55,.5,.45,.5)infinite;-ms-animation:move-forever 25s cubic-bezier(.55,.5,.45,.5)infinite;animation:move-forever 25s cubic-bezier(.55,.5,.45,.5)infinite}.waves-area .waves-svg .parallax>use:nth-child(1){-webkit-animation-delay:-2s;-moz-animation-delay:-2s;-o-animation-delay:-2s;-ms-animation-delay:-2s;animation-delay:-2s;-webkit-animation-duration:7s;-moz-animation-duration:7s;-o-animation-duration:7s;-ms-animation-duration:7s;animation-duration:7s;fill:var(--icat-post-waveone)}.waves-area .waves-svg .parallax>use:nth-child(2){-webkit-animation-delay:-3s;-moz-animation-delay:-3s;-o-animation-delay:-3s;-ms-animation-delay:-3s;animation-delay:-3s;-webkit-animation-duration:10s;-moz-animation-duration:10s;-o-animation-duration:10s;-ms-animation-duration:10s;animation-duration:10s;fill:var(--icat-post-wavetwo)}.waves-area .waves-svg .parallax>use:nth-child(3){-webkit-animation-delay:-4s;-moz-animation-delay:-4s;-o-animation-delay:-4s;-ms-animation-delay:-4s;animation-delay:-4s;-webkit-animation-duration:13s;-moz-animation-duration:13s;-o-animation-duration:13s;-ms-animation-duration:13s;animation-duration:13s;fill:var(--icat-post-wavethree)}.waves-area .waves-svg .parallax>use:nth-child(4){-webkit-animation-delay:-5s;-moz-animation-delay:-5s;-o-animation-delay:-5s;-ms-animation-delay:-5s;animation-delay:-5s;-webkit-animation-duration:20s;-moz-animation-duration:20s;-o-animation-duration:20s;-ms-animation-duration:20s;animation-duration:20s;fill:var(--icat-post-wavefour)}@keyframes move-forever{0%{transform:translate3d(-90px,0,0)}100%{transform:translate3d(85px,0,0)}}</style><div class=article-details><header class=article-category><a href=/categories/jvm/>JVM</a></header><div class=article-title-wrapper><h2 class=article-title><a href=/p/2024/05/71491671/>11-垃圾回收概述及算法</a></h2><h3 class=article-subtitle>JVM底层原理</h3></div><footer class=article-time><div><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-calendar-time" width="56" height="56" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><path d="M11.795 21H5a2 2 0 01-2-2V7a2 2 0 012-2h12a2 2 0 012 2v4"/><circle cx="18" cy="18" r="4"/><path d="M15 3v4"/><path d="M7 3v4"/><path d="M3 11h16"/><path d="M18 16.496V18l1 1"/></svg>
<time class=article-time--published>2024年5月3日</time></div><div><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-clock" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><circle cx="12" cy="12" r="9"/><polyline points="12 7 12 12 15 15"/></svg>
<time class=article-time--reading>阅读时长: 24 分钟</time></div></footer></div></header><section class=article-content><blockquote><p>笔记来源：<a class=link href=https://www.bilibili.com/video/BV1PJ411n7xZ title=尚硅谷JVM全套教程，百万播放，全网巅峰（宋红康详解java虚拟机） target=_blank rel=noopener>尚硅谷 JVM 全套教程，百万播放，全网巅峰（宋红康详解 java 虚拟机）
<span style=white-space:nowrap><svg width=".7em" height=".7em" viewBox="0 0 21 21" xmlns="http://www.w3.org/2000/svg"><path d="m13 3 3.293 3.293-7 7 1.414 1.414 7-7L21 11V3z" fill="currentcolor"/><path d="M19 19H5V5h7l-2-2H5c-1.103.0-2 .897-2 2v14c0 1.103.897 2 2 2h14c1.103.0 2-.897 2-2v-5l-2-2v7z" fill="currentcolor"/></span></a></p><p>同步更新：https://gitee.com/vectorx/NOTE_JVM</p><p><a class=link href=https://codechina.csdn.net/qq_35925558/NOTE_JVM target=_blank rel=noopener>https://codechina.csdn.net/qq_35925558/NOTE_JVM
<span style=white-space:nowrap><svg width=".7em" height=".7em" viewBox="0 0 21 21" xmlns="http://www.w3.org/2000/svg"><path d="m13 3 3.293 3.293-7 7 1.414 1.414 7-7L21 11V3z" fill="currentcolor"/><path d="M19 19H5V5h7l-2-2H5c-1.103.0-2 .897-2 2v14c0 1.103.897 2 2 2h14c1.103.0 2-.897 2-2v-5l-2-2v7z" fill="currentcolor"/></span></a></p><p><a class=link href=https://github.com/uxiahnan/NOTE_JVM target=_blank rel=noopener>https://github.com/uxiahnan/NOTE_JVM
<span style=white-space:nowrap><svg width=".7em" height=".7em" viewBox="0 0 21 21" xmlns="http://www.w3.org/2000/svg"><path d="m13 3 3.293 3.293-7 7 1.414 1.414 7-7L21 11V3z" fill="currentcolor"/><path d="M19 19H5V5h7l-2-2H5c-1.103.0-2 .897-2 2v14c0 1.103.897 2 2 2h14c1.103.0 2-.897 2-2v-5l-2-2v7z" fill="currentcolor"/></span></a></p></blockquote><p>[toc]</p><h1 id=11-垃圾回收概述及算法><a href=#11-%e5%9e%83%e5%9c%be%e5%9b%9e%e6%94%b6%e6%a6%82%e8%bf%b0%e5%8f%8a%e7%ae%97%e6%b3%95 class=header-anchor>#</a>
11. 垃圾回收概述及算法</h1><h2 id=111-垃圾回收概述><a href=#111-%e5%9e%83%e5%9c%be%e5%9b%9e%e6%94%b6%e6%a6%82%e8%bf%b0 class=header-anchor>#</a>
11.1. 垃圾回收概述</h2><h3 id=1111-什么是垃圾><a href=#1111-%e4%bb%80%e4%b9%88%e6%98%af%e5%9e%83%e5%9c%be class=header-anchor>#</a>
11.1.1. 什么是垃圾？</h3><p><img src=https://logan.1357810.xyz/img/20220422/152946273-e1a32c50a4.png width=900 height=600 loading=lazy decoding=async alt=image-20200712085456113 class="gallery-image link-image" data-flex-grow=20 data-flex-basis=20px></p><p>垃圾收集，不是 Java 语言的伴生产物。早在 1960 年，第一门开始使用内存动态分配和垃圾收集技术的 Lisp 语言诞生。</p><p>关于垃圾收集有三个经典问题：</p><ul><li>哪些内存需要回收？</li><li>什么时候回收？</li><li>如何回收？</li></ul><p>垃圾收集机制是 Java 的招牌能力，<mark>极大地提高了开发效率</mark>。如今，垃圾收集几乎成为现代语言的标配，即使经过如此长时间的发展，Java 的垃圾收集机制仍然在不断的演进中，不同大小的设备、不同特征的应用场景，对垃圾收集提出了新的挑战，这当然也是面试的热点。</p><p><strong>大厂面试题</strong></p><blockquote><p><mark>蚂蚁金服</mark></p><ul><li><p>你知道哪几种垃圾回收器，各自的优缺点，重点讲一下 cms 和 G1？</p></li><li><p>JVM GC 算法有哪些，目前的 JDK 版本采用什么回收算法？</p></li><li><p>G1 回收器讲下回收过程 GC 是什么？为什么要有 GC？</p></li><li><p>GC 的两种判定方法？CMS 收集器与 G1 收集器的特点</p></li></ul><p><mark>百度</mark></p><ul><li><p>说一下 GC 算法，分代回收说下</p></li><li><p>垃圾收集策略和算法</p></li></ul><p><mark>天猫</mark></p><ul><li><p>JVM GC 原理，JVM 怎么回收内存</p></li><li><p>CMS 特点，垃圾回收算法有哪些？各自的优缺点，他们共同的缺点是什么？</p></li></ul><p><mark>滴滴</mark></p><ul><li>Java 的垃圾回收器都有哪些，说下 g1 的应用场景，平时你是如何搭配使用垃圾回收器的</li></ul><p><mark>京东</mark></p><ul><li><p>你知道哪几种垃圾收集器，各自的优缺点，重点讲下 cms 和 G1，</p></li><li><p>包括原理，流程，优缺点。垃圾回收算法的实现原理</p></li></ul><p><mark>阿里</mark></p><ul><li><p>讲一讲垃圾回收算法。</p></li><li><p>什么情况下触发垃圾回收？</p></li><li><p>如何选择合适的垃圾收集算法？</p></li><li><p>JVM 有哪三种垃圾回收器？</p></li></ul><p><mark>字节跳动</mark></p><ul><li>常见的垃圾回收器算法有哪些，各有什么优劣？</li><li>System.gc（）和 Runtime.gc（）会做什么事情？</li><li>Java GC 机制？GC Roots 有哪些？</li><li>Java 对象的回收方式，回收算法。</li><li>CMS 和 G1 了解么，CMS 解决什么问题，说一下回收的过程。</li><li>CMS 回收停顿了几次，为什么要停顿两次?</li></ul></blockquote><h4 id=什么是垃圾><a href=#%e4%bb%80%e4%b9%88%e6%98%af%e5%9e%83%e5%9c%be class=header-anchor>#</a>
什么是垃圾？</h4><blockquote><p>An object is considered garbage when it can no longer be reached from any pointer in the running program</p></blockquote><p>垃圾是指在运行程序中没有任何指针指向的对象，这个对象就是需要被回收的垃圾。</p><p>如果不及时对内存中的垃圾进行清理，那么，这些垃圾对象所占的内存空间会一直保留到应用程序的结束，被保留的空间无法被其它对象使用，甚至可能导致内存溢出。</p><p><strong>磁盘碎片整理的日子</strong></p><p>机械硬盘需要进行磁盘整理，同时还有坏道</p><p><img src=https://logan.1357810.xyz/img/20220422/152946273-ade769a7b2.png width=900 height=600 loading=lazy decoding=async alt=image-20200712090848669 class="gallery-image link-image" data-flex-grow=20 data-flex-basis=20px></p><h2 id=1112-为什么需要-gc><a href=#1112-%e4%b8%ba%e4%bb%80%e4%b9%88%e9%9c%80%e8%a6%81-gc class=header-anchor>#</a>
11.1.2. 为什么需要 GC</h2><p><strong>想要学习 GC，首先需要理解为什么需要 GC？</strong></p><p>对于高级语言来说，一个基本认知是如果不进行垃圾回收，<mark>内存迟早都会被消耗完</mark>，因为不断地分配内存空间而不进行回收，就好像不停地生产生活垃圾而从来不打扫一样。</p><p>除了释放没用的对象，垃圾回收也可以清除内存里的记录碎片。碎片整理将所占用的堆内存移到堆的一端，以便<mark>JVM 将整理出的内存分配给新的对象</mark>。</p><p>随着应用程序所应付的业务越来越庞大、复杂，用户越来越多，<mark>没有 GC 就不能保证应用程序的正常进行</mark>。而经常造成 STW 的 GC 又跟不上实际的需求，所以才会不断地尝试对 GC 进行优化。</p><h2 id=1113-早期垃圾回收><a href=#1113-%e6%97%a9%e6%9c%9f%e5%9e%83%e5%9c%be%e5%9b%9e%e6%94%b6 class=header-anchor>#</a>
11.1.3. 早期垃圾回收</h2><p>在早期的 C/C++时代，垃圾回收基本上是手工进行的。开发人员可以使用 new 关键字进行内存申请，并使用 delete 关键字进行内存释放。比如以下代码：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-0-1><a class=lnlinks href=#hl-0-1>1</a>
</span><span class=lnt id=hl-0-2><a class=lnlinks href=#hl-0-2>2</a>
</span><span class=lnt id=hl-0-3><a class=lnlinks href=#hl-0-3>3</a>
</span><span class=lnt id=hl-0-4><a class=lnlinks href=#hl-0-4>4</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl><span class=n>MibBridge</span> <span class=o>*</span><span class=n>pBridge</span><span class=o>=</span> <span class=k>new</span> <span class=n>cmBaseGroupBridge</span><span class=p>();</span>
</span></span><span class=line><span class=cl><span class=c1>//如果注册失败，使用Delete释放该对象所占内存区域
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=k>if</span> <span class=p>(</span><span class=n>pBridge</span><span class=o>-&gt;</span><span class=n>Register</span><span class=p>(</span><span class=n>kDestroy</span><span class=p>)</span> <span class=o>!=</span> <span class=n>NO</span> <span class=n>ERROR</span><span class=err>）</span>
</span></span><span class=line><span class=cl>	<span class=k>delete</span> <span class=n>pBridge</span><span class=p>;</span>
</span></span></code></pre></td></tr></table></div></div><p>这种方式可以灵活控制内存释放的时间，但是会给开发人员带来<mark>频繁申请和释放内存的管理负担</mark>。倘若有一处内存区间由于程序员编码的问题忘记被回收，那么就会产生<mark>内存泄漏</mark>，垃圾对象永远无法被清除，随着系统运行时间的不断增长，垃圾对象所耗内存可能持续上升，直到出现内存溢出并造成<mark>应用程序崩溃</mark>。</p><p>在有了垃圾回收机制后，上述代码极有可能变成这样</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-1-1><a class=lnlinks href=#hl-1-1>1</a>
</span><span class=lnt id=hl-1-2><a class=lnlinks href=#hl-1-2>2</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl><span class=n>MibBridge</span> <span class=o>*</span><span class=n>pBridge</span> <span class=o>=</span> <span class=k>new</span> <span class=n>cmBaseGroupBridge</span><span class=p>();</span>
</span></span><span class=line><span class=cl><span class=n>pBridge</span><span class=o>-&gt;</span><span class=n>Register</span><span class=p>(</span><span class=n>kDestroy</span><span class=p>);</span>
</span></span></code></pre></td></tr></table></div></div><p>现在，除了 Java 以外，C#、Python、Ruby 等语言都使用了自动垃圾回收的思想，也是未来发展趋势，可以说这种自动化的内存分配和来及回收方式已经成为了线代开发语言必备的标准。</p><h2 id=1114-java-垃圾回收机制><a href=#1114-java-%e5%9e%83%e5%9c%be%e5%9b%9e%e6%94%b6%e6%9c%ba%e5%88%b6 class=header-anchor>#</a>
11.1.4. Java 垃圾回收机制</h2><p>自动内存管理，无需开发人员手动参与内存的分配与回收，这样<mark>降低内存泄漏和内存溢出的风险</mark></p><ul><li>没有垃圾回收器，java 也会和 cpp 一样，各种悬垂指针，野指针，泄露问题让你头疼不已。</li></ul><p>自动内存管理机制，将程序员从繁重的内存管理中释放出来，可以更专心地<mark>专注于业务开发</mark></p><p>oracle 官网关于垃圾回收的介绍 <a class=link href=https://docs.oracle.com/javase/8/docs/technotes/guides/vm/gctuning/toc.html target=_blank rel=noopener>https://docs.oracle.com/javase/8/docs/technotes/guides/vm/gctuning/toc.html
<span style=white-space:nowrap><svg width=".7em" height=".7em" viewBox="0 0 21 21" xmlns="http://www.w3.org/2000/svg"><path d="m13 3 3.293 3.293-7 7 1.414 1.414 7-7L21 11V3z" fill="currentcolor"/><path d="M19 19H5V5h7l-2-2H5c-1.103.0-2 .897-2 2v14c0 1.103.897 2 2 2h14c1.103.0 2-.897 2-2v-5l-2-2v7z" fill="currentcolor"/></span></a></p><h4 id=担忧><a href=#%e6%8b%85%e5%bf%a7 class=header-anchor>#</a>
担忧</h4><p>对于 Java 开发人员而言，自动内存管理就像是一个黑匣子，如果过度依赖于“自动”，那么这将会是一场灾难，最严重的就会<mark>弱化 Java 开发人员在程序出现内存溢出时定位问题和解决问题的能力</mark>。</p><p>此时，了解 JVM 的自动内存分配和内存回收原理就显得非常重要，只有在真正了解 JVM 是如何管理内存后，我们才能够在遇见 outofMemoryError 时，快速地根据错误异常日志定位问题和解决问题。</p><p>当需要排查各种内存溢出、内存泄漏问题时，当垃圾收集成为系统达到更高并发量的瓶颈时，我们就必须对这些“自动化”的技术<mark>实施必要的监控和调节</mark>。</p><h4 id=gc-主要关注的区域><a href=#gc-%e4%b8%bb%e8%a6%81%e5%85%b3%e6%b3%a8%e7%9a%84%e5%8c%ba%e5%9f%9f class=header-anchor>#</a>
GC 主要关注的区域</h4><p>GC 主要关注于 方法区 和堆中的垃圾收集</p><p><img src=https://logan.1357810.xyz/img/20220422/152946273-b0c1709d32.png width=900 height=600 loading=lazy decoding=async alt=image-20200712092427246 class="gallery-image link-image" data-flex-grow=20 data-flex-basis=20px></p><p>垃圾收集器可以对年轻代回收，也可以对老年代回收，甚至是全栈和方法区的回收。其中，<mark>Java 堆是垃圾收集器的工作重点</mark></p><p>从次数上讲：</p><ul><li><mark>频繁收集 Young 区</mark></li><li><mark>较少收集 Old 区</mark></li><li><mark>基本不收集 Perm 区（元空间）</mark></li></ul><h2 id=112-垃圾回收相关算法><a href=#112-%e5%9e%83%e5%9c%be%e5%9b%9e%e6%94%b6%e7%9b%b8%e5%85%b3%e7%ae%97%e6%b3%95 class=header-anchor>#</a>
11.2. 垃圾回收相关算法</h2><p><strong>对象存活判断</strong></p><p>在堆里存放着几乎所有的 Java 对象实例，在 GC 执行垃圾回收之前，首先<mark>需要区分出内存中哪些是存活对象，哪些是已经死亡的对象</mark>。只有被标记为己经死亡的对象，GC 才会在执行垃圾回收时，释放掉其所占用的内存空间，因此这个过程我们可以称为<mark>垃圾标记阶段</mark>。</p><p>那么在 JVM 中究竟是如何标记一个死亡对象呢？简单来说，当一个对象已经不再被任何的存活对象继续引用时，就可以宣判为已经死亡。</p><p>判断对象存活一般有两种方式：<mark>引用计数算法</mark>和<mark>可达性分析算法</mark>。</p><h3 id=1121-标记阶段引用计数算法><a href=#1121-%e6%a0%87%e8%ae%b0%e9%98%b6%e6%ae%b5%e5%bc%95%e7%94%a8%e8%ae%a1%e6%95%b0%e7%ae%97%e6%b3%95 class=header-anchor>#</a>
11.2.1. 标记阶段：引用计数算法</h3><h4 id=方式一引用计数算法><a href=#%e6%96%b9%e5%bc%8f%e4%b8%80%e5%bc%95%e7%94%a8%e8%ae%a1%e6%95%b0%e7%ae%97%e6%b3%95 class=header-anchor>#</a>
方式一：引用计数算法</h4><p>引用计数算法（Reference Counting）比较简单，对每个对象保存一个整型的<mark>引用计数器属性。用于记录对象被引用的情况。</mark></p><p>对于一个对象 A，只要有任何一个对象引用了 A，则 A 的引用计数器就加 1；当引用失效时，引用计数器就减 1。只要对象 A 的引用计数器的值为 0，即表示对象 A 不可能再被使用，可进行回收。</p><p>优点：<mark>实现简单，垃圾对象便于辨识；判定效率高，回收没有延迟性。</mark></p><p>缺点：</p><ul><li>它需要单独的字段存储计数器，这样的做法增加了<mark>存储空间的开销</mark>。</li><li>每次赋值都需要更新计数器，伴随着加法和减法操作，这增加了<mark>时间开销</mark>。</li><li>引用计数器有一个严重的问题，即<mark>无法处理循环引用</mark>的情况。这是一条致命缺陷，导致在 Java 的垃圾回收器中没有使用这类算法。</li></ul><h4 id=循环引用><a href=#%e5%be%aa%e7%8e%af%e5%bc%95%e7%94%a8 class=header-anchor>#</a>
循环引用</h4><p>当 p 的指针断开的时候，内部的引用形成一个循环，这就是循环引用</p><p><img src=https://logan.1357810.xyz/img/20220422/152946273-92ad159da8.png width=900 height=600 loading=lazy decoding=async alt=image-20200712102205795 class="gallery-image link-image" data-flex-grow=20 data-flex-basis=20px></p><p><strong>举例</strong></p><p>测试 Java 中是否采用的是引用计数算法</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-2-1><a class=lnlinks href=#hl-2-1> 1</a>
</span><span class=lnt id=hl-2-2><a class=lnlinks href=#hl-2-2> 2</a>
</span><span class=lnt id=hl-2-3><a class=lnlinks href=#hl-2-3> 3</a>
</span><span class=lnt id=hl-2-4><a class=lnlinks href=#hl-2-4> 4</a>
</span><span class=lnt id=hl-2-5><a class=lnlinks href=#hl-2-5> 5</a>
</span><span class=lnt id=hl-2-6><a class=lnlinks href=#hl-2-6> 6</a>
</span><span class=lnt id=hl-2-7><a class=lnlinks href=#hl-2-7> 7</a>
</span><span class=lnt id=hl-2-8><a class=lnlinks href=#hl-2-8> 8</a>
</span><span class=lnt id=hl-2-9><a class=lnlinks href=#hl-2-9> 9</a>
</span><span class=lnt id=hl-2-10><a class=lnlinks href=#hl-2-10>10</a>
</span><span class=lnt id=hl-2-11><a class=lnlinks href=#hl-2-11>11</a>
</span><span class=lnt id=hl-2-12><a class=lnlinks href=#hl-2-12>12</a>
</span><span class=lnt id=hl-2-13><a class=lnlinks href=#hl-2-13>13</a>
</span><span class=lnt id=hl-2-14><a class=lnlinks href=#hl-2-14>14</a>
</span><span class=lnt id=hl-2-15><a class=lnlinks href=#hl-2-15>15</a>
</span><span class=lnt id=hl-2-16><a class=lnlinks href=#hl-2-16>16</a>
</span><span class=lnt id=hl-2-17><a class=lnlinks href=#hl-2-17>17</a>
</span><span class=lnt id=hl-2-18><a class=lnlinks href=#hl-2-18>18</a>
</span><span class=lnt id=hl-2-19><a class=lnlinks href=#hl-2-19>19</a>
</span><span class=lnt id=hl-2-20><a class=lnlinks href=#hl-2-20>20</a>
</span><span class=lnt id=hl-2-21><a class=lnlinks href=#hl-2-21>21</a>
</span><span class=lnt id=hl-2-22><a class=lnlinks href=#hl-2-22>22</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=kd>public</span><span class=w> </span><span class=kd>class</span> <span class=nc>RefCountGC</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=c1>// 这个成员属性的唯一作用就是占用一点内存</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=kd>private</span><span class=w> </span><span class=kt>byte</span><span class=o>[]</span><span class=w> </span><span class=n>bigSize</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=k>new</span><span class=w> </span><span class=kt>byte</span><span class=o>[</span><span class=n>5</span><span class=o>*</span><span class=n>1024</span><span class=o>*</span><span class=n>1024</span><span class=o>]</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=c1>// 引用</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=n>Object</span><span class=w> </span><span class=n>reference</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=kc>null</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=kd>public</span><span class=w> </span><span class=kd>static</span><span class=w> </span><span class=kt>void</span><span class=w> </span><span class=nf>main</span><span class=p>(</span><span class=n>String</span><span class=o>[]</span><span class=w> </span><span class=n>args</span><span class=p>)</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=n>RefCountGC</span><span class=w> </span><span class=n>obj1</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=k>new</span><span class=w> </span><span class=n>RefCountGC</span><span class=p>();</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=n>RefCountGC</span><span class=w> </span><span class=n>obj2</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=k>new</span><span class=w> </span><span class=n>RefCountGC</span><span class=p>();</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=n>obj1</span><span class=p>.</span><span class=na>reference</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>obj2</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=n>obj2</span><span class=p>.</span><span class=na>reference</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>obj1</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=n>obj1</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=kc>null</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=n>obj2</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=kc>null</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=c1>// 显示的执行垃圾收集行为</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=c1>// 这里发生GC，obj1和obj2是否被回收？</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=n>System</span><span class=p>.</span><span class=na>gc</span><span class=p>();</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=c1>// 运行结果</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=nl>PSYoungGen</span><span class=p>:</span><span class=w> </span><span class=n>15490K</span><span class=o>-&gt;</span><span class=n>808K</span><span class=p>(</span><span class=n>76288K</span><span class=p>)</span><span class=o>]</span><span class=w> </span><span class=n>15490K</span><span class=o>-&gt;</span><span class=n>816K</span><span class=p>(</span><span class=n>251392K</span><span class=p>)</span><span class=w>
</span></span></span></code></pre></td></tr></table></div></div><p>上述进行了 GC 收集的行为，所以可以证明 JVM 中采用的不是引用计数器的算法</p><p><img src=https://logan.1357810.xyz/img/20220422/152946273-544bea692e.png width=900 height=600 loading=lazy decoding=async alt=image-20200712103230349 class="gallery-image link-image" data-flex-grow=20 data-flex-basis=20px></p><h4 id=小结><a href=#%e5%b0%8f%e7%bb%93 class=header-anchor>#</a>
小结</h4><p>引用计数算法，是很多语言的资源回收选择，例如因人工智能而更加火热的 Python，它更是同时支持引用计数和垃圾收集机制。</p><p>具体哪种最优是要看场景的，业界有大规模实践中仅保留引用计数机制，以提高吞吐量的尝试。</p><p>Java 并没有选择引用计数，是因为其存在一个基本的难题，也就是很难处理循环引用关系。</p><p>Python 如何解决循环引用？</p><ul><li>手动解除：很好理解，就是在合适的时机，解除引用关系。 使用弱引用 weakref，weakref 是 Python 提供的标准库，旨在解决循环引用。</li></ul><h3 id=1122-标记阶段可达性分析算法><a href=#1122-%e6%a0%87%e8%ae%b0%e9%98%b6%e6%ae%b5%e5%8f%af%e8%be%be%e6%80%a7%e5%88%86%e6%9e%90%e7%ae%97%e6%b3%95 class=header-anchor>#</a>
11.2.2. 标记阶段：可达性分析算法</h3><h4 id=可达性分析算法根搜索算法追踪性垃圾收集><a href=#%e5%8f%af%e8%be%be%e6%80%a7%e5%88%86%e6%9e%90%e7%ae%97%e6%b3%95%e6%a0%b9%e6%90%9c%e7%b4%a2%e7%ae%97%e6%b3%95%e8%bf%bd%e8%b8%aa%e6%80%a7%e5%9e%83%e5%9c%be%e6%94%b6%e9%9b%86 class=header-anchor>#</a>
可达性分析算法（根搜索算法、追踪性垃圾收集）</h4><p>相对于引用计数算法而言，可达性分析算法不仅同样具备实现简单和执行高效等特点，更重要的是该算法可以有效地<mark>解决在引用计数算法中循环引用的问题，防止内存泄漏的发生</mark>。</p><p>相较于引用计数算法，这里的可达性分析就是 Java、C#选择的。这种类型的垃圾收集通常也叫作<mark>追踪性垃圾收集（Tracing Garbage Collection）</mark></p><p>所谓"GCRoots”根集合就是一组必须活跃的引用。</p><h4 id=基本思路><a href=#%e5%9f%ba%e6%9c%ac%e6%80%9d%e8%b7%af class=header-anchor>#</a>
基本思路</h4><ul><li>可达性分析算法是以根对象集合（GCRoots）为起始点，按照从上至下的方式<mark>搜索被根对象集合所连接的目标对象是否可达</mark>。</li><li>使用可达性分析算法后，内存中的存活对象都会被根对象集合直接或间接连接着，搜索所走过的路径称为<mark>引用链（Reference Chain）</mark></li><li>如果目标对象没有任何引用链相连，则是不可达的，就意味着该对象己经死亡，可以标记为垃圾对象。</li><li>在可达性分析算法中，只有能够被根对象集合直接或者间接连接的对象才是存活对象。</li></ul><p><img src=https://logan.1357810.xyz/img/20220422/152946273-ca9c438327.png width=900 height=600 loading=lazy decoding=async alt=image-20210511195540451 class="gallery-image link-image" data-flex-grow=20 data-flex-basis=20px></p><p><strong>在 Java 语言中，GC Roots 包括以下几类元素：</strong></p><ul><li>虚拟机栈中引用的对象<ul><li>比如：各个线程被调用的方法中使用到的参数、局部变量等。</li></ul></li><li>本地方法栈内 JNI（通常说的本地方法）引用的对象</li><li>方法区中类静态属性引用的对象<ul><li>比如：Java 类的引用类型静态变量</li></ul></li><li>方法区中常量引用的对象<ul><li>比如：字符串常量池（String Table）里的引用</li></ul></li><li>所有被同步锁 synchronized 持有的对象</li><li>Java 虚拟机内部的引用。<ul><li>基本数据类型对应的 Class 对象，一些常驻的异常对象（如：NullPointerException、OutOfMemoryError），系统类加载器。</li></ul></li><li>反映 java 虚拟机内部情况的 JMXBean、JVMTI 中注册的回调、本地代码缓存等。</li></ul><p><img src=https://logan.1357810.xyz/img/20220422/152946273-e1ef9f83c3.png width=900 height=600 loading=lazy decoding=async alt=image-20200712104622677 class="gallery-image link-image" data-flex-grow=20 data-flex-basis=20px></p><p>除了这些固定的 GC Roots 集合以外，根据用户所选用的垃圾收集器以及当前回收的内存区域不同，还可以有其他对象“临时性”地加入，共同构成完整 GC Roots 集合。比如：分代收集和局部回收（PartialGC）。</p><p>如果只针对 Java 堆中的某一块区域进行垃圾回收（比如：典型的只针对新生代），必须考虑到内存区域是虚拟机自己的实现细节，更不是孤立封闭的，这个区域的对象完全有可能被其他区域的对象所引用，这时候就需要一并将关联的区域对象也加入 GCRoots 集合中去考虑，才能保证可达性分析的准确性。</p><p>小技巧：由于 Root 采用栈方式存放变量和指针，所以如果一个指针，它保存了堆内存里面的对象，但是自己又不存放在堆内存里面，那它就是一个 Root。</p><p><strong>注意</strong></p><p>如果要使用可达性分析算法来判断内存是否可回收，那么分析工作必须在一个能保障一致性的快照中进行。这点不满足的话分析结果的准确性就无法保证。</p><p>这点也是导致 GC 进行时必须“stop The World”的一个重要原因。</p><ul><li>即使是号称（几乎）不会发生停顿的 CMS 收集器中，枚举根节点时也是必须要停顿的。</li></ul><h3 id=1123-对象的-finalization-机制><a href=#1123-%e5%af%b9%e8%b1%a1%e7%9a%84-finalization-%e6%9c%ba%e5%88%b6 class=header-anchor>#</a>
11.2.3. 对象的 finalization 机制</h3><p>Java 语言提供了对象终止（finalization）机制来允许开发人员提供<mark>对象被销毁之前的自定义处理逻辑</mark>。</p><p>当垃圾回收器发现没有引用指向一个对象，即：垃圾回收此对象之前，总会先调用这个对象的 finalize()方法。</p><p>finalize() 方法允许在子类中被重写，<mark>用于在对象被回收时进行资源释放</mark>。通常在这个方法中进行一些资源释放和清理的工作，比如关闭文件、套接字和数据库连接等。</p><p>永远不要主动调用某个对象的 finalize()方法 I 应该交给垃圾回收机制调用。理由包括下面三点：</p><ul><li>在 finalize()时可能会导致对象复活。</li><li>finalize()方法的执行时间是没有保障的，它完全由 GC 线程决定，极端情况下，若不发生 GC，则 finalize()方法将没有执行机会。</li><li>一个糟糕的 finalize()会严重影响 Gc 的性能。</li></ul><p>从功能上来说，finalize()方法与 C++中的析构函数比较相似，但是 Java 采用的是基于垃圾回收器的自动内存管理机制，所以 finalize()方法在本质上不同于 C++中的析构函数。</p><p>由于 finalize()方法的存在，<mark>虚拟机中的对象一般处于三种可能的状态</mark>。</p><h4 id=生存还是死亡><a href=#%e7%94%9f%e5%ad%98%e8%bf%98%e6%98%af%e6%ad%bb%e4%ba%a1 class=header-anchor>#</a>
生存还是死亡？</h4><p>如果从所有的根节点都无法访问到某个对象，说明对象己经不再使用了。一般来说，此对象需要被回收。但事实上，也并非是“非死不可”的，这时候它们暂时处于“缓刑”阶段。<mark>一个无法触及的对象有可能在某一个条件下“复活”自己</mark>，如果这样，那么对它的回收就是不合理的，为此，定义虚拟机中的对象可能的三种状态。如下：</p><ul><li><mark>可触及的</mark>：从根节点开始，可以到达这个对象。</li><li><mark>可复活的</mark>：对象的所有引用都被释放，但是对象有可能在 finalize()中复活。</li><li><mark>不可触及的</mark>：对象的 finalize()被调用，并且没有复活，那么就会进入不可触及状态。不可触及的对象不可能被复活，因为<mark>finalize()只会被调用一次</mark>。</li></ul><p>以上 3 种状态中，是由于 inalize()方法的存在，进行的区分。只有在对象不可触及时才可以被回收。</p><h4 id=具体过程><a href=#%e5%85%b7%e4%bd%93%e8%bf%87%e7%a8%8b class=header-anchor>#</a>
具体过程</h4><p>判定一个对象 objA 是否可回收，至少要经历两次标记过程：</p><ol><li>如果对象 objA 到 GC Roots 没有引用链，则进行第一次标记。</li><li>进行筛选，判断此对象是否有必要执行 finalize()方法</li><li>如果对象 objA 没有重写 finalize()方法，或者 finalize()方法已经被虚拟机调用过，则虚拟机视为“没有必要执行”，objA 被判定为不可触及的。</li><li>如果对象 objA 重写了 finalize()方法，且还未执行过，那么 objA 会被插入到 F-Queue 队列中，由一个虚拟机自动创建的、低优先级的 Finalizer 线程触发其 finalize()方法执行。</li><li><mark>finalize()方法是对象逃脱死亡的最后机会</mark>，稍后 GC 会对 F-Queue 队列中的对象进行第二次标记。如果 objA 在 finalize()方法中与引用链上的任何一个对象建立了联系，那么在第二次标记时，objA 会被移出“即将回收”集合。之后，对象会再次出现没有引用存在的情况。在这个情况下，finalize 方法不会被再次调用，对象会直接变成不可触及的状态，也就是说，一个对象的 finalize 方法只会被调用一次。</li></ol><p><strong>举例</strong></p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-3-1><a class=lnlinks href=#hl-3-1> 1</a>
</span><span class=lnt id=hl-3-2><a class=lnlinks href=#hl-3-2> 2</a>
</span><span class=lnt id=hl-3-3><a class=lnlinks href=#hl-3-3> 3</a>
</span><span class=lnt id=hl-3-4><a class=lnlinks href=#hl-3-4> 4</a>
</span><span class=lnt id=hl-3-5><a class=lnlinks href=#hl-3-5> 5</a>
</span><span class=lnt id=hl-3-6><a class=lnlinks href=#hl-3-6> 6</a>
</span><span class=lnt id=hl-3-7><a class=lnlinks href=#hl-3-7> 7</a>
</span><span class=lnt id=hl-3-8><a class=lnlinks href=#hl-3-8> 8</a>
</span><span class=lnt id=hl-3-9><a class=lnlinks href=#hl-3-9> 9</a>
</span><span class=lnt id=hl-3-10><a class=lnlinks href=#hl-3-10>10</a>
</span><span class=lnt id=hl-3-11><a class=lnlinks href=#hl-3-11>11</a>
</span><span class=lnt id=hl-3-12><a class=lnlinks href=#hl-3-12>12</a>
</span><span class=lnt id=hl-3-13><a class=lnlinks href=#hl-3-13>13</a>
</span><span class=lnt id=hl-3-14><a class=lnlinks href=#hl-3-14>14</a>
</span><span class=lnt id=hl-3-15><a class=lnlinks href=#hl-3-15>15</a>
</span><span class=lnt id=hl-3-16><a class=lnlinks href=#hl-3-16>16</a>
</span><span class=lnt id=hl-3-17><a class=lnlinks href=#hl-3-17>17</a>
</span><span class=lnt id=hl-3-18><a class=lnlinks href=#hl-3-18>18</a>
</span><span class=lnt id=hl-3-19><a class=lnlinks href=#hl-3-19>19</a>
</span><span class=lnt id=hl-3-20><a class=lnlinks href=#hl-3-20>20</a>
</span><span class=lnt id=hl-3-21><a class=lnlinks href=#hl-3-21>21</a>
</span><span class=lnt id=hl-3-22><a class=lnlinks href=#hl-3-22>22</a>
</span><span class=lnt id=hl-3-23><a class=lnlinks href=#hl-3-23>23</a>
</span><span class=lnt id=hl-3-24><a class=lnlinks href=#hl-3-24>24</a>
</span><span class=lnt id=hl-3-25><a class=lnlinks href=#hl-3-25>25</a>
</span><span class=lnt id=hl-3-26><a class=lnlinks href=#hl-3-26>26</a>
</span><span class=lnt id=hl-3-27><a class=lnlinks href=#hl-3-27>27</a>
</span><span class=lnt id=hl-3-28><a class=lnlinks href=#hl-3-28>28</a>
</span><span class=lnt id=hl-3-29><a class=lnlinks href=#hl-3-29>29</a>
</span><span class=lnt id=hl-3-30><a class=lnlinks href=#hl-3-30>30</a>
</span><span class=lnt id=hl-3-31><a class=lnlinks href=#hl-3-31>31</a>
</span><span class=lnt id=hl-3-32><a class=lnlinks href=#hl-3-32>32</a>
</span><span class=lnt id=hl-3-33><a class=lnlinks href=#hl-3-33>33</a>
</span><span class=lnt id=hl-3-34><a class=lnlinks href=#hl-3-34>34</a>
</span><span class=lnt id=hl-3-35><a class=lnlinks href=#hl-3-35>35</a>
</span><span class=lnt id=hl-3-36><a class=lnlinks href=#hl-3-36>36</a>
</span><span class=lnt id=hl-3-37><a class=lnlinks href=#hl-3-37>37</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=kd>public</span><span class=w> </span><span class=kd>class</span> <span class=nc>CanReliveObj</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=c1>// 类变量，属于GC Roots的一部分</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=kd>public</span><span class=w> </span><span class=kd>static</span><span class=w> </span><span class=n>CanReliveObj</span><span class=w> </span><span class=n>canReliveObj</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=nd>@Override</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=kd>protected</span><span class=w> </span><span class=kt>void</span><span class=w> </span><span class=nf>finalize</span><span class=p>()</span><span class=w> </span><span class=kd>throws</span><span class=w> </span><span class=n>Throwable</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=kd>super</span><span class=p>.</span><span class=na>finalize</span><span class=p>();</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=n>System</span><span class=p>.</span><span class=na>out</span><span class=p>.</span><span class=na>println</span><span class=p>(</span><span class=s>&#34;调用当前类重写的finalize()方法&#34;</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=n>canReliveObj</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=k>this</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=kd>public</span><span class=w> </span><span class=kd>static</span><span class=w> </span><span class=kt>void</span><span class=w> </span><span class=nf>main</span><span class=p>(</span><span class=n>String</span><span class=o>[]</span><span class=w> </span><span class=n>args</span><span class=p>)</span><span class=w> </span><span class=kd>throws</span><span class=w> </span><span class=n>InterruptedException</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=n>canReliveObj</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=k>new</span><span class=w> </span><span class=n>CanReliveObj</span><span class=p>();</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=n>canReliveObj</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=kc>null</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=n>System</span><span class=p>.</span><span class=na>gc</span><span class=p>();</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=n>System</span><span class=p>.</span><span class=na>out</span><span class=p>.</span><span class=na>println</span><span class=p>(</span><span class=s>&#34;-----------------第一次gc操作------------&#34;</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=c1>// 因为Finalizer线程的优先级比较低，暂停2秒，以等待它</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=n>Thread</span><span class=p>.</span><span class=na>sleep</span><span class=p>(</span><span class=n>2000</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=k>if</span><span class=w> </span><span class=p>(</span><span class=n>canReliveObj</span><span class=w> </span><span class=o>==</span><span class=w> </span><span class=kc>null</span><span class=p>)</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>            </span><span class=n>System</span><span class=p>.</span><span class=na>out</span><span class=p>.</span><span class=na>println</span><span class=p>(</span><span class=s>&#34;obj is dead&#34;</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=p>}</span><span class=w> </span><span class=k>else</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>            </span><span class=n>System</span><span class=p>.</span><span class=na>out</span><span class=p>.</span><span class=na>println</span><span class=p>(</span><span class=s>&#34;obj is still alive&#34;</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=n>System</span><span class=p>.</span><span class=na>out</span><span class=p>.</span><span class=na>println</span><span class=p>(</span><span class=s>&#34;-----------------第二次gc操作------------&#34;</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=n>canReliveObj</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=kc>null</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=n>System</span><span class=p>.</span><span class=na>gc</span><span class=p>();</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=c1>// 下面代码和上面代码是一样的，但是 canReliveObj却自救失败了</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=n>Thread</span><span class=p>.</span><span class=na>sleep</span><span class=p>(</span><span class=n>2000</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=k>if</span><span class=w> </span><span class=p>(</span><span class=n>canReliveObj</span><span class=w> </span><span class=o>==</span><span class=w> </span><span class=kc>null</span><span class=p>)</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>            </span><span class=n>System</span><span class=p>.</span><span class=na>out</span><span class=p>.</span><span class=na>println</span><span class=p>(</span><span class=s>&#34;obj is dead&#34;</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=p>}</span><span class=w> </span><span class=k>else</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>            </span><span class=n>System</span><span class=p>.</span><span class=na>out</span><span class=p>.</span><span class=na>println</span><span class=p>(</span><span class=s>&#34;obj is still alive&#34;</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>}</span><span class=w>
</span></span></span></code></pre></td></tr></table></div></div><p>运行结果</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-4-1><a class=lnlinks href=#hl-4-1>1</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>obj is dead
</span></span></code></pre></td></tr></table></div></div><p>在第一次 GC 时，执行了 finalize 方法，但 finalize()方法只会被调用一次，所以第二次该对象被 GC 标记并清除了。</p><h3 id=1124-mat-与-jprofiler-的-gc-roots-溯源><a href=#1124-mat-%e4%b8%8e-jprofiler-%e7%9a%84-gc-roots-%e6%ba%af%e6%ba%90 class=header-anchor>#</a>
11.2.4. MAT 与 JProfiler 的 GC Roots 溯源</h3><h4 id=mat-是什么><a href=#mat-%e6%98%af%e4%bb%80%e4%b9%88 class=header-anchor>#</a>
MAT 是什么？</h4><p>MAT 是 Memory Analyzer 的简称，它是一款功能强大的 Java 堆内存分析器。用于查找内存泄漏以及查看内存消耗情况。</p><p>MAT 是基于 Eclipse 开发的，是一款免费的性能分析工具。</p><p>大家可以在 <a class=link href=http://www.eclipse.org/mat/ target=_blank rel=noopener>http://www.eclipse.org/mat/
<span style=white-space:nowrap><svg width=".7em" height=".7em" viewBox="0 0 21 21" xmlns="http://www.w3.org/2000/svg"><path d="m13 3 3.293 3.293-7 7 1.414 1.414 7-7L21 11V3z" fill="currentcolor"/><path d="M19 19H5V5h7l-2-2H5c-1.103.0-2 .897-2 2v14c0 1.103.897 2 2 2h14c1.103.0 2-.897 2-2v-5l-2-2v7z" fill="currentcolor"/></span>
</a>下载并使用 MAT</p><h4 id=获取-dump-文件><a href=#%e8%8e%b7%e5%8f%96-dump-%e6%96%87%e4%bb%b6 class=header-anchor>#</a>
获取 dump 文件</h4><h5 id=方式一命令行使用-jmap><a href=#%e6%96%b9%e5%bc%8f%e4%b8%80%e5%91%bd%e4%bb%a4%e8%a1%8c%e4%bd%bf%e7%94%a8-jmap class=header-anchor>#</a>
方式一：命令行使用 jmap</h5><p><img src=https://logan.1357810.xyz/img/20220422/152946273-b016c2e66e.png width=900 height=600 loading=lazy decoding=async alt=image-20210512105418987 class="gallery-image link-image" data-flex-grow=20 data-flex-basis=20px></p><h5 id=方式二使用-jvisualvm-导出><a href=#%e6%96%b9%e5%bc%8f%e4%ba%8c%e4%bd%bf%e7%94%a8-jvisualvm-%e5%af%bc%e5%87%ba class=header-anchor>#</a>
方式二：使用 JVisualVM 导出</h5><p>捕获的 heap dump 文件是一个临时文件，关闭 JVisualVM 后自动删除，若要保留，需要将其另存为文件。</p><p>可通过以下方法捕获 heap dump：</p><ul><li><p>在左侧“Application"（应用程序）子窗口中右击相应的应用程序，选择 Heap Dump（堆 Dump）。</p></li><li><p>在 Monitor（监视）子标签页中点击 Heap Dump（堆 Dump）按钮。</p></li></ul><p>本地应用程序的 Heap dumps 作为应用程序标签页的一个子标签页打开。同时，heap dump 在左侧的 Application（应用程序）栏中对应一个含有时间戳的节点。</p><p>右击这个节点选择 save as（另存为）即可将 heap dump 保存到本地。</p><h5 id=方式三使用-mat-打开-dump-文件><a href=#%e6%96%b9%e5%bc%8f%e4%b8%89%e4%bd%bf%e7%94%a8-mat-%e6%89%93%e5%bc%80-dump-%e6%96%87%e4%bb%b6 class=header-anchor>#</a>
方式三：使用 MAT 打开 Dump 文件</h5><p><img src=https://logan.1357810.xyz/img/20220422/152946273-a6c601736d.png width=900 height=600 loading=lazy decoding=async alt=image-20200712112512720 class="gallery-image link-image" data-flex-grow=20 data-flex-basis=20px></p><h4 id=jprofiler-的-gc-roots-溯源><a href=#jprofiler-%e7%9a%84-gc-roots-%e6%ba%af%e6%ba%90 class=header-anchor>#</a>
JProfiler 的 GC Roots 溯源</h4><p>我们在实际的开发中，一般不会查找全部的 GC Roots，可能只是查找某个对象的整个链路，或者称为 GC Roots 溯源，这个时候，我们就可以使用 JProfiler</p><p><img src=https://logan.1357810.xyz/img/20220422/152946273-ed861d007b.png width=900 height=600 loading=lazy decoding=async alt=image-20200712113256075 class="gallery-image link-image" data-flex-grow=20 data-flex-basis=20px></p><h3 id=1125-清除阶段标记-清除算法><a href=#1125-%e6%b8%85%e9%99%a4%e9%98%b6%e6%ae%b5%e6%a0%87%e8%ae%b0-%e6%b8%85%e9%99%a4%e7%ae%97%e6%b3%95 class=header-anchor>#</a>
11.2.5. 清除阶段：标记-清除算法</h3><p>当成功区分出内存中存活对象和死亡对象后，GC 接下来的任务就是执行垃圾回收，释放掉无用对象所占用的内存空间，以便有足够的可用内存空间为新对象分配内存。</p><p>目前在 JVM 中比较常见的三种垃圾收集算法是<mark>标记一清除算法（Mark-Sweep）、复制算法（copying）、标记-压缩算法（Mark-Compact）</mark></p><h4 id=标记-清除算法mark-sweep><a href=#%e6%a0%87%e8%ae%b0-%e6%b8%85%e9%99%a4%e7%ae%97%e6%b3%95mark-sweep class=header-anchor>#</a>
标记-清除算法（Mark-Sweep）</h4><p>标记-清除算法（Mark-Sweep）是一种非常基础和常见的垃圾收集算法，该算法被 J.McCarthy 等人在 1960 年提出并并应用于 Lisp 语言。</p><h4 id=执行过程><a href=#%e6%89%a7%e8%a1%8c%e8%bf%87%e7%a8%8b class=header-anchor>#</a>
执行过程</h4><p>当堆中的有效内存空间（available memory）被耗尽的时候，就会停止整个程序（也被称为 stop the world），然后进行两项工作，第一项则是标记，第二项则是清除</p><ul><li><p><mark>标记</mark>：Collector 从引用根节点开始遍历，标记所有被引用的对象。一般是在对象的 Header(对象头) 中记录为可达对象。</p></li><li><p><mark>清除</mark>：Collector 对堆内存从头到尾进行线性的遍历，如果发现某个对象在其 Header 中没有标记为可达对象，则将其回收</p></li></ul><p><img src=https://logan.1357810.xyz/img/20220422/152946273-c4b727d1a5.png width=900 height=600 loading=lazy decoding=async alt=image-20200712150935078 class="gallery-image link-image" data-flex-grow=20 data-flex-basis=20px></p><h4 id=缺点><a href=#%e7%bc%ba%e7%82%b9 class=header-anchor>#</a>
缺点</h4><ul><li>标记清除算法的效率不算高</li><li>在进行 GC 的时候，需要停止整个应用程序，用户体验较差</li><li>这种方式清理出来的空闲内存是不连续的，产生内碎片，需要维护一个空闲列表</li></ul><h4 id=何为清除><a href=#%e4%bd%95%e4%b8%ba%e6%b8%85%e9%99%a4 class=header-anchor>#</a>
何为清除？</h4><p><mark>这里所谓的清除并不是真的置空，而是把需要清除的对象地址保存在空闲的地址列表里。下次有新对象需要加载时，判断垃圾的位置空间是否够，如果够，就存放覆盖原有的地址。</mark></p><h3 id=1126-清除阶段复制算法><a href=#1126-%e6%b8%85%e9%99%a4%e9%98%b6%e6%ae%b5%e5%a4%8d%e5%88%b6%e7%ae%97%e6%b3%95 class=header-anchor>#</a>
11.2.6. 清除阶段：复制算法</h3><h4 id=复制copying算法><a href=#%e5%a4%8d%e5%88%b6copying%e7%ae%97%e6%b3%95 class=header-anchor>#</a>
复制（Copying）算法</h4><p>为了解决标记-清除算法在垃圾收集效率方面的缺陷，M.L.Minsky 于 1963 年发表了著名的论文，“使用双存储区的 Lisp 语言垃圾收集器 CA LISP Garbage Collector Algorithm Using Serial Secondary Storage）”。M.L.Minsky 在该论文中描述的算法被人们称为复制（Copying）算法，它也被 M.L.Minsky 本人成功地引入到了 Lisp 语言的一个实现版本中。</p><h4 id=核心思想><a href=#%e6%a0%b8%e5%bf%83%e6%80%9d%e6%83%b3 class=header-anchor>#</a>
核心思想</h4><p>将活着的内存空间分为两块，每次只使用其中一块，在垃圾回收时将正在使用的内存中的存活对象复制到未被使用的内存块中，之后清除正在使用的内存块中的所有对象，交换两个内存的角色，最后完成垃圾回收</p><p><img src=https://logan.1357810.xyz/img/20220422/152946273-9eda350f6e.png width=900 height=600 loading=lazy decoding=async alt=image-20200712151916991 class="gallery-image link-image" data-flex-grow=20 data-flex-basis=20px></p><h4 id=优点><a href=#%e4%bc%98%e7%82%b9 class=header-anchor>#</a>
优点</h4><ul><li>没有标记和清除过程，实现简单，运行高效</li><li>复制过去以后保证空间的连续性，不会出现“碎片”问题。</li></ul><h4 id=缺点-1><a href=#%e7%bc%ba%e7%82%b9-1 class=header-anchor>#</a>
缺点</h4><ul><li>此算法的缺点也是很明显的，就是需要两倍的内存空间。</li><li>对于 G1 这种分拆成为大量 region 的 GC，复制而不是移动，意味着 GC 需要维护 region 之间对象引用关系，不管是内存占用或者时间开销也不小；句柄池和hotspot中用的直接指针的优缺点</li></ul><h4 id=特别的><a href=#%e7%89%b9%e5%88%ab%e7%9a%84 class=header-anchor>#</a>
特别的</h4><p>如果系统中的存活的对象很多，复制算法就不太理想。复制算法需要复制的存活对象数量并不会太大，或者说非常低才行，所以基本用在新生代这种朝生夕死的垃圾清理，并不会用在老年代中</p><h4 id=应用场景><a href=#%e5%ba%94%e7%94%a8%e5%9c%ba%e6%99%af class=header-anchor>#</a>
应用场景</h4><p>在新生代，对常规应用的垃圾回收，一次通常可以回收 70% - 99% 的内存空间。回收性价比很高。所以现在的商业虚拟机都是用这种收集算法回收新生代。</p><p><img src=https://logan.1357810.xyz/img/20220422/152946273-2b189ec901.png width=900 height=600 loading=lazy decoding=async alt=image-20200712152847218 class="gallery-image link-image" data-flex-grow=20 data-flex-basis=20px></p><h3 id=1127-清除阶段标记-压缩整理算法><a href=#1127-%e6%b8%85%e9%99%a4%e9%98%b6%e6%ae%b5%e6%a0%87%e8%ae%b0-%e5%8e%8b%e7%bc%a9%e6%95%b4%e7%90%86%e7%ae%97%e6%b3%95 class=header-anchor>#</a>
11.2.7. 清除阶段：标记-压缩（整理）算法</h3><h4 id=标记-压缩或标记-整理mark-compact算法><a href=#%e6%a0%87%e8%ae%b0-%e5%8e%8b%e7%bc%a9%e6%88%96%e6%a0%87%e8%ae%b0-%e6%95%b4%e7%90%86mark-compact%e7%ae%97%e6%b3%95 class=header-anchor>#</a>
标记-压缩（或标记-整理、Mark-Compact）算法</h4><p>复制算法的高效性是建立在存活对象少、垃圾对象多的前提下的。这种情况在新生代经常发生，但是在老年代，更常见的情况是大部分对象都是存活对象。如果依然使用复制算法，由于存活对象较多，复制的成本也将很高。因此，基于老年代垃圾回收的特性，需要使用其他的算法。</p><p>标记一清除算法的确可以应用在老年代中，但是该算法不仅执行效率低下，而且在执行完内存回收后还会产生内存碎片，所以 JVM 的设计者需要在此基础之上进行改进。标记-压缩（Mark-Compact）算法由此诞生。</p><p>1970 年前后，G.L.Steele、C.J.Chene 和 D.s.Wise 等研究者发布标记-压缩算法。在许多现代的垃圾收集器中，人们都使用了标记-压缩算法或其改进版本。</p><h4 id=执行过程-1><a href=#%e6%89%a7%e8%a1%8c%e8%bf%87%e7%a8%8b-1 class=header-anchor>#</a>
执行过程</h4><ol><li><p>第一阶段和标记清除算法一样，从根节点开始标记所有被引用对象</p></li><li><p>第二阶段将所有的存活对象压缩到内存的一端，按顺序排放。</p></li><li><p>之后，清理边界外所有的空间。</p></li></ol><p><img src=https://logan.1357810.xyz/img/20220422/152946273-f7e2df5a78.png width=900 height=600 loading=lazy decoding=async alt=image-20200712153236508 class="gallery-image link-image" data-flex-grow=20 data-flex-basis=20px></p><p>标记-压缩算法的最终效果等同于标记-清除算法执行完成后，再进行一次内存碎片整理，因此，也可以把它称为<mark>标记-清除-压缩（Mark-Sweep-Compact）算法</mark>。</p><p>二者的本质差异在于标记-清除算法是一种<mark>非移动式的回收算法</mark>，标记-压缩是移动式的。是否移动回收后的存活对象是一项优缺点并存的风险决策。可以看到，标记的存活对象将会被整理，按照内存地址依次排列，而未被标记的内存会被清理掉。如此一来，当我们需要给新对象分配内存时，JVM 只需要持有一个内存的起始地址即可，这比维护一个空闲列表显然少了许多开销。</p><h4 id=指针碰撞bump-the-pointer><a href=#%e6%8c%87%e9%92%88%e7%a2%b0%e6%92%9ebump-the-pointer class=header-anchor>#</a>
指针碰撞（Bump the Pointer）</h4><p>如果内存空间以规整和有序的方式分布，即已用和未用的内存都各自一边，彼此之间维系着一个记录下一次分配起始点的标记指针，当为新对象分配内存时，只需要通过修改指针的偏移量将新对象分配在第一个空闲内存位置上，这种分配方式就叫做指针碰撞（Bump tHe Pointer）。</p><h4 id=优点-1><a href=#%e4%bc%98%e7%82%b9-1 class=header-anchor>#</a>
优点</h4><ul><li>消除了标记-清除算法当中，内存区域分散的缺点，我们需要给新对象分配内存时，JVM 只需要持有一个内存的起始地址即可。</li><li>消除了复制算法当中，内存减半的高额代价。</li></ul><h4 id=缺点-2><a href=#%e7%bc%ba%e7%82%b9-2 class=header-anchor>#</a>
缺点</h4><ul><li>从效率上来说，标记-整理算法要低于复制算法。</li><li>移动对象的同时，如果对象被其他对象引用，则还需要调整引用的地址</li><li>移动过程中，需要全程暂停用户应用程序。即：STW</li></ul><h4 id=原理><a href=#%e5%8e%9f%e7%90%86 class=header-anchor>#</a>
原理</h4><ul><li>Lisp2 算法</li></ul><p>Lisp2算法包括两个阶段</p><ol><li>标记</li><li>压缩</li></ol><ul><li>标记阶段：选取gc根对象。从这些对象开始向下遍历其子对象，最终可能会形成一个又向有环图。在此图中的对象就是活动对象，也就是将要压缩的对象。</li><li>整理阶段：将对象向着一端移动，移动后对象的相对顺序不变，但是对象紧临。</li></ul><p>比如：在垃圾回收前：有ABCDEF五个对象，可以看出A和E是非活动对象。其中根引用了B和D，B引用了C，D引用了F</p><p><a class=link href=https://gentlezuo.github.io/2019/08/10/gc-%e6%a0%87%e8%ae%b0%e6%95%b4%e7%90%86%e7%ae%97%e6%b3%95%e7%9a%84%e4%b8%a4%e7%a7%8d%e5%ae%9e%e7%8e%b0/%e6%a0%87%e8%ae%b0%e6%95%b4%e7%90%86-%e5%88%9d%e5%a7%8b%e7%8a%b6%e6%80%81.png target=_blank rel=noopener><img src=https://logan.1357810.xyz/img/20220424/1650805861-8a74849f44a9fe.png width=900 height=600 loading=lazy decoding=async alt=标记整理-初始状态 class="gallery-image link-image" data-flex-grow=20 data-flex-basis=20px>
<span style=white-space:nowrap><svg width=".7em" height=".7em" viewBox="0 0 21 21" xmlns="http://www.w3.org/2000/svg"><path d="m13 3 3.293 3.293-7 7 1.414 1.414 7-7L21 11V3z" fill="currentcolor"/><path d="M19 19H5V5h7l-2-2H5c-1.103.0-2 .897-2 2v14c0 1.103.897 2 2 2h14c1.103.0 2-.897 2-2v-5l-2-2v7z" fill="currentcolor"/></span></a></p><p><a class=link href=https://gentlezuo.github.io/2019/08/10/gc-%e6%a0%87%e8%ae%b0%e6%95%b4%e7%90%86%e7%ae%97%e6%b3%95%e7%9a%84%e4%b8%a4%e7%a7%8d%e5%ae%9e%e7%8e%b0/%e6%a0%87%e8%ae%b0%e6%95%b4%e7%90%86-%e5%88%9d%e5%a7%8b%e7%8a%b6%e6%80%81.png target=_blank rel=noopener>标记整理-初始状态
<span style=white-space:nowrap><svg width=".7em" height=".7em" viewBox="0 0 21 21" xmlns="http://www.w3.org/2000/svg"><path d="m13 3 3.293 3.293-7 7 1.414 1.414 7-7L21 11V3z" fill="currentcolor"/><path d="M19 19H5V5h7l-2-2H5c-1.103.0-2 .897-2 2v14c0 1.103.897 2 2 2h14c1.103.0 2-.897 2-2v-5l-2-2v7z" fill="currentcolor"/></span></a></p><p>标记结束后：
<a class=link href=https://gentlezuo.github.io/2019/08/10/gc-%e6%a0%87%e8%ae%b0%e6%95%b4%e7%90%86%e7%ae%97%e6%b3%95%e7%9a%84%e4%b8%a4%e7%a7%8d%e5%ae%9e%e7%8e%b0/%e6%a0%87%e8%ae%b0%e6%95%b4%e7%90%86-%e6%a0%87%e8%ae%b0%e5%90%8e.png target=_blank rel=noopener><img src=https://logan.1357810.xyz/img/20220424/1650805862-d5a8a37d334ca3.png width=900 height=600 loading=lazy decoding=async alt=标记整理-标记后 class="gallery-image link-image" data-flex-grow=20 data-flex-basis=20px>
<span style=white-space:nowrap><svg width=".7em" height=".7em" viewBox="0 0 21 21" xmlns="http://www.w3.org/2000/svg"><path d="m13 3 3.293 3.293-7 7 1.414 1.414 7-7L21 11V3z" fill="currentcolor"/><path d="M19 19H5V5h7l-2-2H5c-1.103.0-2 .897-2 2v14c0 1.103.897 2 2 2h14c1.103.0 2-.897 2-2v-5l-2-2v7z" fill="currentcolor"/></span></a></p><p><a class=link href=https://gentlezuo.github.io/2019/08/10/gc-%e6%a0%87%e8%ae%b0%e6%95%b4%e7%90%86%e7%ae%97%e6%b3%95%e7%9a%84%e4%b8%a4%e7%a7%8d%e5%ae%9e%e7%8e%b0/%e6%a0%87%e8%ae%b0%e6%95%b4%e7%90%86-%e6%a0%87%e8%ae%b0%e5%90%8e.png target=_blank rel=noopener>标记整理-标记后
<span style=white-space:nowrap><svg width=".7em" height=".7em" viewBox="0 0 21 21" xmlns="http://www.w3.org/2000/svg"><path d="m13 3 3.293 3.293-7 7 1.414 1.414 7-7L21 11V3z" fill="currentcolor"/><path d="M19 19H5V5h7l-2-2H5c-1.103.0-2 .897-2 2v14c0 1.103.897 2 2 2h14c1.103.0 2-.897 2-2v-5l-2-2v7z" fill="currentcolor"/></span></a></p><p>在垃圾回收后：
<a class=link href=https://gentlezuo.github.io/2019/08/10/gc-%e6%a0%87%e8%ae%b0%e6%95%b4%e7%90%86%e7%ae%97%e6%b3%95%e7%9a%84%e4%b8%a4%e7%a7%8d%e5%ae%9e%e7%8e%b0/%e6%a0%87%e8%ae%b0%e6%95%b4%e7%90%86-%e6%95%b4%e7%90%86%e5%90%8e.png target=_blank rel=noopener><img src=https://logan.1357810.xyz/img/20220424/1650805863-77f27e164022a7.png width=900 height=600 loading=lazy decoding=async alt=标记整理-整理后 class="gallery-image link-image" data-flex-grow=20 data-flex-basis=20px>
<span style=white-space:nowrap><svg width=".7em" height=".7em" viewBox="0 0 21 21" xmlns="http://www.w3.org/2000/svg"><path d="m13 3 3.293 3.293-7 7 1.414 1.414 7-7L21 11V3z" fill="currentcolor"/><path d="M19 19H5V5h7l-2-2H5c-1.103.0-2 .897-2 2v14c0 1.103.897 2 2 2h14c1.103.0 2-.897 2-2v-5l-2-2v7z" fill="currentcolor"/></span></a></p><p><a class=link href=https://gentlezuo.github.io/2019/08/10/gc-%e6%a0%87%e8%ae%b0%e6%95%b4%e7%90%86%e7%ae%97%e6%b3%95%e7%9a%84%e4%b8%a4%e7%a7%8d%e5%ae%9e%e7%8e%b0/%e6%a0%87%e8%ae%b0%e6%95%b4%e7%90%86-%e6%95%b4%e7%90%86%e5%90%8e.png target=_blank rel=noopener>标记整理-整理后
<span style=white-space:nowrap><svg width=".7em" height=".7em" viewBox="0 0 21 21" xmlns="http://www.w3.org/2000/svg"><path d="m13 3 3.293 3.293-7 7 1.414 1.414 7-7L21 11V3z" fill="currentcolor"/><path d="M19 19H5V5h7l-2-2H5c-1.103.0-2 .897-2 2v14c0 1.103.897 2 2 2h14c1.103.0 2-.897 2-2v-5l-2-2v7z" fill="currentcolor"/></span></a></p><ul><li>标记阶段算法</li></ul><p>选取gc roots，然后以深度优先或者广度优先的方式遍历。</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-5-1><a class=lnlinks href=#hl-5-1> 1</a>
</span><span class=lnt id=hl-5-2><a class=lnlinks href=#hl-5-2> 2</a>
</span><span class=lnt id=hl-5-3><a class=lnlinks href=#hl-5-3> 3</a>
</span><span class=lnt id=hl-5-4><a class=lnlinks href=#hl-5-4> 4</a>
</span><span class=lnt id=hl-5-5><a class=lnlinks href=#hl-5-5> 5</a>
</span><span class=lnt id=hl-5-6><a class=lnlinks href=#hl-5-6> 6</a>
</span><span class=lnt id=hl-5-7><a class=lnlinks href=#hl-5-7> 7</a>
</span><span class=lnt id=hl-5-8><a class=lnlinks href=#hl-5-8> 8</a>
</span><span class=lnt id=hl-5-9><a class=lnlinks href=#hl-5-9> 9</a>
</span><span class=lnt id=hl-5-10><a class=lnlinks href=#hl-5-10>10</a>
</span><span class=lnt id=hl-5-11><a class=lnlinks href=#hl-5-11>11</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl><span class=n>mark_phase</span><span class=p>(){</span>
</span></span><span class=line><span class=cl>    <span class=k>for</span><span class=p>(</span><span class=nl>r</span> <span class=p>:</span> <span class=err>$</span><span class=n>roots</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=n>mark</span><span class=p>(</span><span class=o>*</span><span class=n>r</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=n>mark</span><span class=p>(</span><span class=n>obj</span><span class=p>){</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span><span class=p>(</span><span class=n>obj</span><span class=p>.</span><span class=n>mark</span> <span class=o>==</span> <span class=n>FALSE</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=n>obj</span><span class=p>.</span><span class=n>mark</span> <span class=o>=</span> <span class=n>TRUE</span>
</span></span><span class=line><span class=cl>        <span class=k>for</span><span class=p>(</span><span class=nl>child</span> <span class=p>:</span> <span class=n>children</span><span class=p>(</span><span class=n>obj</span><span class=p>))</span>
</span></span><span class=line><span class=cl>            <span class=n>mark</span><span class=p>(</span><span class=o>*</span><span class=n>child</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div><p><code>$roots</code>为gc roots，<code>mark</code>是对象头的标记位</p><p>标记的时候可以在对象头上标记，但是这样与写时复制不兼容。当复制了一个对象，还不需要写的时候开始gc，那么就必须进行对象复制操作。为了解决这个问题可以使用位图标记，不再操作对象头，这样与写时复制兼容，并且标记与清除效率更高。</p><p>这种朴素的标记法，在标记阶段必须全局暂停，为了可以并发，可以使用三色标记法。</p><ul><li>压缩阶段具体实现</li></ul><p>lisp2中的对象中的对象：在对象头中有一个forwarding指针，指向将来该对象的位置。</p><p><a class=link href=https://gentlezuo.github.io/2019/08/10/gc-%e6%a0%87%e8%ae%b0%e6%95%b4%e7%90%86%e7%ae%97%e6%b3%95%e7%9a%84%e4%b8%a4%e7%a7%8d%e5%ae%9e%e7%8e%b0/lisp2%e4%b8%ad%e7%9a%84%e5%af%b9%e8%b1%a1.png target=_blank rel=noopener><img src=https://logan.1357810.xyz/img/20220424/1650805916-32eded84668089.png width=900 height=600 loading=lazy decoding=async alt=lisp2中的对象 class="gallery-image link-image" data-flex-grow=20 data-flex-basis=20px>
<span style=white-space:nowrap><svg width=".7em" height=".7em" viewBox="0 0 21 21" xmlns="http://www.w3.org/2000/svg"><path d="m13 3 3.293 3.293-7 7 1.414 1.414 7-7L21 11V3z" fill="currentcolor"/><path d="M19 19H5V5h7l-2-2H5c-1.103.0-2 .897-2 2v14c0 1.103.897 2 2 2h14c1.103.0 2-.897 2-2v-5l-2-2v7z" fill="currentcolor"/></span></a></p><p><a class=link href=https://gentlezuo.github.io/2019/08/10/gc-%e6%a0%87%e8%ae%b0%e6%95%b4%e7%90%86%e7%ae%97%e6%b3%95%e7%9a%84%e4%b8%a4%e7%a7%8d%e5%ae%9e%e7%8e%b0/lisp2%e4%b8%ad%e7%9a%84%e5%af%b9%e8%b1%a1.png target=_blank rel=noopener>lisp2中的对象
<span style=white-space:nowrap><svg width=".7em" height=".7em" viewBox="0 0 21 21" xmlns="http://www.w3.org/2000/svg"><path d="m13 3 3.293 3.293-7 7 1.414 1.414 7-7L21 11V3z" fill="currentcolor"/><path d="M19 19H5V5h7l-2-2H5c-1.103.0-2 .897-2 2v14c0 1.103.897 2 2 2h14c1.103.0 2-.897 2-2v-5l-2-2v7z" fill="currentcolor"/></span></a></p><p>步骤：</p><ol><li>设置forwarding指针</li><li>更新指针</li><li>移动对象</li></ol><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-6-1><a class=lnlinks href=#hl-6-1>1</a>
</span><span class=lnt id=hl-6-2><a class=lnlinks href=#hl-6-2>2</a>
</span><span class=lnt id=hl-6-3><a class=lnlinks href=#hl-6-3>3</a>
</span><span class=lnt id=hl-6-4><a class=lnlinks href=#hl-6-4>4</a>
</span><span class=lnt id=hl-6-5><a class=lnlinks href=#hl-6-5>5</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl><span class=n>compaction_phase</span><span class=p>(){</span>
</span></span><span class=line><span class=cl>    <span class=n>set_forwarding_ptr</span><span class=p>()</span>
</span></span><span class=line><span class=cl>    <span class=n>adjust_ptr</span><span class=p>()</span>
</span></span><span class=line><span class=cl>    <span class=n>move_obj</span><span class=p>()</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div><p>1.设置forwarding指针</p><p>在步骤1中，会搜索整个堆，给活动对象设置forwarding的位置。</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-7-1><a class=lnlinks href=#hl-7-1>1</a>
</span><span class=lnt id=hl-7-2><a class=lnlinks href=#hl-7-2>2</a>
</span><span class=lnt id=hl-7-3><a class=lnlinks href=#hl-7-3>3</a>
</span><span class=lnt id=hl-7-4><a class=lnlinks href=#hl-7-4>4</a>
</span><span class=lnt id=hl-7-5><a class=lnlinks href=#hl-7-5>5</a>
</span><span class=lnt id=hl-7-6><a class=lnlinks href=#hl-7-6>6</a>
</span><span class=lnt id=hl-7-7><a class=lnlinks href=#hl-7-7>7</a>
</span><span class=lnt id=hl-7-8><a class=lnlinks href=#hl-7-8>8</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>set_forwarding_ptr(){
</span></span><span class=line><span class=cl>    scan = new_address = $heap_start
</span></span><span class=line><span class=cl>    while(scan &lt; $heap_end)
</span></span><span class=line><span class=cl>        if(scan.mark == TRUE)
</span></span><span class=line><span class=cl>            scan.forwarding = new_address
</span></span><span class=line><span class=cl>            new_address += scan.size
</span></span><span class=line><span class=cl>        scan += scan.size
</span></span><span class=line><span class=cl>}
</span></span></code></pre></td></tr></table></div></div><p><code>scan</code>是搜索堆中对象的指针，<code>new_address</code>是指向目标地点的指针。当<code>scan</code>扫描到活动对象，就会将<code>new_address</code>赋值给该对象的<code>forwarding</code>，并且移动<code>new_address</code>的位置。直到结束。</p><p><a class=link href=https://gentlezuo.github.io/2019/08/10/gc-%e6%a0%87%e8%ae%b0%e6%95%b4%e7%90%86%e7%ae%97%e6%b3%95%e7%9a%84%e4%b8%a4%e7%a7%8d%e5%ae%9e%e7%8e%b0/lisp2%e8%ae%be%e7%bd%aeforwarding%e6%8c%87%e9%92%88.png target=_blank rel=noopener><img src=https://logan.1357810.xyz/img/20220424/1650805985-b88873d3bab0f8.png width=900 height=600 loading=lazy decoding=async alt=lisp2设置forwarding指针 class="gallery-image link-image" data-flex-grow=20 data-flex-basis=20px>
<span style=white-space:nowrap><svg width=".7em" height=".7em" viewBox="0 0 21 21" xmlns="http://www.w3.org/2000/svg"><path d="m13 3 3.293 3.293-7 7 1.414 1.414 7-7L21 11V3z" fill="currentcolor"/><path d="M19 19H5V5h7l-2-2H5c-1.103.0-2 .897-2 2v14c0 1.103.897 2 2 2h14c1.103.0 2-.897 2-2v-5l-2-2v7z" fill="currentcolor"/></span></a></p><p><a class=link href=https://gentlezuo.github.io/2019/08/10/gc-%e6%a0%87%e8%ae%b0%e6%95%b4%e7%90%86%e7%ae%97%e6%b3%95%e7%9a%84%e4%b8%a4%e7%a7%8d%e5%ae%9e%e7%8e%b0/lisp2%e8%ae%be%e7%bd%aeforwarding%e6%8c%87%e9%92%88.png target=_blank rel=noopener>lisp2设置forwarding指针
<span style=white-space:nowrap><svg width=".7em" height=".7em" viewBox="0 0 21 21" xmlns="http://www.w3.org/2000/svg"><path d="m13 3 3.293 3.293-7 7 1.414 1.414 7-7L21 11V3z" fill="currentcolor"/><path d="M19 19H5V5h7l-2-2H5c-1.103.0-2 .897-2 2v14c0 1.103.897 2 2 2h14c1.103.0 2-.897 2-2v-5l-2-2v7z" fill="currentcolor"/></span></a></p><p>这样做的原因是整理前的堆和整理后的堆是同一个空间，不像复制算法中的from和to可以切换。因此有必要设置forwarding的指针。</p><p>2.更新指针</p><p>第2步需要让每一个对象知道移动后子对象将来的位置。因此需要修改指针.</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-8-1><a class=lnlinks href=#hl-8-1> 1</a>
</span><span class=lnt id=hl-8-2><a class=lnlinks href=#hl-8-2> 2</a>
</span><span class=lnt id=hl-8-3><a class=lnlinks href=#hl-8-3> 3</a>
</span><span class=lnt id=hl-8-4><a class=lnlinks href=#hl-8-4> 4</a>
</span><span class=lnt id=hl-8-5><a class=lnlinks href=#hl-8-5> 5</a>
</span><span class=lnt id=hl-8-6><a class=lnlinks href=#hl-8-6> 6</a>
</span><span class=lnt id=hl-8-7><a class=lnlinks href=#hl-8-7> 7</a>
</span><span class=lnt id=hl-8-8><a class=lnlinks href=#hl-8-8> 8</a>
</span><span class=lnt id=hl-8-9><a class=lnlinks href=#hl-8-9> 9</a>
</span><span class=lnt id=hl-8-10><a class=lnlinks href=#hl-8-10>10</a>
</span><span class=lnt id=hl-8-11><a class=lnlinks href=#hl-8-11>11</a>
</span><span class=lnt id=hl-8-12><a class=lnlinks href=#hl-8-12>12</a>
</span><span class=lnt id=hl-8-13><a class=lnlinks href=#hl-8-13>13</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>adjust_ptr(){
</span></span><span class=line><span class=cl>    //更改根的指针
</span></span><span class=line><span class=cl>    for(r : $roots)
</span></span><span class=line><span class=cl>        *r = (*r).forwarding
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    scan = $heap_start
</span></span><span class=line><span class=cl>    while(scan &lt; $heap_end)
</span></span><span class=line><span class=cl>        //如果标记过，就将子对象设置为子对象将来的位置（forwarding）
</span></span><span class=line><span class=cl>        if(scan.mark == TRUE)
</span></span><span class=line><span class=cl>            for(child : children(scan))
</span></span><span class=line><span class=cl>                *child = (*child).forwarding
</span></span><span class=line><span class=cl>        scan += scan.size
</span></span><span class=line><span class=cl>}
</span></span></code></pre></td></tr></table></div></div><p>这里的scan与上面的scan作用相同。</p><p><a class=link href=https://gentlezuo.github.io/2019/08/10/gc-%e6%a0%87%e8%ae%b0%e6%95%b4%e7%90%86%e7%ae%97%e6%b3%95%e7%9a%84%e4%b8%a4%e7%a7%8d%e5%ae%9e%e7%8e%b0/lisp2%e6%9b%b4%e6%94%b9%e6%8c%87%e9%92%88.png target=_blank rel=noopener><img src=https://logan.1357810.xyz/img/20220424/1650805986-5b223869421e91.png width=900 height=600 loading=lazy decoding=async alt=更改指针 class="gallery-image link-image" data-flex-grow=20 data-flex-basis=20px>
<span style=white-space:nowrap><svg width=".7em" height=".7em" viewBox="0 0 21 21" xmlns="http://www.w3.org/2000/svg"><path d="m13 3 3.293 3.293-7 7 1.414 1.414 7-7L21 11V3z" fill="currentcolor"/><path d="M19 19H5V5h7l-2-2H5c-1.103.0-2 .897-2 2v14c0 1.103.897 2 2 2h14c1.103.0 2-.897 2-2v-5l-2-2v7z" fill="currentcolor"/></span></a></p><p><a class=link href=https://gentlezuo.github.io/2019/08/10/gc-%e6%a0%87%e8%ae%b0%e6%95%b4%e7%90%86%e7%ae%97%e6%b3%95%e7%9a%84%e4%b8%a4%e7%a7%8d%e5%ae%9e%e7%8e%b0/lisp2%e6%9b%b4%e6%94%b9%e6%8c%87%e9%92%88.png target=_blank rel=noopener>更改指针
<span style=white-space:nowrap><svg width=".7em" height=".7em" viewBox="0 0 21 21" xmlns="http://www.w3.org/2000/svg"><path d="m13 3 3.293 3.293-7 7 1.414 1.414 7-7L21 11V3z" fill="currentcolor"/><path d="M19 19H5V5h7l-2-2H5c-1.103.0-2 .897-2 2v14c0 1.103.897 2 2 2h14c1.103.0 2-.897 2-2v-5l-2-2v7z" fill="currentcolor"/></span></a></p><p>3.移动对象</p><p>第3步，移动对象，过程很简单，每个对象都知道要去的地址，只需要顺序移动便可，然后清除之前的标记。注意要顺序移动，不然会覆盖掉活动对象。</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-9-1><a class=lnlinks href=#hl-9-1> 1</a>
</span><span class=lnt id=hl-9-2><a class=lnlinks href=#hl-9-2> 2</a>
</span><span class=lnt id=hl-9-3><a class=lnlinks href=#hl-9-3> 3</a>
</span><span class=lnt id=hl-9-4><a class=lnlinks href=#hl-9-4> 4</a>
</span><span class=lnt id=hl-9-5><a class=lnlinks href=#hl-9-5> 5</a>
</span><span class=lnt id=hl-9-6><a class=lnlinks href=#hl-9-6> 6</a>
</span><span class=lnt id=hl-9-7><a class=lnlinks href=#hl-9-7> 7</a>
</span><span class=lnt id=hl-9-8><a class=lnlinks href=#hl-9-8> 8</a>
</span><span class=lnt id=hl-9-9><a class=lnlinks href=#hl-9-9> 9</a>
</span><span class=lnt id=hl-9-10><a class=lnlinks href=#hl-9-10>10</a>
</span><span class=lnt id=hl-9-11><a class=lnlinks href=#hl-9-11>11</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>move_obj(){
</span></span><span class=line><span class=cl>    scan = $free = $heap_start
</span></span><span class=line><span class=cl>    while(scan &lt; $heap_end)
</span></span><span class=line><span class=cl>        if(scan.mark == TRUE)
</span></span><span class=line><span class=cl>            new_address = scan.forwarding
</span></span><span class=line><span class=cl>            copy_data(new_address, scan, scan.size)
</span></span><span class=line><span class=cl>            new_address.forwarding = NULL
</span></span><span class=line><span class=cl>            new_address.mark = FALSE
</span></span><span class=line><span class=cl>            $free += new_address.size
</span></span><span class=line><span class=cl>            scan += scan.size
</span></span><span class=line><span class=cl>}
</span></span></code></pre></td></tr></table></div></div><p><a class=link href=https://gentlezuo.github.io/2019/08/10/gc-%e6%a0%87%e8%ae%b0%e6%95%b4%e7%90%86%e7%ae%97%e6%b3%95%e7%9a%84%e4%b8%a4%e7%a7%8d%e5%ae%9e%e7%8e%b0/lisp2%e6%95%b4%e7%90%86%e5%90%8e.png target=_blank rel=noopener><img src=https://logan.1357810.xyz/img/20220424/1650806883-3e0060773b491d.png width=900 height=600 loading=lazy decoding=async alt=lisp2整理后 class="gallery-image link-image" data-flex-grow=20 data-flex-basis=20px>
<span style=white-space:nowrap><svg width=".7em" height=".7em" viewBox="0 0 21 21" xmlns="http://www.w3.org/2000/svg"><path d="m13 3 3.293 3.293-7 7 1.414 1.414 7-7L21 11V3z" fill="currentcolor"/><path d="M19 19H5V5h7l-2-2H5c-1.103.0-2 .897-2 2v14c0 1.103.897 2 2 2h14c1.103.0 2-.897 2-2v-5l-2-2v7z" fill="currentcolor"/></span></a></p><p><a class=link href=https://gentlezuo.github.io/2019/08/10/gc-%e6%a0%87%e8%ae%b0%e6%95%b4%e7%90%86%e7%ae%97%e6%b3%95%e7%9a%84%e4%b8%a4%e7%a7%8d%e5%ae%9e%e7%8e%b0/lisp2%e6%95%b4%e7%90%86%e5%90%8e.png target=_blank rel=noopener>lisp2整理后
<span style=white-space:nowrap><svg width=".7em" height=".7em" viewBox="0 0 21 21" xmlns="http://www.w3.org/2000/svg"><path d="m13 3 3.293 3.293-7 7 1.414 1.414 7-7L21 11V3z" fill="currentcolor"/><path d="M19 19H5V5h7l-2-2H5c-1.103.0-2 .897-2 2v14c0 1.103.897 2 2 2h14c1.103.0 2-.897 2-2v-5l-2-2v7z" fill="currentcolor"/></span></a></p><p>时间复杂度</p><ol><li>标记阶段：遍历所有的存活对象，与活动对象数成正比</li><li>设置forwarding指针阶段：扫描整个堆</li><li>更改子对象指针阶段：扫描整个堆</li><li>移动阶段：扫描整个堆</li></ol><p>优点</p><ul><li>相比于标记清除与引用计数：没有内存碎片</li><li>相比于复制算法：有效利用堆</li></ul><p>缺点</p><p>一次遍历活动对象+三次扫描整个堆，吞吐量较小。</p><p><a class=link href=https://gentlezuo.github.io/2019/08/10/gc- target=_blank rel=noopener>https://gentlezuo.github.io/2019/08/10/gc-
<span style=white-space:nowrap><svg width=".7em" height=".7em" viewBox="0 0 21 21" xmlns="http://www.w3.org/2000/svg"><path d="m13 3 3.293 3.293-7 7 1.414 1.414 7-7L21 11V3z" fill="currentcolor"/><path d="M19 19H5V5h7l-2-2H5c-1.103.0-2 .897-2 2v14c0 1.103.897 2 2 2h14c1.103.0 2-.897 2-2v-5l-2-2v7z" fill="currentcolor"/></span>
</a>标记整理算法的两种实现/#双指针算法</p><h3 id=1128-小结><a href=#1128-%e5%b0%8f%e7%bb%93 class=header-anchor>#</a>
11.2.8. 小结</h3><div class=table-wrapper><table><thead><tr><th style=text-align:left></th><th style=text-align:left>Mark-Sweep标记清除</th><th style=text-align:left>Mark-Compact标记整理</th><th style=text-align:left>Copying复制算法</th></tr></thead><tbody><tr><td style=text-align:left><strong>速率</strong></td><td style=text-align:left>中等</td><td style=text-align:left>最慢</td><td style=text-align:left>最快</td></tr><tr><td style=text-align:left><strong>空间开销</strong></td><td style=text-align:left>少（但会堆积碎片）</td><td style=text-align:left>少（不堆积碎片）</td><td style=text-align:left>通常需要活对象的 2 倍空间（不堆积碎片）</td></tr><tr><td style=text-align:left><strong>移动对象</strong></td><td style=text-align:left>否</td><td style=text-align:left>是</td><td style=text-align:left>是</td></tr><tr><td style=text-align:left>对象申请内存</td><td style=text-align:left>虚拟机维护空闲空间列表</td><td style=text-align:left>指针碰撞</td><td style=text-align:left>指针碰撞</td></tr><tr><td style=text-align:left>STW</td><td style=text-align:left>是</td><td style=text-align:left>是</td><td style=text-align:left>是</td></tr></tbody></table></div><p>效率上来说，复制算法是当之无愧的老大，但是却浪费了太多内存。</p><p>而为了尽量兼顾上面提到的三个指标，标记-整理算法相对来说更平滑一些，但是效率上不尽如人意，它比复制算法多了一个标记的阶段，比标记-清除多了一个整理内存的阶段</p><p>难道就没有一种最优算法吗？</p><p>回答：无，没有最好的算法，只有最合适的算法。</p><p><img src=https://logan.1357810.xyz/img/20220422/152946273-c9b17364d3.png width=900 height=600 loading=lazy decoding=async alt=image-20210512104415281 class="gallery-image link-image" data-flex-grow=20 data-flex-basis=20px></p><h3 id=1129-分代收集算法><a href=#1129-%e5%88%86%e4%bb%a3%e6%94%b6%e9%9b%86%e7%ae%97%e6%b3%95 class=header-anchor>#</a>
11.2.9. 分代收集算法</h3><p>前面所有这些算法中，并没有一种算法可以完全替代其他算法，它们都具有自己独特的优势和特点。分代收集算法应运而生。</p><p>分代收集算法，是基于这样一个事实：不同的对象的生命周期是不一样的。因此，<mark>不同生命周期的对象可以采取不同的收集方式</mark>，以便提高回收效率。一般是把 Java 堆分为新生代和老年代，这样就可以根据各个年代的特点使用不同的回收算法，以提高垃圾回收的效率。</p><p>在 Java 程序运行的过程中，会产生大量的对象，其中有些对象是与业务信息相关，比如<mark>Http 请求中的 Session 对象、线程、Socket 连接</mark>，这类对象跟业务直接挂钩，因此生命周期比较长。但是还有一些对象，主要是程序运行过程中生成的临时变量，这些对象生命周期会比较短，比如：<mark>String 对象</mark>，由于其不变类的特性，系统会产生大量的这些对象，有些对象甚至只用一次即可回收。</p><p><mark>目前几乎所有的 GC 都采用分代手机算法执行垃圾回收的。</mark></p><p>在 HotSpot 中，基于分代的概念，GC 所使用的内存回收算法必须结合年轻代和老年代各自的特点。</p><h4 id=年轻代young-gen><a href=#%e5%b9%b4%e8%bd%bb%e4%bb%a3young-gen class=header-anchor>#</a>
年轻代（Young Gen）</h4><p>年轻代特点：区域相对老年代较小，对象生命周期短、存活率低，回收频繁。</p><p>这种情况复制算法的回收整理，速度是最快的。复制算法的效率只和当前存活对象大小有关，因此很适用于年轻代的回收。而复制算法内存利用率不高的问题，通过 hotspot 中的两个 survivor 的设计得到缓解。</p><h4 id=老年代tenured-gen><a href=#%e8%80%81%e5%b9%b4%e4%bb%a3tenured-gen class=header-anchor>#</a>
老年代（Tenured Gen）</h4><p>老年代特点：区域较大，对象生命周期长、存活率高，回收不及年轻代频繁。</p><p>这种情况存在大量存活率高的对象，复制算法明显变得不合适。一般是由标记-清除或者是标记-清除与标记-整理的混合实现。</p><ul><li>Mark 阶段的开销与存活对象的数量成正比。</li><li>Sweep 阶段的开销与所管理区域的大小成正相关。</li><li>Compact 阶段的开销与存活对象的数据成正比。</li></ul><p>以 HotSpot 中的 CMS 回收器为例，CMS 是基于 Mark-Sweep 实现的，对于对象的回收效率很高。而对于碎片问题，CMS 采用基于 Mark-Compact 算法的 Serial Old 回收器作为补偿措施：当内存回收不佳（碎片导致的 Concurrent Mode Failure 时），将采用 Serial Old 执行 Full GC 以达到对老年代内存的整理。</p><p>分代的思想被现有的虚拟机广泛使用。几乎所有的垃圾回收器都区分新生代和老年代</p><h3 id=112x-增量收集算法分区算法><a href=#112x-%e5%a2%9e%e9%87%8f%e6%94%b6%e9%9b%86%e7%ae%97%e6%b3%95%e5%88%86%e5%8c%ba%e7%ae%97%e6%b3%95 class=header-anchor>#</a>
11.2.X. 增量收集算法、分区算法</h3><h4 id=增量收集算法><a href=#%e5%a2%9e%e9%87%8f%e6%94%b6%e9%9b%86%e7%ae%97%e6%b3%95 class=header-anchor>#</a>
增量收集算法</h4><p>上述现有的算法，在垃圾回收过程中，应用软件将处于一种 Stop the World 的状态。在 Stop the World 状态下，应用程序所有的线程都会挂起，暂停一切正常的工作，等待垃圾回收的完成。如果垃圾回收时间过长，应用程序会被挂起很久，将<mark>严重影响用户体验或者系统的稳定性</mark>。为了解决这个问题，即对实时垃圾收集算法的研究直接导致了增量收集（Incremental Collecting）算法的诞生。</p><h5 id=基本思想><a href=#%e5%9f%ba%e6%9c%ac%e6%80%9d%e6%83%b3 class=header-anchor>#</a>
基本思想</h5><p>如果一次性将所有的垃圾进行处理，需要造成系统长时间的停顿，那么就可以让垃圾收集线程和应用程序线程交替执行。每次，<mark>垃圾收集线程只收集一小片区域的内存空间，接着切换到应用程序线程。依次反复，直到垃圾收集完成</mark>。</p><p>总的来说，增量收集算法的基础仍是传统的标记-清除和复制算法。增量收集算法通过<mark>对线程间冲突的妥善处理，允许垃圾收集线程以分阶段的方式完成标记、清理或复制工作</mark></p><h5 id=缺点-3><a href=#%e7%bc%ba%e7%82%b9-3 class=header-anchor>#</a>
缺点</h5><p>使用这种方式，由于在垃圾回收过程中，间断性地还执行了应用程序代码，所以能减少系统的停顿时间。但是，因为线程切换和上下文转换的消耗，会使得垃圾回收的总体成本上升，<mark>造成系统吞吐量的下降</mark>。</p><h4 id=分区算法><a href=#%e5%88%86%e5%8c%ba%e7%ae%97%e6%b3%95 class=header-anchor>#</a>
分区算法</h4><p>一般来说，在相同条件下，堆空间越大，一次 Gc 时所需要的时间就越长，有关 GC 产生的停顿也越长。为了更好地控制 GC 产生的停顿时间，将一块大的内存区域分割成多个小块，根据目标的停顿时间，每次合理地回收若干个小区间，而不是整个堆空间，从而减少一次 GC 所产生的停顿。</p><p>分代算法将按照对象的生命周期长短划分成两个部分，分区算法将整个堆空间划分成连续的不同小区间。</p><p>每一个小区间都独立使用，独立回收。这种算法的好处是可以控制一次回收多少个小区间。</p><p><img src=https://logan.1357810.xyz/img/20220422/152946273-e98086f4eb.png width=900 height=600 loading=lazy decoding=async alt=image-20200712165318590 class="gallery-image link-image" data-flex-grow=20 data-flex-basis=20px></p><h4 id=写到最后><a href=#%e5%86%99%e5%88%b0%e6%9c%80%e5%90%8e class=header-anchor>#</a>
写到最后</h4><p>注意，这些只是基本的算法思路，实际 GC 实现过程要复杂的多，目前还在发展中的前沿 GC 都是复合算法，并且并行和并发兼备。</p></section><footer class=article-footer><section class=article-tags><a href=/tags/jvm/>JVM</a></section><section class=article-copyright><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-copyright" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><circle cx="12" cy="12" r="9"/><path d="M14.5 9a3.5 4 0 100 6"/></svg>
<span>true</span></section><section class=article-lastmod><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-clock" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><circle cx="12" cy="12" r="9"/><polyline points="12 7 12 12 15 15"/></svg>
<span>最后更新于 2024年5月4日 14:09</span></section></footer></article><aside class=related-content--wrapper><h2 class=section-title>相关文章</h2><div class=related-content><div class="flex article-list--tile"><article><a href=/p/2024/05/11895611/><div class=article-details><h2 class=article-title>01-概述篇</h2></div></a></article><article><a href=/p/2024/05/14915117/><div class=article-details><h2 class=article-title>02-JVM监控及诊断工具-命令行篇</h2></div></a></article><article><a href=/p/2024/05/49167149/><div class=article-details><h2 class=article-title>03-JVM监控及诊断工具-GUI篇</h2></div></a></article><article><a href=/p/2024/05/84511784/><div class=article-details><h2 class=article-title>03-运行时数据区及程序计数器</h2></div></a></article><article><a href=/p/2024/05/45117945/><div class=article-details><h2 class=article-title>04-JVM运行时参数</h2></div></a></article></div></div></aside><link rel=preload as=style onload='this.rel="stylesheet"' href=https://cdn.bootcdn.net/ajax/libs/waline/2.9.1/waline.min.css crossorigin=anonymous><script src=https://cdn.bootcdn.net/ajax/libs/waline/2.9.1/waline.min.js crossorigin=anonymous></script><div id=waline class=waline-container></div><style>.waline-container{background-color:var(--card-background);border-radius:var(--card-border-radius);box-shadow:var(--shadow-l1);padding:var(--card-padding);--waline-font-size:var(--article-font-size)}.waline-container .wl-count{color:var(--card-text-color-main)}</style><script>Waline.init({dark:'html[data-scheme="dark"]',el:"#waline",emoji:["https://cdn.jsdelivr.net/gh/walinejs/emojis/weibo"],lang:"zh-cn",locale:{admin:"Admin",placeholder:null},requiredMeta:["nick"],serverURL:"https://waline.wssw.fun/"})</script><footer class=site-footer><section class=copyright>&copy;
2020 -
2024 &nbsp;&nbsp;by &nbsp; logan</section><section class=powerby>发表了79篇文章 ·
总计439.85k字</section><section class=powerby><div class=powerby><span id=busuanzi_container_site_pv>本站总访问量<span id=busuanzi_value_site_pv></span>次
</span><span id=busuanzi_container_site_uv>本站访客数<span id=busuanzi_value_site_uv></span>人次</span></div></section></footer><div class=pswp tabindex=-1 role=dialog aria-hidden=true><div class=pswp__bg></div><div class=pswp__scroll-wrap><div class=pswp__container><div class=pswp__item></div><div class=pswp__item></div><div class=pswp__item></div></div><div class="pswp__ui pswp__ui--hidden"><div class=pswp__top-bar><div class=pswp__counter></div><button class="pswp__button pswp__button--close" title="Close (Esc)"></button>
<button class="pswp__button pswp__button--share" title=Share></button>
<button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button>
<button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button><div class=pswp__preloader><div class=pswp__preloader__icn><div class=pswp__preloader__cut><div class=pswp__preloader__donut></div></div></div></div></div><div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap"><div class=pswp__share-tooltip></div></div><button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)">
</button>
<button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)"></button><div class=pswp__caption><div class=pswp__caption__center></div></div></div></div></div><script src=https://cdn.bootcdn.net/ajax/libs/photoswipe/4.1.3/photoswipe.min.js crossorigin=anonymous defer></script><link rel=preload as=style onload='this.rel="stylesheet"' href=https://cdn.bootcdn.net/ajax/libs/photoswipe/4.1.3/photoswipe.min.css crossorigin=anonymous><script src=https://cdn.bootcdn.net/ajax/libs/photoswipe/4.1.3/photoswipe-ui-default.min.js crossorigin=anonymous defer></script><link rel=preload as=style onload='this.rel="stylesheet"' href=https://cdn.bootcdn.net/ajax/libs/photoswipe/4.1.3/default-skin/default-skin.min.css crossorigin=anonymous></main></div><script type=text/javascript src=/ts/main.js defer></script><a href=javascript:void(0) class=right_things id=back-to-top title=返回顶部></a><style>html{scroll-behavior:smooth}#back-to-top{z-index:998!important;transition:1.5s ease,opacity 2s ease,visibility 2s ease,right .8s ease;opacity:0;display:inline-block;visibility:hidden;position:fixed;bottom:10px;right:10px;width:55px;height:55px;font-size:30px;text-align:center;line-height:50px;border-radius:20px;box-shadow:var(--shadow-l1);cursor:pointer;color:var(--body-text-color);background-image:linear-gradient(-20deg,#e9defa 0%,#fbfcdb 100%); [data-scheme="dark"] & { background-image: linear-gradient(60deg, #241348 0%, #4d0404 100%); }}#back-to-top:before{content:' ';display:inline-block;position:relative;top:0;transform:rotate(135deg);height:10px;width:10px;border-width:0 0 2px 2px;border-style:solid}#back-to-top:hover{transform:scale(1.1,1.1);background-image:linear-gradient(-225deg,#E3FDF5 0%,#FFE6FA 100%); [data-scheme="dark"] & { background-image: linear-gradient(60deg, #432581 0%, #861818 100%); }}#back-to-top:hover:before{border-color:#2674e0}@media screen and (max-width:768px){#back-to-top{width:35px;height:35px;font-size:10px;right:15px}}</style><script>function resizeRight(){var t=document.querySelectorAll(".right_things"),e=window.innerWidth;t.length>0&&t.forEach(function(t){e>2100?t.style.right="280px":e>1800?t.style.right="120px":e<1800&&(t.style.right="10px")})}window.addEventListener("resize",function(){requestAnimationFrame(resizeRight)});function backToTop(){window.scrollTo({top:0,behavior:"smooth"})}window.onload=function(){requestAnimationFrame(resizeRight);var t=this.document.documentElement.scrollTop||this.document.body.scrollTop,e=this.document.getElementById("back-to-top");t>0?(e.style.visibility="visible",e.style.opacity="1"):(e.style.opacity="0",e.style.visibility="hidden")},window.onscroll=function(){var t=this.document.documentElement.scrollTop||this.document.body.scrollTop,e=this.document.getElementById("back-to-top");t<400?(e.style.opacity="0",e.style.visibility="hidden"):(e.style.visibility="visible",e.style.opacity="1",e.addEventListener("click",backToTop,!1))}</script><style>.toggle-toc-inner,.toggle-toc-inner svg{z-index:1!important;pointer-events:none}.toggle-toc-inner{width:100%;height:100%;display:flex;align-items:center;justify-content:center}.toggle-toc-inner svg{display:none}#toc-container{display:none;position:fixed;bottom:120px;right:80px;padding:10px;border:1px solid #96979a50;border-radius:var(--card-border-radius);box-shadow:rgba(14,30,37,.12)0 2px 4px,rgba(14,30,37,.32)0 2px 16px;z-index:997!important;max-height:80vh;overflow-y:auto;width:auto;max-width:290px;background-image:linear-gradient(-20deg,#e9defa 0%,#fbfcdb 100%); [data-scheme="dark"] & { background-image: linear-gradient(45deg, #8baaaa 0%, #ae8b9c 100%); color: #FFFFFFB2; }}#TableOfContents{background-image:linear-gradient(-20deg,#e9defa 0%,#fbfcdb 100%); [data-scheme="dark"] & { background-image: linear-gradient(45deg, #8baaaa 0%, #ae8b9c 100%); }}#TableOfContents a:hover{font-weight:bolder}[data-scheme=dark] #TableOfContents a{color:#212223}[data-scheme=dark] #TableOfContents a:hover{color:#052ed3}#toggle-toc{transition:1.5s ease,opacity 2s ease,visibility 2s ease,right .8s ease;opacity:0;display:block;visibility:hidden;position:fixed;bottom:75px;right:10px;width:55px;height:55px;font-size:1.7rem;padding:5px;z-index:1000!important;border:0 solid #96979a50;border-radius:20px;box-shadow:var(--shadow-l1);color:#707070;cursor:pointer;background-image:linear-gradient(-20deg,#e9defa 0%,#fbfcdb 100%); [data-scheme="dark"] & { background-image: linear-gradient(60deg, #241348 0%, #4d0404 100%); color: #FFFFFFB2; } animation: jump 0.3s 4;animation-delay:.6s}#toggle-toc:hover{transform:scale(1.1,1.1);background-image:linear-gradient(-225deg,#E3FDF5 0%,#FFE6FA 100%); [data-scheme="dark"] & { background-image: linear-gradient(60deg, #432581 0%, #861818 100%); }}.widget--toc #TableOfContents{overflow-x:auto;max-height:66vh;width:auto}.toggle-toc-inner::before{content:'目录'}@media screen and (max-width:768px){#toggle-toc{width:35px;height:35px;font-size:10px;bottom:60px;right:15px}.toggle-toc-inner::before{content:''}.toggle-toc-inner svg{display:block}#toc-container{bottom:100px;right:60px}}</style><a id=toggle-toc class=right_things title=目录 href=javascript:void(0)><div class=toggle-toc-inner><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-menu-2" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"/><path d="M4 6h16"/><path d="M4 12h16"/><path d="M4 18h16"/></svg></div></a><section class="widget archives" id=toc-container><h2 class=section-title>目录</h2><div class=widget--toc><nav id=TableOfContents><ol><li><a href=#11-垃圾回收概述及算法>11. 垃圾回收概述及算法</a><ol><li><a href=#111-垃圾回收概述>11.1. 垃圾回收概述</a><ol><li><a href=#1111-什么是垃圾>11.1.1. 什么是垃圾？</a><ol><li><a href=#什么是垃圾>什么是垃圾？</a></li></ol></li></ol></li><li><a href=#1112-为什么需要-gc>11.1.2. 为什么需要 GC</a></li><li><a href=#1113-早期垃圾回收>11.1.3. 早期垃圾回收</a></li><li><a href=#1114-java-垃圾回收机制>11.1.4. Java 垃圾回收机制</a><ol><li><ol><li><a href=#担忧>担忧</a></li><li><a href=#gc-主要关注的区域>GC 主要关注的区域</a></li></ol></li></ol></li><li><a href=#112-垃圾回收相关算法>11.2. 垃圾回收相关算法</a><ol><li><a href=#1121-标记阶段引用计数算法>11.2.1. 标记阶段：引用计数算法</a><ol><li><a href=#方式一引用计数算法>方式一：引用计数算法</a></li><li><a href=#循环引用>循环引用</a></li><li><a href=#小结>小结</a></li></ol></li><li><a href=#1122-标记阶段可达性分析算法>11.2.2. 标记阶段：可达性分析算法</a><ol><li><a href=#可达性分析算法根搜索算法追踪性垃圾收集>可达性分析算法（根搜索算法、追踪性垃圾收集）</a></li><li><a href=#基本思路>基本思路</a></li></ol></li><li><a href=#1123-对象的-finalization-机制>11.2.3. 对象的 finalization 机制</a><ol><li><a href=#生存还是死亡>生存还是死亡？</a></li><li><a href=#具体过程>具体过程</a></li></ol></li><li><a href=#1124-mat-与-jprofiler-的-gc-roots-溯源>11.2.4. MAT 与 JProfiler 的 GC Roots 溯源</a><ol><li><a href=#mat-是什么>MAT 是什么？</a></li><li><a href=#获取-dump-文件>获取 dump 文件</a><ol><li><a href=#方式一命令行使用-jmap>方式一：命令行使用 jmap</a></li><li><a href=#方式二使用-jvisualvm-导出>方式二：使用 JVisualVM 导出</a></li><li><a href=#方式三使用-mat-打开-dump-文件>方式三：使用 MAT 打开 Dump 文件</a></li></ol></li><li><a href=#jprofiler-的-gc-roots-溯源>JProfiler 的 GC Roots 溯源</a></li></ol></li><li><a href=#1125-清除阶段标记-清除算法>11.2.5. 清除阶段：标记-清除算法</a><ol><li><a href=#标记-清除算法mark-sweep>标记-清除算法（Mark-Sweep）</a></li><li><a href=#执行过程>执行过程</a></li><li><a href=#缺点>缺点</a></li><li><a href=#何为清除>何为清除？</a></li></ol></li><li><a href=#1126-清除阶段复制算法>11.2.6. 清除阶段：复制算法</a><ol><li><a href=#复制copying算法>复制（Copying）算法</a></li><li><a href=#核心思想>核心思想</a></li><li><a href=#优点>优点</a></li><li><a href=#缺点-1>缺点</a></li><li><a href=#特别的>特别的</a></li><li><a href=#应用场景>应用场景</a></li></ol></li><li><a href=#1127-清除阶段标记-压缩整理算法>11.2.7. 清除阶段：标记-压缩（整理）算法</a><ol><li><a href=#标记-压缩或标记-整理mark-compact算法>标记-压缩（或标记-整理、Mark-Compact）算法</a></li><li><a href=#执行过程-1>执行过程</a></li><li><a href=#指针碰撞bump-the-pointer>指针碰撞（Bump the Pointer）</a></li><li><a href=#优点-1>优点</a></li><li><a href=#缺点-2>缺点</a></li><li><a href=#原理>原理</a></li></ol></li><li><a href=#1128-小结>11.2.8. 小结</a></li><li><a href=#1129-分代收集算法>11.2.9. 分代收集算法</a><ol><li><a href=#年轻代young-gen>年轻代（Young Gen）</a></li><li><a href=#老年代tenured-gen>老年代（Tenured Gen）</a></li></ol></li><li><a href=#112x-增量收集算法分区算法>11.2.X. 增量收集算法、分区算法</a><ol><li><a href=#增量收集算法>增量收集算法</a><ol><li><a href=#基本思想>基本思想</a></li><li><a href=#缺点-3>缺点</a></li></ol></li><li><a href=#分区算法>分区算法</a></li><li><a href=#写到最后>写到最后</a></li></ol></li></ol></li></ol></li></ol></nav></div></section><script>var toggleButton=document.getElementById("toggle-toc"),tocContainer=document.getElementById("toc-container"),scrollThreshold=400;function extracted(){var e=window.scrollY||window.pageYOffset;e>=scrollThreshold?(toggleButton.style.visibility="visible",toggleButton.style.opacity="1"):(toggleButton.style.opacity="0",toggleButton.style.visibility="hidden")}window.addEventListener("scroll",function(){extracted()}),window.onload=function(){extracted()},toggleButton.addEventListener("click",function(e){tocContainer.style.display==="none"||tocContainer.style.display===""?tocContainer.style.display="block":tocContainer.style.display="none",e.stopPropagation()}),"ontouchstart"in window||toggleButton.addEventListener("mouseover",function(){tocContainer.style.display="block"}),document.addEventListener("click",function(e){!tocContainer.contains(e.target)&&!toggleButton.contains(e.target)&&e.target!==toggleButton&&e.target!==tocContainer&&(tocContainer.style.display="none")})</script><script src=https://cdn.bootcdn.net/ajax/libs/nprogress/0.2.0/nprogress.min.js crossorigin=anonymous></script><div class=top-scroll-bar></div><style>.top-scroll-bar,.page-load-progress-bar{position:fixed;top:0;left:0;z-index:9999;display:none;width:0;height:4px;border-radius:5px;background-image:linear-gradient(to right,#5a0ca6 0%,rgba(208,114,155,.84) 50%,#29d 100%); [data-scheme="light"] & { background-image: linear-gradient(to right, #78ee6e 0%, #5069e3 50%, #29d 100%); }}#nprogress{pointer-events:none}#nprogress .my_bar{background-image:linear-gradient(to right,#5a0ca6 0%,rgba(208,114,155,.84) 50%,#29d 100%); [data-scheme="light"] & { background-image: linear-gradient(to right, #78ee6e 0%, #5069e3 50%, #29d 100%); } position: fixed;z-index:9999;top:0;left:0;border-radius:10px;width:100%;height:5px}#nprogress .my_peg{display:block;position:absolute;right:0;width:100px;height:100%;box-shadow:0 0 10px #29d,0 0 5px #29d;opacity:1;-webkit-transform:rotate(3deg)translate(0,-4px);-ms-transform:rotate(3deg)translate(0,-4px);transform:rotate(3deg)translate(0,-4px)}#nprogress .my_spinner{display:block;position:fixed;z-index:1031;top:15px;right:15px}#nprogress .my_spinner-icon{width:25px;height:25px;box-sizing:border-box;border:solid 3px transparent;border-top-color:#29d;border-left-color:#29d;border-radius:50%;-webkit-animation:nprogress-spinner 400ms linear infinite;animation:nprogress-spinner 400ms linear infinite}.nprogress-custom-parent{overflow:hidden;position:relative}.nprogress-custom-parent #nprogress .my_spinner,.nprogress-custom-parent #nprogress .my_bar{position:absolute}@-webkit-keyframes nprogress-spinner{0%{-webkit-transform:rotate(0)}100%{-webkit-transform:rotate(360deg)}}@keyframes nprogress-spinner{0%{transform:rotate(0)}100%{transform:rotate(360deg)}}</style><script>var my_template='<div class="my_bar" role="bar"><div class="my_peg"></div></div><div class="my_spinner" role="spinner"><div class="my_spinner-icon"></div></div>';NProgress.configure({template:my_template}),NProgress.start(),document.addEventListener("readystatechange",()=>{if(document.readyState==="interactive"&&NProgress.inc(.6),document.readyState==="complete"){NProgress.done(!0),NProgress.configure({template:my_template,minimum:0,trickle:!1,showSpinner:!1});var e=document.querySelector(".top-scroll-bar");window.addEventListener("scroll",function(){var t=document.documentElement.scrollTop||document.body.scrollTop,n=document.documentElement.scrollHeight-document.documentElement.clientHeight,s=t/n*100;e.style.width=s+"%",e.style.display="block"})}})</script><script>function loadScript(e,t){var n=document.querySelector('script[src="'+e+'"]'),s=!1;n.onload=function(){s||(s=!0,t&&window[t]())},n.onreadystatechange=function(){!s&&(n.readyState==="loaded"||n.readyState==="complete")&&(s=!0,t&&window[t]())}}</script></body></html>